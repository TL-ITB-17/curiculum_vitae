[{"authors":["admin"],"categories":null,"content":"The author is a master\u0026rsquo;s student in Environmental Engineering, Institut Teknologi Bandung with fields of Technology and Environmental Management. Currently active writers in communities such as R Indonesia and Machine Learning ID.\nBesides being active in the community, the writer is also active in writing blogs. The theme of the blog that the author makes is related to data analytics and environmental modeling.\n","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"598b63dd58b43bce02403646f240cd3c","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"author","summary":"The author is a master\u0026rsquo;s student in Environmental Engineering, Institut Teknologi Bandung with fields of Technology and Environmental Management. Currently active writers in communities such as R Indonesia and Machine Learning ID.\nBesides being active in the community, the writer is also active in writing blogs. The theme of the blog that the author makes is related to data analytics and environmental modeling.","tags":null,"title":"Mohammad Rosidi, S.T.","type":"author"},{"authors":null,"categories":null,"content":"\r\rbody{\rtext-align: justify}\r\rPada section ini penulis akan menyajikan beberapa tutorial terkait analisa data dan modeling menggunakan R. Tutorial secara garis besar akan membahas:\n\rAnalisa dan modeling data menggunakan metode statistik di R\rAnalisa dan modeling lingkungan menggunakan R\rOptimasi operasi menggunakan R\r\rPembahasan juga akan meliputi analisa statistik menggunakan GUI R (R Commander) untuk menganalisa data.\n","date":1551373200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1551373200,"objectID":"fe0f055b9d498b98f202fea04c5beccd","permalink":"/tutorial/","publishdate":"2019-03-01T00:00:00+07:00","relpermalink":"/tutorial/","section":"tutorial","summary":"body{\rtext-align: justify}\r\rPada section ini penulis akan menyajikan beberapa tutorial terkait analisa data dan modeling menggunakan R. Tutorial secara garis besar akan membahas:\n\rAnalisa dan modeling data menggunakan metode statistik di R\rAnalisa dan modeling lingkungan menggunakan R\rOptimasi operasi menggunakan R\r\rPembahasan juga akan meliputi analisa statistik menggunakan GUI R (R Commander) untuk menganalisa data.","tags":null,"title":"Overview","type":"docs"},{"authors":["Mohammad Rosidi, S.T."],"categories":null,"content":"  body{ text-align: justify}  Pada postingan kali ini penulis akan memberikan kumpulan cheat sheet R yang penulis ambil dari berbagai sumber.\n1. Base R oleh Mhairi McNeil Merupakan cheat sheet yang berguna untuk memahami penggunaan fungsi dasar R seperti bagaimana cara membuat matrix, vektor, list, data frame, serta bagaimana bekerja dengannya.\n2. Advanced R oleh Arianne Colton dan Sean Chen Cheat sheet yang berguna jika pembaca telah menguasai dasar-dasar R dan ingin mengembangkan diri keranah yang lebih mahir. Cheat sheet ini berisi kumpulan fungsi bekerja dengan environment, data structures, functions, dan lain-lain pada R.\n3. Caret oleh Max Kuhn Cheat sheet library caret ini berisi bagaimana melakukan modeling dan membuat machine learning pada R menggunakan library ini. Library ini sangat berguna jika pembaca juga ingin melakukan validasi dan optimasi pada model yang telah pembaca buat karena library ini dapat dibilang menyediakan fungsi yang cukup lengkap.\n4. Cartography oleh Timothée Giraud Cheat sheet yang digunakan untuk bekerja dengan library cartography. Cheat sheet ini berguna untuk membuat visualisasi data spasial yang interaktif.\n5. data.table oleh Erik Petrovski Jika pembaca pernah melakukan manipulasi data menggunakan library keluarga tidyverse seperti dplyr, tidyr, tibble, dll. data.table adalah library alternatif untuk melakukan manipulasi data seperti reshaping, subseting, dll dengan kecepatan proses komputasi yang setara dengan library keluarga tidyverse.\n6. lubridate oleh RStudio lubridate merupakan library yang digunakan untuk melakukan pengolahan data dengan format data berupa waktu dan tanggal.Cheat sheet ini berisi bagaimana bekerja dengan jenis data waktu dan tanggal seperti pembulatan tanggal, bekerja dengan zona waktu, melakukan ekstraksi elemen waktu atau tanggal, dll.\n7. stringr oleh RStudio stringr meupakan paket yang berguna saat kita ingin berkerja dengan huruf atau string misalnya karakter pada data. Cheat sheet ini memberikan panduan bagi pembaca dalam manipulasi jenis data string pada R.\n8. purr oleh RStudio purr merupakan salah satu library yang termasuk dalam keluarga library tidyverse. Library ni berguna saat pembaca ingin bekerja dengan list dan function di R. Cheat sheet ini akan memberikan kita panduan bagaimana melakukan manipulasi pada list sebaik mengaplikasikan function secara iteratf pada tiap elemen list atau vektor menggunakan library purr yang merupakan library alternatif yang memberikan kecepatan dalam proses komputasi dibandingkan keluarga fungsi apply() pada R.\n9. data import oleh RStudio Cheat sheet ini memberikan panduan bagaimana membaca flat file (.csv, .tsv, .txt, dll) menggunakan library readr, bekerja dengan hasil import berupa tibble serta melakukan reshape data yang berantakan dengan tidyr. Gunakan library tidyr untuk mentransformasi data frame atau tibble menjadi lebih tidy yang dapat bekerja lebih lancar dengan R dan library tidyverse.\n10. Transformasi data oleh RStudio Cheat sheet yang memberikan panduan bagi pembaca bagaimana bekerja dengan grammar untuk manipulasi tabel pada dataset yang pembaca miliki menggunkan library dplyr. Manipulasi tabel yang dapat dilakukan seperti select(), filter(), arrange(), mutate(), summarise(), group(), dan menggabungkan data frame serta tibble menggunakan kaluarga fungsi join yang merupakan alternatif yang lebih advance dari fungsi seperti cbind() dan rbind().\n11. R Markdown oleh RStudio R Markdown adalah format penulisan yang dapat mempermudah penulisan laporan yang dapat digunakan kembali dengan R. Pembaca dapat menggabungkan kode R dengan narasi yang ditulis dalam markdown (format plain text yang mudah ditulis) dan kemudian mengekspor hasilnya menjadi format html, pdf, atau File Word. Pembaca bahkan dapat menggunakan R Markdown untuk membuat dokumen interaktif dan slideshow.\n12. RStudio IDE oleh RStudio RStudio IDE adalah lingkungan pengembangan terintegrasi paling populer untuk R. Apa pun yang pembaca ingin lakukan dengan R (seperti menulis, menjalankan, dan men-debug sintaks pada R, serta berkeja secara kolaboratif dan kontrol versi, membuat paket, dokumen serta aplikasi), RStudio IDE dapat membantu pembaca melakukannya lebih cepat. Cheat sheet ini akan memandu pembaca memahami fitur-fitur IDE yang paling berguna, serta daftar panjang pintasan keyboard yang ada di dalam RStudio IDE.\n13. Shiny oleh RStudio Cheat sheet ini memberikan panduan bagaimana membangun sebuah website aplikasi interaktif menggunakan library shiny. Jika pembaca ingin membuat sebuah laporan dari hasil analisa pembaca kedalam bentuk aplikasi yang interaktif, shiny sangat tepat untuk pembaca pertimbangkan sebagai sebuah library untuk membangun aplikasi tersebut.\n14. ggplot2 oleh RStudio Library ggplot2 membantu pembaca dalam membuat visualisasi data yang cantik dan mudah dikustomisasi. Library ini mengimplementasikan konsep grammar of graphics yang merupakan sistem yang mudah digunakan dalam membangun grafik.\n15. R Markdown Reference Guide oleh RStudio R Markdown merupakan suatu paket yang mengintegrasikan 3 buah perangkat lunak yaitu markdown, knitr, dan pandoc. Cheat sheet ini berisi panduan option yang digunakan pada markdown, knitr, dan pandoc yang digunakan untuk kustomisasi laporan atau slideshow yang akan pembaca buat.\n","date":1555779600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1556298000,"objectID":"f9a5d69a4b97780a19dfb1dc0ba9c96d","permalink":"/post/cheatsheet-r/","publishdate":"2019-04-21T00:00:00+07:00","relpermalink":"/post/cheatsheet-r/","section":"post","summary":"Kumpulan cheat sheet library R paling populer.","tags":["R","Cheat Sheet"],"title":"Kumpulan R Cheat","type":"post"},{"authors":["Mohammad Rosidi, S.T."],"categories":null,"content":" body{ text-align: justify}  R merupakan bahasa pemrograman yang banyak digunakan untuk melakukan analisa statistik. Penggunaannya yang mudah, jumlah paket yang banyak, serta dapat digunakan oleh seluruh kalangan secara gratis membuatnya menjadi salah satu bahasa pemrograman yang paling banyak digunakan. Untuk itu sayang sekali jika kita tidak menggunakannya karena R merupakan bahasa pemrograman yang sangat powerfull.\nAlasan tersebut membuat penulis sadar bahwa pbetapa pentingnya untuk menyajikan panduan lengkap penggunaan R untuk aplikasinya dalam bidang statistik bahkan lebih jauh dapat digunakan untuk analisa lain seperti membuat model matematik dan optimasi sistem meskipun R tidak didesain untuk melakukannya.\nPenulis telah membuat tutorial langkah-langkah penggunaan R yang dapat dibaca pada section Tutorial yang akan diupdate setiap minggu. Adapun tema yang akan dibahas mengenai R antara lain penerapannya dalam bidang:\n Statistik Visualisasi Data Model Matematik Model Sistem Dinamik Optimasi (mis: linear Programming)  ","date":1555779600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1555779600,"objectID":"cb3b4427c83c869b864e54c2dcbff34d","permalink":"/post/mengenal-r/","publishdate":"2019-04-21T00:00:00+07:00","relpermalink":"/post/mengenal-r/","section":"post","summary":"Komputasi statistik dan matematis menggunakan R sebagai solusi bahasa pemrograman sumber terbuka.","tags":["R","Tutorial"],"title":"Mengenal Lebih Jauh R Melalui Tutorial","type":"post"},{"authors":["Mohammad Rosidi, S.T."],"categories":null,"content":" body{ text-align: justify}  Tutorial telah memasuki Part 4. Banyak sekali materi yang dapat pembaca pelajari. Chapter Penaksiran Secara Statistika merupakan Chapter yang paling lama proses pembuatannya. Pada Chapter tersebut penulis membuat sejumlah sintaks fungsi yang belum tersedia di R. Kedepan fungsi-fungsi yang penulis kerjakan pada seluruh Chapter tutorial akan penulis jadikan satu repository git sehingga pembaca dapat dengan mudah menggunakannya sewaktu-waktu tanpa perlu menulis sintaks panjang.\nPada Chapter Penaksiran Secara Statistika, penulis telah menambahkan pembahasan mengenai simulasi dengan metode bootstrap. Metode ini akan banyak berguna saat kita akan melakukan penaksiran secara statistika dan tidak terbatas pada penaksiran nilai pemusatan dan sebaran data. Metode ini akan kita jumpai lagi saat kita memasukan Part Model Statistik.\nSetelah membaca Chapter Penaksiran Secara Statistika, penulis berharap pembaca dapat lebih memahami algortitma proses penentuan interval estimasi serta paham bagaimana membuat sintaks fungsi berdasarkan algortima yang tersedia sehingga kedepannya pembaca dapat dengan mudah dan leluasa dalam membuat fungsi karya pembaca sendiri.\n","date":1555606800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1555606800,"objectID":"24a069fac533d185814b8585874da36d","permalink":"/post/update-tutorial-part-1/","publishdate":"2019-04-19T00:00:00+07:00","relpermalink":"/post/update-tutorial-part-1/","section":"post","summary":"Penaksiran Secara Statistika Menggunakan Metode Parameterik dan Nonparametrik.","tags":["R","Tutorial"],"title":"Update Tutorial Part 1: Statistika Inferensial","type":"post"},{"authors":null,"categories":null,"content":"\r\rbody{\rtext-align: justify}\r\r\rDaftar Isi\n\rDefinisi Interval Estimasi\rInterpretasi Interval Estimasi\rInterval Kepercayaan Median\rInterval Kepercayaan Mean\rInterval Prediksi Nonparametrik\rTransformasi DataInterval Prediksi Parametrik\rInterval Kepercayaan Persentil (Interval Toleransi)\rInterval Kepercayaan Menggunakan Metode Bootstrap\rKegunaan Lain Dari Interval Kepercayaan\r\r\rPada Chapter 6-Ringkasan Numerik kita telah belajar beberapa atribut kunci dari data seperti \\(\\overline{X}\\) dan \\(s\\). Kedua nilai tersebut disebut sebagai nilai estimasi sampel dari populasi (untuk mean \\(\\mu\\) dan simpangan baku \\(\\sigma\\)). Pada Chapter ini kita akan melakukan eksplorasi lebih jauh lagi mengenai interval estimasi (interval estimate) yang akan menyinggung kedua nilai tersebut lebih jauh.\n10.1 Definisi Interval Estimasi\rMedian sampel dan mean sampel menyatakan titik pemusatan data. Estimasi menggunakan kedua nilai tersebut disebut sebagai estimasi titik (point estimation). Estimasi titik sendiri tidak menggambarkan reliabilitas atau kurangnya reliabilitas (variabilitas) dari estimasi ini. Sebagai contoh, anggaplah terdapat dua data X dan Y dengan mean 5 dengan jumlah observasi yang sama. Data Y memiliki nilai mean 5 dengan sangat sedikit variasi didalamnya, sedangkan data X jauh lebih bervariasi. Perkiraan titik 5 untuk X jauh lebih tidak dapat diandalkan dibandingkan dengan untuk Y karena variabilitas yang lebih besar dalam data X. Dengan kata lain, lebih banyak kehati-hatian diperlukan ketika menyatakan bahwa 5 memperkirakan mean populasi sebenarnya X daripada ketika menyatakan ini untuk Y. Melaporkan hanya perkiraan mean sampel (poin) 5 gagal memberikan petunjuk tentang perbedaan ini.\nSebagai alternatif untuk estimasi titik, estimasi interval adalah interval yang memiliki probabilitas yang dinyatakan mengandung nilai populasi sebenarnya. interval lebih lebar untuk set data yang memiliki variabilitas lebih besar. Jadi dalam contoh di atas, interval antara 4,7 dan 5,3 mungkin memiliki kemungkinan 95% untuk mengandung mean populasi Y yang sebenarnya (tidak diketahui). Butuh interval yang jauh lebih luas, katakanlah antara 2,0 dan 8,0, untuk memiliki probabilitas yang sama untuk mengandung rerata sebenarnya dari X. Karena itu, perbedaan keandalan dari dua estimasi dengan jelas dinyatakan menggunakan estimasi interval. Estimasi interval dapat memberikan dua informasi yang estimasi poin tidak dapat berikan, antara lain:\nPernyataan probabilitas atau kemungkinan bahwa interval berisi nilai populasi sebenarnya (keandalannya).\rPernyataan kemungkinan bahwa satu titik data dengan besaran tertentu berasal dari populasi yang diteliti.\r\rEstimasi interval untuk poin pertama disebut sebagai interval kepercayaan (confidence interval), sedangkan yang kedua disebut sebagai interval prediksi (prediction interal). Meskipun salin terkait, pembaca perlu berhati-hati sebab kedua definisi tersebut sering kali tertukar satu sama lain.\n\r10.2 Interpretasi Interval Estimasi\rUntuk lebih memahami mengenai definisi interval estimasi pada sub-chapter ini akan diberikan contoh yang diambil dari buku statistical Methods in Water Resources karya Helsel dan Hirsch (2012). Misalkan mean populasi sebenarnya \\(\\mu\\) konsentrasi dalam akuifer adalah 10. Sleain itu, anggaplah bahwa varians populasi sebenarnya \\(\\sigma^2\\) sama dengan 1. Karena nilai-nilai ini dalam praktiknya tidak pernah diketahui, sampel diambil untuk memperkirakannya dengan mean sampel \\(x\\) dan sampel varian \\(s^2\\) . Dana yang cukup tersedia untuk mengambil 12 sampel air (kira-kira satu per bulan) selama satu tahun, dan hari-hari di mana pengambilan sampel terjadi dipilih secara acak. Dari 12 sampel ini \\(x\\)x dan \\(s^2\\) dihitung. Meskipun pada kenyataannya hanya satu set 12 sampel akan diambil setiap tahun, menggunakan komputer 12 hari dapat dipilih beberapa kali untuk menggambarkan konsep perkiraan interval. Untuk masing-masing dari 10 set independen dari 12 sampel, interval kepercayaan pada mean dihitung dengan menggunakan persamaan yang diberikan pada Tabel 1 dan Gambar 1.\n\rTable 1:  Sepuluh interval kepercayaan 90% sekitar nilai mean sebenarnya sebesar 10 (Data berdistribusi normal dan Tanda plus menyatakan data tidak disertakan dalam nilai mean sebenarnya)\r\rNo.\rN\rMean\rSt.Dev\r90% Interval kepercayaan\r\r\r\r1\r12\r10,06\r1,11\r9,46 sampai 10,64\r\r2\r12\r10,60\r0,81\r\\(^+\\) 10,18 sampai 11,02\r\r3\r12\r9,95\r1,26\r9,29 sampai 10,60\r\r4\r12\r10,18\r1,26\r9,52 sampai 10,83\r\r5\r12\r10,17\r1,33\r9,48 sampai 10,85\r\r6\r12\r10,22\r1,19\r9,60 sampai 10,84\r\r7\r12\r9,71\r1,51\r8,92 sampai 10,49\r\r8\r12\r9,90\r1,01\r9,38 sampai 10,43\r\r9\r12\r9,95\r0.10\r9,43 sampai 10,46\r\r10\r12\r9,88\r1,37\r9,17 sampai 10,59\r\r\r\rKesepuluh interval pada contoh di atas disebut dengan dengan interval kepercayaan 90% dari nilai mean sesungguhnya. Nilai mean sebenarnya akan terdapat pada interval tersebut dengan probabilitas 90%. Sehingga berdasarkan Tabel 1 terdapat 9 interval yang memiliki nilai mean sesungguhnya didalamnya (probabilitas 90%). Jika kita sekali lagi melakukan sampling dengan jumlah sampling yang sama pada interval nilai baru yang dihasilkan akan mengandung nilai mean sesungguhnya dan dapat juga tidak. Probabilitas interval tersebut mengandung nilai mean sesungguhnya disebut sebagai tingkat kepercayaan (confidence level). Probabilitas nilai interval tidak mengandung mean sesungguhnya disebut sebagai alpha level (\\(\\alpha\\)) yang ditulis berdasarkan Persamaan (1).\n\\[\\begin{equation}\r\\alpha=1-confidence\\ level\\ \\tag{1}\r\\end{equation}\\]\rLebar interval kepercayaan adalah fungsi dari bentuk distribusi data (variabilitas dan kemencengannya), ukuran sampel, dan tingkat kepercayaan yang diinginkan. Ketika tingkat kepercayaan meningkat, lebar interval juga meningkat, karena interval yang lebih besar lebih mungkin mengandung nilai sebenarnya daripada interval yang lebih pendek. Dengan demikian interval kepercayaan 95% akan lebih luas daripada interval 90% untuk data yang sama.\n## Warning: package \u0026#39;knitr\u0026#39; was built under R version 3.5.3\r\rFigure 1: Sepuluh interval kepercayaan 90 persen data dengan nilai mean sebenarnya 10 (Helsel dan Hirsch, 2002)\r\rInterval kepercayaan simetris pada rata-rata biasanya dihitung dengan asumsi data mengikuti distribusi normal. Jika tidak, distribusi rerata itu sendiri akan mendekati normal sepanjang ukuran sampel besar (katakanlah 50 pengamatan atau lebih besar). Interval kepercayaan dengan asumsi normalitas kemudian akan memasukkan mean sebenarnya (\\(1-\\alpha\\))% dari waktu. Dalam contoh di atas, data dihasilkan dari distribusi normal, sehingga ukuran sampel kecil 12 tidak menjadi masalah. Namun ketika data memiliki kemencengan dan ukuran sampel di bawah 50 atau lebih, interval kepercayaan simetris tidak akan mengandung rata-rata (\\(1-\\alpha\\))% sepanjang waktu. Dalam contoh di bawah ini, interval kepercayaan simetris secara salah dihitung untuk data yang miring (Gambar 2). Hasil (Gambar 3 dan Tabel 2) menunjukkan bahwa interval kepercayaan kehilangan nilai sebenarnya dari 1 lebih sering daripada yang seharusnya. Semakin besar skewness, semakin besar ukuran sampel harus sebelum interval kepercayaan simetris dapat diandalkan. Sebagai alternatif, interval kepercayaan asimetris dapat dihitung untuk situasi umum data yang memiliki kemencengan.\n\rTable 2:  Sepuluh interval kepercayaan 90% sekitar nilai mean sebenarnya sebesar 1 (Data tidak berdistribusi normal dan Tanda plus menyatakan data tidak disertakan dalam nilai mean sebenarnya)\r\rNo.\rN\rMean\rSt.Dev\r90% Interval kepercayaan\r\r\r\r1\r12\r0,784\r0,320\r\\(^+\\) 0,618 sampai 0,950\r\r2\r12\r0,811\r0,299\r\\(^+\\) 0,656 sampai 0,966\r\r3\r12\r1,178\r0,700\r0,815 sampai 1,541\r\r4\r12\r1,030\r0,459\r0,792 sampai 1,267\r\r5\r12\r1,079\r0,573\r0,782 sampai 1,376\r\r6\r12\r0,833\r0,363\r0,644 sampai 1,021\r\r7\r12\r0,789\r0,240\r\\(^+\\) 0,644 sampai 0,913\r\r8\r12\r1,159\r0,815\r0,736 sampai 1,581\r\r9\r12\r0,822\r0,365\r\\(^+\\) 0,633 sampai 0,992\r\r10\r12\r0,837\r0,478\r0,589 sampai 1,085\r\r\r\r\rFigure 2: Histogram data dengan nilai mean populasi 1 dan simpangan baku populasi 0.75 (Helsel dan Hirsch, 2002)\r\r\rFigure 3: Sepuluh interval kepercayaan 90 persen data dengan nilai mean sebenarnya (Helsel dan Hirsch, 2002)\r\r\r10.3 Interval Kepercayaan Median\rInterval kepercayaan median populasi dapat dihitung tanpa perlu mengikuti asumsi distribusi tertentu. Sehingga nilai median dapat digunakan untuk memperkirakan nilai pusat data untuk distribusi data yang tidak berdistribusi normal.\n10.3.1 Interval Estimasi Median Metode Nonparametrik\rInterval estimasi nonparametrik untuk median populasi sebenarnya dihitung menggunakan distribusi binomial. Pertama, tingkat signifikansi yang diinginkan \\(\\alpha\\) dinyatakan, error yang dapat diterima tidak termasuk median yang sebenarnya. Satu-setengah (\\(\\alpha/2\\)) dari error ini digunakan untuk setiap akhir interval (Gambar 4). Tabel distribusi binomial memberikan nilai kritis bawah dan atas \\(x\u0026#39;\\) dan \\(x\\) pada setengah tingkat alfa yang diinginkan (\\(\\alpha/2\\)). Nilai-nilai kritis ini ditransformasikan ke dalam rangking \\(R_l\\) dan \\(R_u\\) yang sesuai dengan titik data \\(C_l\\) dan \\(C_u\\) di ujung interval kepercayaan.\n\rFigure 4: Probabilitas median populasi P50 pada dua sisi interval estimasi (Helsel dan Hirsch, 2002)\r\rUntuk ukuran sampel kecil, tabel binomial dimasukkan pada kolom p = 0,5 (median) untuk menghitung interval kepercayaan pada median. Nilai kritis \\(x\u0026#39;\\) diperoleh dari tabel distribusi binomial yang sesuai dengan \\(\\alpha/2\\), atau sedekat mungkin dengan \\(\\alpha/2\\). Nilai kritis ini kemudian digunakan untuk menghitung peringkat \\(R_u\\) dan \\(R_l\\) yang sesuai dengan nilai data pada batas kepercayaan atas dan bawah untuk median. Batas-batas ini adalah titik data peringkat \\(R_l\\)th yang masuk dari setiap ujung daftar n observasi. Interval kepercayaan yang dihasilkan akan mencerminkan bentuk (menceng atau simetris) dari data asli.\n\\[\\begin{equation}\rR_l=x\u0026#39;+1 \\tag{2}\r\\end{equation}\\]\r\\[\\begin{equation}\rR_u=n-x\u0026#39;=x\\ untuk\\ x\u0026#39;\\ dan\\ x\\ dari\\ tabel\\ dist.\\ binomial \\tag{3}\r\\end{equation}\\]\rInterval nonparametrik tidak selalu dapat secara tepat menghasilkan tingkat kepercayaan yang diinginkan ketika ukuran sampel kecil. Ini karena mereka terpisah, melompat dari satu nilai data ke yang berikutnya di ujung interval. Namun, tingkat kepercayaan yang dekat dengan yang diinginkan tersedia untuk semua kecuali ukuran sampel terkecil.\nUntuk lebih memahaminya diberikan data 25 pengukuran konsentrasi arsenin di air tanah dalam ppb yang disajikan pada Tabel 3.\n## Warning: package \u0026#39;tibble\u0026#39; was built under R version 3.5.3\r\rTable 3: Konsentrasi Arsenik dalam air tanah (ppb)\r\robservasi\rkonsentrasi\r\r\r\r1\r1.3\r\r2\r1.5\r\r3\r1.8\r\r4\r2.6\r\r5\r2.8\r\r6\r3.5\r\r7\r4.0\r\r8\r4.8\r\r9\r8.0\r\r10\r9.5\r\r11\r12.0\r\r12\r14.0\r\r13\r19.0\r\r14\r23.0\r\r15\r41.0\r\r16\r80.0\r\r17\r100.0\r\r18\r110.0\r\r19\r120.0\r\r20\r190.0\r\r21\r240.0\r\r22\r250.0\r\r23\r300.0\r\r24\r340.0\r\r25\r580.0\r\r\r\rVisualisasi Tabel 3 ditunjukkan pada Gambar 5. Berdasarkan gambar tersebut terlihat bahwa data memiliki kemencengan yang positif sehingga penaksiran rata-rata populasi menggunakan nilai mean tidak dapat dilakukan.\n## Warning: package \u0026#39;ggplot2\u0026#39; was built under R version 3.5.3\r## Warning: package \u0026#39;ggthemes\u0026#39; was built under R version 3.5.3\r\rFigure 5: Distribusi konsentrasi arsenik dalam air tanah\r\rBerdasarkan data pada Tabel 3, median konsentrasi arsenik \\(\\hat{C}_{0.5}\\)=19 yang berada pada urutan data ke-13 dari data yang telah diurutkan dari yang terkecil ke yang terbesar. Untuk menentukan interval kepercayaan 95% median kosentrasi arsenik \\(C_{0.5}\\), nilai kritis berdasarkan nilai error mendekati \\(\\alpha/2\\)=0,025 adalah \\(x\u0026#39;\\)=7. Untuk lebih memahaminya pembaca dapat mengunduh tabel distribusi binomial pada laman berikut. Nilai \\(x\u0026#39;\\)=7 diperoleh menggunakan Tabel distribusi binomial dengan \\(n\\)=25 dan \\(p\\)=0,5 yang ditampilkan pada Gambar 6 dengan nilai probabilitas sebesar 0,022 (mendekati 0,025) yang setara dengan area yang diarsir pada Gambar 4.\n\rFigure 6: Lokasi probabilitas x berdasarkan tabel distribusi binomial\r\rBerdasarkan Persamaan (2) dan Persamaan (3), rangking \\(R_l\\) pada observasi yang menyatakan batas kepercayaan bawah (lower confidence limit) adalah 8 (\\(R_i\\)=7+1) dan \\(R_u\\) yang menyatakan batas kepercayaan atas (upper confidence level) adalah 25-7=18. Berdasarkan nilai probabilitas \\(x\u0026#39;\\)=0,022, maka nilai alpha yang sesunggunya sebesar \\(\\alpha=2*0,022=0,044\\). Nilai tersebut setara dengan tingkat kepercayaan \\(1-0,044\\) atau 95,6%. Nilai interval kepercayaan median antara observasi ke-8 dan 18 adalah \\(C_l=4,8\\le C_{0.5}\\le110=C_u\\ \\ pada\\ \\alpha=0,044\\). Nilai asimetrik disekitar \\(\\hat{C}_{0.5}\\)=19 mencerminkan kemencengan pada data.\nJika pembaca ingin melakukan perhitungan pada R, pembaca harus membuat fungsi sebagai berikut:\nmed_npCI \u0026lt;- function(x,alpha){\r# mengurutkan data\rx_sort=sort(x)\r# menghitung jumlah observasi\rn=length(x)\r# menghitung median data\rmed = median(x, na.rm=TRUE)\r# loop untuk mencari nilai probabilitas terdekat\r# dengan alpha\rfor(i in 1:n){\rb = pbinom(i,n,0.5)\rif(b\u0026gt;alpha/2){\rbreak\r}\r}\r# mengambil x\u0026#39;\rx_i=i-1\r# menghitung Rl dan Ru\rrl=x_i+1\rru=n-x_i\r# menghitung true confidence level\rCL=1-2*(pbinom(x_i,n,0.5))\r# menghitung Lower dan Upper CL\rLCL=x_sort[rl]\rUCL=x_sort[ru]\r# menggabungkannya dalam satu data\rdata=data.frame(\u0026quot;median\u0026quot;=med,\r\u0026quot;True CL %\u0026quot;=CL*100,\r\u0026quot;Lower CL\u0026quot;=LCL,\r\u0026quot;Upper CL\u0026quot;=UCL)\rreturn(data)\r}\r\rNote: \n\rx: vektor numerik\ralpha: alpha level yang digunakan\r\r\rFungsi yang telah dibuat tersebut selanjutnya dapat pembaca gunakan saat akan menghitung interval kepercayaan median populasi menggunakan metode Nonparametrik. Berikut penerapannya menggunakan data pada Tabel 3 yang telah disimpan kedalam objek gwardat.\nmed_npCI(x=gwardat$konsentrasi, alpha=0.05)\r## median True.CL.. Lower.CL Upper.CL\r## 1 19 95.67147 4.8 110\rAlternatif lain yang dapat digunakan untuk menghitung interval kepercayaan jika sampel cukup besar n\u0026gt;20 menggunakan metode Nonparametrik adalah dengan menggunakan pendekatan tabel distribusi normal untuk memperkirakan distribusi binomial. Dengan menggunakan pendekatan ini, hanya sebagian kecil tabel distribusi binomial (n=20) yang diperlukan untuk melakukannya. Nilai kritis \\(z_{\\alpha/2}\\) dari tabel distribusi normal menentukan rangking atas dan bawah observasi yang menyatakan awal dan akhir nilai interval kepercayaan yang dinyatakan pada Persamaan (4) dan Persamaan (5). Pembulatan diperlukan dalam proses ini sebab nilai ranking harus berupa integer.\n\\[\\begin{equation}\rR_l=\\frac{n-z_{\\frac{\\alpha}{2}}\\cdot\\sqrt{n}}{2} \\tag{4}\r\\end{equation}\\]\r\\[\\begin{equation}\rR_l=\\frac{n-z_{\\frac{\\alpha}{2}}\\cdot\\sqrt{n}}{2}+1\r\\tag{5}\r\\end{equation}\\]\rMenggunakan contoh data pada Tabel 3, dengan 95% interval kepercayaan (\\(z_{\\alpha/2}\\)=1,96) median dapat dihitung seperti berikut:\n\\[\rR_l=\\frac{25-1,96\\cdot\\sqrt{25}}{2}=7,6 \\]\n\\[\rR_l=\\frac{25+1,96\\cdot\\sqrt{25}}{2}+1=18,4 \\]\nBerdasarkan hasil perhitungan diperoleh rangking bawah adalah data ke-8 dan rangking atas adalah 18. Kedua data dibulatkan berdasarkan integer terdekat. Nilai interval kepercayaan median yang diperoleh sama dengan metode sebelumnya sebab rangking batas bawah dan atasnya yang seragam.\nJika pembaca ingin menggunakan R, maka fungsi yang sebelumya telah kita buat dapat dimodifikasi seperti berikut:\nmed_norCI \u0026lt;- function(x, alpha){\r# mengurutkan data dari yang terkecil\rx_sort=sort(x)\r# menghitung jumlah observasi\rn = length(x)\r# menghitung median data\rmed = median(x, na.rm=TRUE)\r# menghitung Rl dan Ru\rrl=round((n-abs(qnorm(alpha/2))*sqrt(n))/2,0)\rru=round(((n+abs(qnorm(alpha/2))*sqrt(n))/2)+1,0)\r# menghitung Lower dan Upper CL\rLCL=x_sort[rl]\rUCL=x_sort[ru]\r# menggabungkannya dalam satu data\rdata=data.frame(\u0026quot;median\u0026quot;=med,\r\u0026quot;Lower CL\u0026quot;=LCL,\r\u0026quot;Upper CL\u0026quot;=UCL)\rreturn(data)\r}\rFungsi med_norCI() sama dengan fungsi med_npCI(). Perbedaannya terletak pada penggunaan distribusi normal pada proses penentuan titik kritisnya.\nDengan menggunakan fungsi med_norCI(), rentang kepercayaan median dapat dihitung seperti berikut:\n\rNote: \n\rx: vektor numerik\ralpha: alpha level yang digunakan\r\r\rmed_norCI(x=gwardat$konsentrasi, alpha=0.05)\r## median Lower.CL Upper.CL\r## 1 19 4.8 110\rJika kita tidak ingin menggunakan vektor dalam fungsi, kita dapat juga menggunakan data frame sebagai inputnya. Kelebihannya adalah kita dapat menghitung rentang kepercayaan seluruh kolom dalam satu kali proses. Hal ini tentunya akan menghemat waktu yang digunakan. Berikut adalah contoh sintaks fungsi untuk menghitung interval kepercayaan median menggunakan distribusi normal dengan metode nonparametrik yang digunakan:\nmed_norCI \u0026lt;- function(df, alpha){\r# membuat matrik untuk menyimpan\r# hasil loop\rmed = rep(NA, ncol(df))\rLCL = rep(NA, ncol(df))\rUCL = rep(NA, ncol(df))\rvar = rep(NA, ncol(df))\r# looping\rfor(i in 1:ncol(df)){\r# mengurutkan data\rx_sort = sort(df[, i])\r# mengambil nama kolom dataset\rvar[i] = colnames(df[i])\r# menghitung jumlah observasi\rn = length(x_sort)\r# menghitung median data\rmed[i] = median(x_sort, na.rm=TRUE)\r# menghitung Lower dan Upper CL\rLCL[i]=x_sort[(round((n-abs(qnorm(alpha/2))*sqrt(n))/2,0))]\rUCL[i]=x_sort[(round(((n+abs(qnorm(alpha/2))*sqrt(n))/2)+1,0))]\r}\r# menggabungkannya dalam satu data\rdata=data.frame(\u0026quot;variabel\u0026quot;=var,\r\u0026quot;median\u0026quot;=med,\r\u0026quot;Lower CL\u0026quot;=LCL,\r\u0026quot;Upper CL\u0026quot;=UCL)\rreturn(data)\r}\r\rNote: \n\rdf: data frame\ralpha: alpha level yang digunakan\r\r\rFungsi tersebut dapat menghitung sekaligus Interval kepercayaan median dengan metode nonparametrik. Pembaca dapat mencobanya dengan menggunakan dataset yang pembaca miliki. Pembaca dapat mengabaikan peringatan yang muncul dan berfokus pada hasil yang diperoleh. Sebagai contoh jalankan fungsi tersebut menggunakan dataset airquality berikut:\nmed_norCI(df=airquality, alpha=0.05)\r\r10.3.2 Metode Parametrik Interval Estimasi Median\rTelah dijelaskan pada chapter 6 bahwa rata-rata geometrik merupakan merupakan nilai rata-rata yang digunakan untuk mengestimasi median sampel untuk data yang memiliki kemencengan dengan transformasi yang digunakan agar data simetris adalah transformasi logaritmik \\(y=\\ln(x)\\). Pada metode ini data diasumsikan memiliki distribusi lognormal (kemencengan positif). Rerata dan interval geometris akan lebih efisien (interval lebih pendek) dari median dan interval kepercayaannya ketika data benar-benar lognormal. Median sampel dan intervalnya lebih tepat dan lebih efisien jika logaritma data masih menunjukkan kemencengan dan/atau outlier. Estimasi media menggunakan metode parametrik dituliskan kedalam Persamaan (6) dan Persamaan (7).\n\\[\\begin{equation}\rGM_x=\\exp\\left(\\overline{y}\\right) \\tag{6}\r\\end{equation}\\]\rdimana \\(y=\\ln(x)\\) dan \\(\\overline{y}\\)=mean sampel \\(y\\).\n\\[\\begin{equation}\r\\exp\\left(\\overline{y}-t_{\\left(\\frac{\\alpha}{2},n-1\\right)}\\sqrt{\\frac{s_y^2}{n}}\\right)\\le GM_x\\le\\exp\\left(\\overline{y}+t_{\\left(\\frac{\\alpha}{2},n-1\\right)}\\sqrt{\\frac{s_y^2}{n}}\\right) \\tag{7}\r\\end{equation}\\]\rdimana \\(s_{y}^2\\)= varians sampel y pada unit log natural.\nPada Tabel 3, untuk menghitung interval keyakinan median menggunakan pendekatan mean geometrik \\(GM_x\\) kita perlu mentransformasi datanya terlebih dahulu sehingga menjadi bentuk natural log. hasil transformasi disajikan pada Tabel 4.\n\rTable 4: Tranformasi logaritmik konsentrasi Arsenik dalam air tanah (ppb)\r\robservasi\rkonsentrasi\r\r\r\r1\r0.2623643\r\r2\r0.4054651\r\r3\r0.5877867\r\r4\r0.9555114\r\r5\r1.0296194\r\r6\r1.2527630\r\r7\r1.3862944\r\r8\r1.5686159\r\r9\r2.0794415\r\r10\r2.2512918\r\r11\r2.4849066\r\r12\r2.6390573\r\r13\r2.9444390\r\r14\r3.1354942\r\r15\r3.7135721\r\r16\r4.3820266\r\r17\r4.6051702\r\r18\r4.7004804\r\r19\r4.7874917\r\r20\r5.2470241\r\r21\r5.4806389\r\r22\r5.5214609\r\r23\r5.7037825\r\r24\r5.8289456\r\r25\r6.3630281\r\r\r\rvisualisasi distribusi yang baru disajikan pada Gambar 7.\n\rFigure 7: Distribusi logaritmik konsentrasi arsenik dalam air tanah\r\rNilai mean dari data tersebut adalah 3,17 dengan simpangan baku sebesar 1,96. Berdasarkan Gambar 7, kita telah memperoleh distribusi yang simetris.\nDengan menggunakan Persamaan (6) dan Persamaan (7) selanjutnya dapat dihitung interval kepercayaannya dengan derajat kepercayaan 95%.\n\\[\rGM_x=\\exp\\left(3,17\\right)=23,8\r\\]\n\\[\r\\exp\\left(3.17-2,064\\cdot\\sqrt{\\frac{1.96^2}{25}}\\right)\\le GM_x\\le\\exp\\left(3.17-2,064\\cdot\\sqrt{\\frac{1.96^2}{25}}\\right)\r\\]\n\\[\r\\exp\\left(2,36\\right)\\le GM_x\\le\\exp\\left(3,98\\right)\r\\]\n\\[\r10,6\\le GM_x\\le53,5\r\\]\nDengan menggunakan R dapat dikerjakan menggunakan fungsi sebagai berikut:\nmed_gm \u0026lt;- function(x, alpha){\rx = log(x)\r# rata-rata geometrik\rgm = exp(mean(x, na.rm=TRUE))\r# menghitung derajat kebebasan\rdf = length(x)-1\r# menghitung batas bawah dan atas\rLCL = exp(mean(x, na.rm=TRUE)-qt(1-alpha/2,df)*sqrt(var(x, na.rm=TRUE)/length(x)))\rUCL = exp(mean(x, na.rm=TRUE)+qt(1-alpha/2,df)*sqrt(var(x, na.rm=TRUE)/length(x)))\r# menggabungkan hasil\rdata=data.frame(\u0026quot;GM\u0026quot;=gm,\r\u0026quot;Lower CL\u0026quot;=LCL,\r\u0026quot;Upper CL\u0026quot;=UCL)\rreturn(data)\r}\r\rNote: \n\rx: vektor numerik\ralpha: alpha level yang digunakan\r\r\rmed_gm(x=gwardat$konsentrasi, alpha=0.05)\r## GM Lower.CL Upper.CL\r## 1 23.87106 10.63118 53.59966\rFungsi med_gm() dapat dilakukan sejumlah modifikasi seperti penggunaan data frame sebagai input serta proses transformasi yang dilakukan didalam fungsi yang ada sekaligus. Berikut adalah contoh fungsi yang digunakan untuk input berupa data frame dan proses transformasi termasuk didalamnya:\nmed_gm \u0026lt;- function(df, alpha){\r# membuat vektor untuk menyimpan hasil loop\rvar = rep(NA, ncol(df))\rgm = rep(NA, ncol(df))\rLCL = rep(NA, ncol(df))\rUCL = rep(NA, ncol(df))\r# looping\rfor(i in 1:ncol(df)){\r# mengambil nama kolom\rvar[i] = colnames(df[i])\r# transformasi variabel (logaritmik)\rx = log(df[,i])\r# rata-rata geometrik\rgm[i] = exp(mean(x, na.rm=TRUE))\r# menghitung derajat kebebasan\rd = length(x)-1\r# menghitung batas bawah dan atas\rLCL[i] = exp(mean(x, na.rm=TRUE)-qt(1-alpha/2,d)*sqrt(var(x, na.rm=TRUE)/length(x)))\rUCL[i] = exp(mean(x, na.rm=TRUE)+qt(1-alpha/2,d)*sqrt(var(x,na.rm=TRUE)/length(x)))\r}\r# menggabungkan hasil\rdata=data.frame(\u0026quot;Variabel\u0026quot;=var,\r\u0026quot;GM\u0026quot;=gm,\r\u0026quot;Lower CL\u0026quot;=LCL,\r\u0026quot;Upper CL\u0026quot;=UCL)\rreturn(data)\r}\r\rNote: \n\rdf: data frame\ralpha: alpha level yang digunakan\r\r\rUntuk menguji fungsi tersebut jalankan fungsi tersebut menggunakan dataset yang pembaca miliki. Dalam contoh ini ak diberikan contoh penerapannya menggunakan dataset airquality. Jalankan fungsi berikut untuk memperoleh hasilnya.\nmed_gm(airquality, 0.05)\rPembaca perlu berhati-hati dalam menentukan apakah akan menggunakan metode Nonparametrik atau parametrik. Jika data berditribusi lognormal kita dapat menggunakan metode parametrik.\n\r\r10.4 Interval Kepercayaan Mean\rEstimasi interval juga dapat dihitung untuk mean populasi sebenarnya \\(\\mu\\). Hal ini sangat sesuai jika pusat data menjadi fokus dalam analisa statistik. Interval simetris di sekitar sampel rata-rata X paling sering dihitung. Untuk ukuran sampel besar, interval simetris secara memadai menggambarkan variasi rata-rata, terlepas dari bentuk distribusi data. Ini karena distribusi rata-rata sampel akan mendekati dengan distribusi normal ketika ukuran sampel semakin besar, meskipun data mungkin tidak terdistribusi secara normal. Untuk ukuran sampel yang lebih kecil, rata-rata tidak akan didistribusikan secara normal kecuali jika data itu sendiri terdistribusi secara normal. Ketika data meningkat kemencengannya, lebih banyak data diperlukan sebelum distribusi rata-rata dapat didekati secara memadai oleh distribusi normal. Untuk distribusi yang sangat miring atau data yang mengandung outlier, mungkin diperlukan lebih dari 100 pengamatan sebelum nilai rata-rata tidak akan terpengaruh oleh nilai terbesar untuk mengasumsikan bahwa distribusinya akan simetris.\n10.4.1 Interval Kepercayaan Mean Untuk Distribusi Yang Simetris\rInterval kepercayaan mean untuk distribusi simetris dihitung menggunakan tabel distribusi student’s t yang tersedia dalam buku teks statistik dan perangkat lunak. Tabel ini dimasukkan untuk menemukan nilai kritis untuk t pada setengah tingkat alfa yang diinginkan. Pada buku lain sering dijelaskan bahwa distribusi t hanya digunakan untuk sampel kecil (beberapa menyebutkan n\u0026lt;30), sedangkan untuk distribusi besar digunakan distribusi normal. Penggunaan distribusi normal jarang digunakan dalam prakiraan. Hal ini disebabkan karena pada proses perhitungan diperlukan nilai simpangan baku \\(\\sigma\\). Pada kenyataannya pada pengukuran dilapangan kita sering sekalin melakukan estimasi terhadap simpangan baku melalui sampel \\(s\\) karena kita tidak mengetahui nilai simpangan baku populasinya sehingga pada buku ini akan digali lebih jauh metode estimasi interval menggunakan persamaan distribusi t.\nLebar interval kepercayaan adalah fungsi dari nilai-nilai kritis dari tabel distribusi t, simpangan baku data, dan ukuran sampel. Ketika data memiliki kemecengan atau mengandung outlier, asumsi di balik interval t dan distribusi normal tidak berlaku. Interval simetris yang dihasilkan akan sangat luas sehingga sebagian besar pengamatan akan dimasukkan di dalamnya. Ini juga dapat mencapai di bawah nol di ujung bawah. Titik akhir negatif dari interval kepercayaan untuk data yang tidak dapat menjadi negatif adalah sinyal yang jelas bahwa asumsi interval kepercayaan simetris tidak diperlukan. Untuk data tersebut, dengan asumsi distribusi lognormal seperti yang dijelaskan dalam sub chapter sebelumnya (interval kepercayaan median) akan lebih tepat. Interval kepercayaan dihitung menggunakan Persamaan (8).\n\\[\\begin{equation}\r\\overline{x}-t_{\\left(\\frac{\\alpha}{2},n-1\\right)}\\cdot\\sqrt{\\frac{s^2}{n}}\\le\\mu\\le\\overline{x}+t_{\\left(\\frac{\\alpha}{2},n-1\\right)}\\cdot\\sqrt{\\frac{s^2}{n}}\r\\tag{8}\r\\end{equation}\\]\rUntuk lebih memahami cara penerapannya, kita akan menggunakan kembali data pada Tabel 4. Langkah pertama yang perlu dilakukan adalah menghitung mean sampel \\(\\overline{x}\\) dan simpangan baku sampel \\(s\\). Berdasarkan hasil perhitungan diperoleh nilai \\(\\overline{x}\\) =98.352 dan \\(s\\) = 144.685. Dengan meggunakan Persamaan (8), interval estimasi mean dengan tingkat kepercayaan 95% dapat dihitung sebagai berikut:\n\\[\r3,17\\ -\\ t_{\\left(0.25,24\\right)}\\cdot\\sqrt{\\frac{1,96^2}{25}}\\le\\mu\\le3,17\\ -\\ t_{\\left(0.25,24\\right)}\\cdot\\sqrt{\\frac{1,96^2}{25}}\r\\]\n\\[\r2,36\\le\\mu\\le3,98\r\\]\nBerdasarkan hasil yang diperoleh terdapat 95% peluang nilai mean populasi \\(\\mu\\) terletak pada interval 2,36 sampai 3,98. Perlu diingat bahwa metode parametrik sangat sensitif dengan adanya outlier sehingga jika pembaca ingin menggunakannya pastikan terlebih dahulu tidak ada outlier pada data dengan cara melakukan visualisasi data.\nPada R kita dapat menggunakan fungsi stat.desc() untuk menhitung statistika deskriptif serta interval kepercayaan mean-nya. Berikut adalah sintaks yang digunakan:\n# memuat paket\rlibrary(pastecs)\r## Warning: package \u0026#39;pastecs\u0026#39; was built under R version 3.5.3\r# ringkasan data\rr=stat.desc(gwardat2$konsentrasi)\rr\r## nbr.val nbr.null nbr.na min max ## 25.0000000 0.0000000 0.0000000 0.2623643 6.3630281 ## range sum median mean SE.mean ## 6.1006638 79.3166718 2.9444390 3.1726669 0.3919164 ## CI.mean.0.95 var std.dev coef.var ## 0.8088758 3.8399625 1.9595822 0.6176451\r# batas bawah (LCL)\rmean(gwardat2$konsentrasi)-r[[11]]\r## [1] 2.363791\r# batas atas (UCL)\rmean(gwardat2$konsentrasi)+r[[11]]\r## [1] 3.981543\rSelain itu , kita juga dapat menghitung interval kepercayaan mean menggunakan fungsi t.test(). Fungsi ini pada dasarnya dilakukan untuk melakukan uji hipotesis terhadap satu rata-rata. Untuk lebih tahu mengenai fungsi tersebut jalankan sintaks bantuan berikut:\n?t.test\rUntuk menghitung interval kepercayaan mean jalankan sintaks berikut:\nt.test(gwardat$konsentrasi, conf.level= 0.95) \r## ## One Sample t-test\r## ## data: gwardat$konsentrasi\r## t = 3.3988, df = 24, p-value = 0.002364\r## alternative hypothesis: true mean is not equal to 0\r## 95 percent confidence interval:\r## 38.62894 158.07506\r## sample estimates:\r## mean of x ## 98.352\r\r10.4.2 Interval Kepercayaan Mean Untuk Distribusi Yang Asimetris\rMean dan interval kepercayaan dapat dihitung dengan mengasumsikan distribusi data mengikuti distribusi logaritmik \\(y=\\ln{(x)}\\). Metode ini berguna untuk jenis data yang memiliki bentuk distribusi data yang memiliki kemencengan positif (perlu transformasi logaritmik agar simetris).Metode ini memberikan perkiraan rata-rata yang lebih dapat diandalkan (varians lebih rendah) daripada perhitungan rata-rata sampel biasa tanpa transformasi log.\nUntuk memperkirakan rata-rata populasi \\(\\mu_x\\) dalam unit aslinya, anggap datanya berdistribusi normal. Satu-setengah varians logaritma ditambahkan ke \\(\\overline{y}\\) (rata-rata log) sebelum eksponensial. Karena varians sampel \\(s^2_y\\) hanya perkiraan varians sebenarnya dari logaritma, estimasi sampel rata-rata akan menjadi bias. Namun, untuk sampel dengan \\(s^2_y\\) kecil dan ukuran sampel besar bias dapat diabaikan. Interval kepercayaan dapat dituliskan berdasarkan Persamaan (9).\n\\[\\begin{equation}\r\\mu_x=\\exp\\left(\\overline{y}+0,5\\cdot s_y^2\\right)\r\\tag{9}\r\\end{equation}\\]\rdimana \\(y=\\ln{(x)}\\), \\(\\overline{y}\\)= mean sampel dan \\(s^2_y\\)= varians sampel y dalam unit log natural.\nInterval kepercayaan sekitar \\(\\mu_x\\) bukan estimasi interval yang dihitung untuk rata-rata geometri dalam Persamaan (7). Interval kepercayaan tidak dapat dihitung hanya dengan mengekspansi interval sekitar \\(\\overline{y}\\). Interval kepercayaan yang tepat dalam satuan asli untuk rata-rata data lognormal dapat dihitung. Untuk lebih jelasnya pembaca dapat melihatnya pada situs http://jse.amstat.org/v13n1/olsson.html.\nMetode Cox dapat digunakan untuk menghitung interval keyakinan dengan nilai estimasi rata-rata menggunakan Persamaan (9). Persamaan yang digunakan dapat dituliskan sebagai berikut (Persamaan (10)).\n\\[\\begin{equation}\r\\ln\\left(\\mu_x\\right)=\\overline{Y}+\\frac{s_y^2}{2}\\pm z_{\\left(\\frac{\\alpha}{2}\\right)}\\sqrt{\\frac{s_y^2}{n}+\\frac{s_y^4}{2\\left(n-1\\right)}}\r\\tag{10}\r\\end{equation}\\]\rPersamaan (10) dapat dimodifikasi dengan menggunakan distribusi t dibanding menggunakan distribusi normal. Penggunaan distribusi t akan memperbaiki kelemahan penggunaan distribusi normal pada sampel yang berukuran kecil.\nData Tabel 3 dapat kita gunakan untuk menghitung rata-rata menggunakan Persamaan (10). Hal ini disebabkan karena data yang ada memiliki kemencengan positif sehingga dapat dianggap bahwa transformasi logaritmik dapat membentuk distribusi ini menjadi lebih simetris.\nBerdasarkan hasil perhitungan diperoleh nilai \\(\\overline{Y}\\) =3.173 dan \\(s^2_y\\) = 1.96. Sehingga nilai interval selanjutnya dapat dihitung menggunakan Persamaan (10) dengan interval keyakinan 95%.\n\\[\r\\ln\\left(\\mu_x\\right)=3,17+\\frac{1,96^2}{2}\\pm1,96\\sqrt{\\frac{1,96^2}{25}+\\frac{1,96^4}{2\\left(25-1\\right)}}\r\\]\n\\[\r\\ln\\left(\\mu_x\\right)=5,10\\pm1,33\r\\]\nSehingga\n\\[\r\\exp\\left(5,10-1,33\\right)\\le\\mu_x\\le\\exp\\left(5,10+1,33\\right)\r\\]\n\\[\r43,38\\le\\mu_x\\le620,17\r\\]\nNilai interval yang dihasilkan sangat panjang sehingga nilai rata-rata yang dihasilkan tidak dapat diandalkan untuk memperkirankan lokasi nilai mean populasi.\nPada contoh berikut akan disajikan sintaks untuk menghitung interval kepercayaan mean data pada Tabel 3 berdasarkan Persamaan (10) dan sitribusi yang digunakan adalah distribusi t. Pembaca dapat memodifikasi sintaks berikut jika ingin menggunakan distribusi normal.\nmean_asci\u0026lt;-function(x,alpha){\rm=mean(x, na.rm=TRUE)\r# mean data hasil transformasi logaritmik\rave = mean(log(x), na.rm=TRUE)\r# simpangan baku data hasil transformasi\rsd = sd(log(x), na.rm=TRUE)\r# jumlah observasi\rn = length(x)\r# derajat kebebasa\rdf = n-1\r# interval keyakinan satu sisi\rre = 1-(alpha/2)\r# CI menggunakan distribusi t\rLCL = exp(ave+(0.5*sd^2)-qt(re,df)*sqrt(((sd^2)/n)+((sd^4)/(2*df))))\rUCL = exp(ave+(0.5*sd^2)+qt(re,df)*sqrt(((sd^2)/n)+((sd^4)/(2*df))))\r# menggabungkan hasil\rdata = data.frame(\u0026quot;Mean\u0026quot;=m,\r\u0026quot;Lower CL\u0026quot;=LCL,\r\u0026quot;Upper CL\u0026quot;=UCL)\rreturn(data)\r}\r\rNote: \n\rx: vektor numerik\ralpha: alpha level yang digunakan\r\r\rmean_asci(x=gwardat$konsentrasi, alpha=0.05)\r## Mean Lower.CL Upper.CL\r## 1 98.352 40.11052 660.9363\rJika pembaca ingin menggunakan data frame sebagai input yang digunakan selain vektor, fungsi tersebut dapat dimodifikasi seperti berikut:\nmean_asci\u0026lt;-function(df,alpha){\r# membuat vektor untuk menyimpan hasil loop\rvar = rep(NA, ncol(df))\rm = rep(NA, ncol(df))\rLCL = rep(NA, ncol(df))\rUCL = rep(NA, ncol(df))\r# looping\rfor(i in 1:ncol(df)){\r# mengambil nama kolom\rvar[i] = colnames(df[i])\r# menghitung mean data\rm[i]=mean(df[,i], na.rm=TRUE)\r# mean data hasil transformasi logaritmik\rave = mean(log(df[,i]), na.rm=TRUE)\r# simpangan baku data hasil transformasi\rsd = sd(log(df[,i]), na.rm=TRUE)\r# jumlah observasi\rn = length(df[,i])\r# derajat kebebasa\rd = n-1\r# interval keyakinan satu sisi\rre = 1-(alpha/2)\r# CI menggunakan distribusi t\rLCL[i] = exp(ave+(0.5*sd^2)-qt(re,d)*sqrt(((sd^2)/n)+((sd^4)/(2*d))))\rUCL[i] = exp(ave+(0.5*sd^2)+qt(re,d)*sqrt(((sd^2)/n)+((sd^4)/(2*d))))\r}\r# menggabungkan hasil\rdata = data.frame(\u0026quot;Variabel\u0026quot;=var,\r\u0026quot;Mean\u0026quot;=m,\r\u0026quot;Lower CL\u0026quot;=LCL,\r\u0026quot;Upper CL\u0026quot;=UCL)\rreturn(data)\r}\r\rNote: \n\rdf: data frame\ralpha: alpha level yang digunakan\r\r\rUntuk menguji fungsi tersebut, pembaca dapat memasukkan data frame yang pembaca miliki kedalam persamaan tersebut. Berikut adalah contoh sintaks yang digunakan untuk menghitung interval kepercayaan mean pada dataset airquality. Pembaca dapat menjalankannya pada komputer pembaca.\nmean_asci(airquality, 0.05)\r\r\r10.5 Interval Prediksi Nonparametrik\rPertanyaan yang sering diajukan adalah apakah satu pengamatan baru kemungkinan berasal dari distribusi yang sama dengan data yang dikumpulkan sebelumnya, atau sebagai alternatif dari distribusi yang berbeda. Pertanyaan dapat dievaluasi dengan menentukan apakah pengamatan baru di luar interval prediksi yang dihitung dari data yang ada. Interval prediksi mengandung \\(100\\cdot\\left(1-\\alpha\\right)\\) persen dari distribusi data, sementara \\(100\\cdot\\alpha\\) persen berada di luar interval. Jika pengamatan baru datang dari distribusi yang sama dengan data yang diukur sebelumnya, ada kemungkinan \\(100\\cdot\\alpha\\) persen bahwa pengamatan baru tersebut akan berada di luar interval prediksi. Karena pengamatan baru tersebut berada di luar interval tidak “membuktikan” pengamatan baru itu berbeda, hanya saja sepertinya begitu. Seberapa besar kemungkinan ini tergantung pada pilihan \\(\\alpha\\) yang ditentukan oleh peneliti.\nInterval prediksi dihitung dengan tujuan yang berbeda dari interval kepercayaan. Interval prediksi terkait dengan nilai data individu yang berlawanan dengan ringkasan statistik seperti nilai mean. Interval prediksi lebih luas daripada interval kepercayaan, karena pengamatan individu lebih bervariasi daripada ringkasan statistik yang dihitung dari beberapa pengamatan. Tidak seperti interval kepercayaan, interval prediksi memperhitungkan variabilitas titik data tunggal di sekitar median atau rata-rata, di samping kesalahan dalam memperkirakan pusat distribusi. Ketika mean \\(\\pm\\) 2 simpangan baku secara keliru digunakan untuk memperkirakan lebar interval prediksi, data baru dinyatakan berasal dari populasi yang berbeda lebih sering daripada yang seharusnya.\n10.5.1 Interval Prediksi Nonparametrik Dua Sisi\rInterval prediksi tingkat kepercayaan nonparametrik \\(\\alpha\\) secara sederhana dinyatakan sebagai interval antara persentil distribusi \\(\\alpha/2\\) dan \\(1-\\left(\\frac{\\alpha}{2}\\right)\\) (Gambar 8). Interval ini mengandung \\(100\\cdot\\left(1-\\alpha\\right)\\) data, sedangkan \\(100\\cdot\\alpha\\) persen berada di luar interval. Oleh karena itu jika titik data tambahan baru berasal dari distribusi yang sama dengan data yang diukur sebelumnya, ada kemungkinan \\(100\\cdot\\alpha\\) persen bahwa itu akan berada di luar interval prediksi. Interval akan mencerminkan bentuk data yang dikembangkannya, dan tidak ada asumsi tentang bentuk bentuk yang perlu dibuat. Interval prediksi nonparametrik dua sisi dinyatakan berdasarkan Persamaan (11).\n\\[\\begin{equation}\rPI_{np}=X_{\\frac{\\alpha}{2}\\cdot\\left(n+1\\right)}\\ sampai\\ dengan\\ X_{\\left[1-\\left(\\frac{\\alpha}{2}\\right)\\right]\\cdot\\left(n+1\\right)}\r\\tag{11}\r\\end{equation}\\]\r\rFigure 8: Prediksi interval dua sisi (Helsel dan Hirsch, 2002)\r\rKita akan kembali menggunakan data pada Tabel 3. Dengan menggunakan tingkat kepercayaan 90% kita diminta untuk menentukan interval prediksi dari konsentrasi arsenik pada data tersebut tanpa mengasumsikan distribusi dari data.\nUntuk melakukannya kita perlu menentukan observasi ke-2,5 dan 97,5 (berdasarkan nilai \\(\\alpha/2\\)) dengan rangking observasi berdasarkan Persamaan (11) adalah \\((0,05*26)\\) atau rangking observasi antara observasi 1 (\\(R_1\\)) dan 2 (\\(R_2\\)) dan \\((0,95*26)\\) rangking observasi antara observasi 24 (\\(R_{24}\\)) dan 25 (\\(R_{25}\\)). Dengan menggunakan interpolasi linier pada observasi ke-1, 2 , 24 dan 25, interval prediksi yang diperoleh adalah sebagai berikut:\n\\[\rX_1+\\left(\\frac{R_{\\left(0.05\\cdot26\\right)}-R_1}{R_2-R_1}\\right)\\cdot\\left(X_2-X_1\\right)\\ sampai\\ dengan\\ X_{24}+\\left(\\frac{R_{\\left(0.95\\cdot26\\right)}-R_{24}}{R_{25}-R_{24}}\\right)\\cdot\\left(X_{25}-X_4\\right)\r\\]\n\\[\r1,3+\\left(\\frac{1,3-1}{2-1}\\right)\\cdot\\left(1,5-1,3\\right)\\ sampai\\ dengan\\ 340+\\left(\\frac{24,5-24}{25-24}\\right)\\cdot\\left(580-340\\right)\r\\]\n\\[\r1,4\\ sampai\\ dengan\\ 508\\ ppb\r\\]\nObservasi baru diluar rentang tersebut akan dianggap berasal dari distribusi yang berbeda dengan tingkat error sebesar 10% (\\(\\alpha\\)=10%).\nDengan menggunakan R pembaca depat menghitung interval prediksi menggunakan fungsi berikut:\nPInp \u0026lt;- function(x, alpha){\r# mengurutkan data\rx_sort = sort(x)\r# jumlah observasi\rn = length(x)\r# menghitung alpha masing-masing sisi\rerr \u0026lt;- alpha/2\r# menentukan rangkin observasi sesuai alpha\rrl = err*(n+1)\rru = (1-err)*(n+1)\r# menentukan observasi untuk interpolasi linier\rrl_1= ceiling(rl) # bulatkan ke bawah\rrl_2= floor(rl) # bulatkan ke atas\rru_1= ceiling(ru) ru_2= floor(ru)\r# menentukan interval prediksi\rLPI = round(x_sort[rl_1]+((rl-rl_1)/(rl_2-rl_1))*(x_sort[rl_2]-x_sort[rl_1]),1)\rUPI = round(x_sort[ru_1]+((ru-ru_1)/(ru_2-ru_1))*(x_sort[ru_2]-x[ru_1]),1)\r# menggabungkan hasil\rdata = data.frame(\u0026quot;Lower PI\u0026quot;=LPI,\r\u0026quot;Upper PI\u0026quot;=UPI)\rreturn(data)\r}\r\rNote: \n\rx: vektor numerik\ralpha: alpha level yang digunakan\r\r\rPInp(x=gwardat$konsentrasi, alpha=0.1)\r## Lower.PI Upper.PI\r## 1 1.4 508\r\r10.5.2 Interval Prediksi Nonparametrik Satu Sisi\rInterval prediksi satu sisi digunakan jika kita ingin mengecek apakah pengamatan baru lebih besar dari data yang ada, atau lebih kecil dari data yang ada, tetapi tidak keduanya. Keputusan untuk menggunakan interval satu sisi harus didasarkan sepenuhnya pada pertanyaan yang menarik. Seharusnya tidak ditentukan setelah melihat data dan memutuskan bahwa pengamatan baru cenderung hanya lebih besar, atau hanya lebih kecil, daripada informasi yang ada. Interval satu sisi menggunakan \\(\\alpha\\) dibanding \\(\\alpha/2\\) sebagai nilai error, menempatkan semua error di satu sisi interval (Gambar 9). Interval prediksi dituliskan berdasarkan Persamaan (12).\n\rFigure 9: Prediksi interval satu sisi (Helsel dan Hirsch, 2002)\r\r\\[\\begin{equation}\rPI_{np}:\\ x_{baru}\u0026lt;X_{\\alpha\\cdot\\left(n+1\\right)}\\ atau\\ x_{baru}\u0026gt;X_{\\left[1-\\alpha\\right]\\cdot\\left(n+1\\right)}\r\\tag{12}\r\\end{equation}\\]\rUntuk memahami penerapannya, misalkan kita memiliki nilai arsenik baru dengan konsentrasi 355 ppb. Kita perlu menentukan apakah nilai tersebut lebih besar dari sebagian besar data yang ada.\nDengan menggunakan Persamaan (12) dan \\(\\alpha\\)=0,1 atau tingkat kepercayaan 90%, interval prediksi satu sisi atau data teratas dari persentil ke-90 dari data yang ada adalah \\(X_{0,9}*26=X_{23,4}\\). Dengan menggunakan interpolasi linier pada observasi data dengan rangking ke-23 (\\(R_{23}\\)) dan 24 (\\(R_{23}\\)) diperoleh:\n\\[\rX_{23}+0,4\\cdot\\left(X_{24}-X_{23}\\right)=300+0,4\\cdot40=316\\ ppb\r\\]\nBerdasarkan data yang diperoleh diketahui bahwa batas atas dari interval prediksi adalah 316\u0026lt;355 pbb, sehingga disimpulkan bahwa konsentrasi 355 pbb lebih besar dari sebagian besar data yang ada.\nDengan menggunakan R interval prediksi menggunakan satu sisi dapat dihitung menggunakan fungsi berikut:\nPInp_os \u0026lt;- function(x, obs, alpha, side){\r# mengurutkan data dari yang terkecil\rx_sort = sort(x)\r# jumlah observasi\rn = length(x)\r# rangking observasi\rru = (1-alpha)*(n+1)\rru_1 = ceiling(ru)\rru_2 = floor(ru)\rrl = alpha*(n+1)\rrl_1 = ceiling(rl)\rrl_2 = floor(rl)\r# perhitungan interval atas dan bawah\rPIup = x_sort[ru_1]+((ru-ru_1)/(ru_2-ru_1))*(x_sort[ru_2]-x_sort[ru_1])\rPIdown = x_sort[rl_1]+((rl-rl_1)/(rl_2-rl_1))*(x_sort[rl_2]-x_sort[rl_1])\r# decision making\rif((side==\u0026quot;upper\u0026quot;) \u0026amp; (PIup\u0026lt;obs)){\rcat(\u0026quot;PI =\u0026quot;,PIup,\u0026quot;,observasi baru=\u0026quot;,obs)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi lebih besar dibandingkan sebagian besar nilai yang ada\u0026quot;)\r} else if((side==\u0026quot;lower\u0026quot;) \u0026amp; (PIdown\u0026gt;obs)){\rcat(\u0026quot;PI =\u0026quot;,PIdown, \u0026quot;,observasi baru=\u0026quot;,obs)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi lebih kecil dibandingkan sebagian besar nilai yang ada\u0026quot;)\r} else if(side==\u0026quot;\u0026quot;){\rprint(\u0026quot;side belum ditentukan tentukan apakah lower atau upper\u0026quot;)\r} else{\rcat(\u0026quot;batas bawah =\u0026quot;,PIdown,\u0026quot;, batas atas =\u0026quot;,PIup)\rcat(\u0026quot;\\n---------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi sama dengan sebagian besar nilai yang ada\u0026quot;)\r}\r}\r\rNote: \n\rx: vektor numerik\ralpha: alpha level yang digunakan\robs: observasi baru yang akan dibandingkan\rside: untuk memilih jenis uji satu sisi yang digunakan. nilai yang mungkin adalah Upper (membandingkan dengan limit atas) dan Lower (membandingkan dengan limit bawah)\r\r\rPInp_os(x=gwardat$konsentrasi, obs=355, alpha=0.1, side=\u0026quot;upper\u0026quot;)\r## PI = 316 ,observasi baru= 355\r## ----------------------------------------------------------------------\r## Kesimpulan:\r## nilai observasi lebih besar dibandingkan sebagian besar nilai yang ada\r\r\r10.6 Interval Prediksi Parametrik\rInterval prediksi parametrik juga digunakan untuk menentukan apakah pengamatan baru kemungkinan berasal dari distribusi yang berbeda dari data yang dikumpulkan sebelumnya. Namun, pada metode parametrik asumsi bentuk dari distribusi data akan diperhitungkan. Asumsi ini memberikan lebih banyak informasi untuk membangun interval, asalkan asumsi tersebut valid. Jika data tidak mengikuti distribusi yang diasumsikan, interval prediksi mungkin tidak akurat.\n10.6.1 Interval Prediksi Distribusi Simetris\rAsumsi yang digunakan untuk melakukan perhitungan interval prediksi untuk distribusi data yang simetris adalah data haruslah berdistribusi normal. Interval prediksi selanjutnya dibentuk secara simetris pada kedua sisi nilai mean. Interval ini lebih lebar rentangnya dibandingkan dengan interval kepercayaan nilai mean. Persamaan matematis yang digunakan untuk menghitungnya dituliskan pada Persamaan (13).\n\\[\\begin{equation}\rPI=\\overline{X}-t_{\\left(\\frac{\\alpha}{2},n-1\\right)}\\cdot\\sqrt{s^2+\\left(\\frac{s^2}{n}\\right)}sampai\\ \\overline{X}+t_{\\left(\\frac{\\alpha}{2},n-1\\right)}\\cdot\\sqrt{s^2+\\left(\\frac{s^2}{n}\\right)}\r\\tag{13}\r\\end{equation}\\]\rUntuk interval satu sisi Persamaan (13), menjadi Persamaan (14).\n\\[\\begin{equation}\rPI=\\overline{X}-t_{\\left(\\alpha,n-1\\right)}\\cdot\\sqrt{s^2+\\left(\\frac{s^2}{n}\\right)}sampai\\ \\overline{X}+t_{\\left(\\alpha,n-1\\right)}\\cdot\\sqrt{s^2+\\left(\\frac{s^2}{n}\\right)}\r\\tag{14}\r\\end{equation}\\]\rUntuk lebih memahaminya misalkan terdapat hasil pengukuran baru konsentrasi arsenik sebesar 350 ppb dengan menggunakan data pada Tabel 3 sebagai pembanding. Buktikan bahwa observasi baru tersebut berasal dari distrubusi yang sama dengan \\(\\alpha\\)=5%.\nDengan menggunakan Persamaan (13), interval prediksi dapat dihitung sebagai berikut:\n\\[\rPI\\ =\\ 98,4-t_{\\left(0.025,24\\right)}\\cdot\\sqrt{144,7^2+\\frac{144,7^2}{25}\\ }sampai\\ \\ 98,4+t_{\\left(0.025,24\\right)}\\cdot\\sqrt{144,7^2+\\frac{144,7^2}{25}}\r\\]\n\\[\rPI\\ =\\ 98,4-2,064\\cdot147,6\\ \\ sampai\\ \\ 98,4+2,064\\cdot147,6\r\\]\n\\[\rPI\\ =\\ -206,25\\ \\ sampai\\ \\ 403,05\r\\]\nBerdasarkan hasil perhitungan yang dilakukan terlihat bahwa limit interval prediksi yang dihasilkanterdapat nilai negatif. Kosentrasi negatif mengindikasikan bahwa data yang digunakan tidaklah simetris sehingga penggunaan interval prediksi untuk data yang simetris tidak dapat digunakan pada data tersebut. Metode perhitungan interval prediksi untuk data asimetris lebih cocok untuk digunakan.\nPada R interval prediksi disekitar nilai mean dapat dihitung menggunakan fungsi berikut:\nPI_sim \u0026lt;- function(x, obs, alpha, side){\r# menghitung nilai mean\rave = mean(x, na.rm=TRUE)\r# menghitung nilai varians dara\rvar = var(x, na.rm=TRUE)\r# menghitung df\rn = length(x)\rdf = n-1\r# perhitungan rentang satu sisi\rpi_l1 = ave-qt((1-alpha), df)*sqrt(var+(var/n))\rpi_u1 = ave+qt((1-alpha), df)*sqrt(var+(var/n))\r# perhitungan rentang dua sisi\rpi_l2 = ave-qt((1-alpha/2), df)*sqrt(var+(var/n))\rpi_u2 = ave+qt((1-alpha/2), df)*sqrt(var+(var/n))\r# decision making\rif(side==\u0026quot;upper\u0026quot; \u0026amp; obs\u0026gt;pi_u1){\rcat(\u0026quot;PI Atas =\u0026quot;,pi_u1,\u0026quot;,observasi baru=\u0026quot;,obs)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi lebih besar dibandingkan sebagian besar nilai yang ada\u0026quot;)\r}else if(side==\u0026quot;lower\u0026quot; \u0026amp; obs\u0026lt;pi_l1){\rcat(\u0026quot;PI Bawah =\u0026quot;,pi_l1,\u0026quot;,observasi baru=\u0026quot;,obs)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi lebih kecil dibandingkan sebagian besar nilai yang ada\u0026quot;)\r}else if(side==\u0026quot;two side\u0026quot; \u0026amp; obs\u0026gt;pi_u2){\rcat(\u0026quot;PI Bawah =\u0026quot;,pi_l2,\u0026quot;,observasi baru=\u0026quot;,obs, \u0026quot;,PI Atas =\u0026quot;,pi_u2)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi lebih besar dibandingkan sebagian besar nilai yang ada\u0026quot;)\r}else if(side==\u0026quot;two side\u0026quot; \u0026amp; obs\u0026lt;pi_l2){\rcat(\u0026quot;PI Bawah =\u0026quot;,pi_l2,\u0026quot;,observasi baru=\u0026quot;,obs, \u0026quot;,PI Atas =\u0026quot;,pi_u2)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi lebih kecil dibandingkan sebagian besar nilai yang ada\u0026quot;)\r}else if(side==\u0026quot;upper\u0026quot; \u0026amp; obs\u0026lt;pi_u1){\rcat(\u0026quot;PI Atas =\u0026quot;,pi_u1,\u0026quot;,observasi baru=\u0026quot;,obs)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi sama dengan sebagian besar nilai yang ada\u0026quot;)\r}else if(side==\u0026quot;lower\u0026quot; \u0026amp; obs\u0026gt;pi_l1){\rcat(\u0026quot;PI Bawah =\u0026quot;,pi_l1,\u0026quot;,observasi baru=\u0026quot;,obs)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi sama dengan sebagian besar nilai yang ada\u0026quot;)\r}else{\rcat(\u0026quot;PI Bawah =\u0026quot;,pi_l2, \u0026quot;,observasi baru=\u0026quot;,obs,\u0026quot;,PI Atas =\u0026quot;,pi_u2)\rcat(\u0026quot;\\n---------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi sama dengan sebagian besar nilai yang ada\u0026quot;)\r}\r}\r\rNote: \n\rx: vektor numerik\ralpha: alpha level yang digunakan\robs: observasi baru yang akan dibandingkan\rside: untuk memilih jenis uji digunakan. nilai yang mungkin adalah upper (membandingkan dengan limit atas uji satu sisi), lower (membandingkan dengan limit bawah uji satu sisi) dan two side (uji dua sisi).\r\r\r# interval prediksi satu sisi\rPI_sim(x = gwardat$konsentrasi, obs = 350, alpha=0.05, side=2)\r## PI Bawah = -206.177 ,observasi baru= 350 ,PI Atas = 402.881\r## ---------------------------------------------------------\r## Kesimpulan:\r## nilai observasi sama dengan sebagian besar nilai yang ada\r\r10.6.2 Interval Prediksi Untuk Distribusi Data Yang Tidak Simetris\rUntuk distribusi data yang tidak simetris, data perlu dilakukan transformasi terlebih dahulu sebelum dilakukan. Data di lingkungan khusunya parameter di air cenderung memiliki bentuk distribusi tidak simetris (cenderung memiliki kemencengan positif). Transformasi logaritmik biasanya dapat digunakan untuk data tersebut agar bentuknya dapat simetris dan dapat memenuhi asumsi normalitas pada data. Data yang telah dilakukan transformasi selanjutnya dihitung menggunakan Persamaan (13) untuk interval prediksi dua sisi dan Persamaan (14) untuk interval prediksi satu sisi. Hasil perhitungan selanjutnya dilakukan transformasi kembali sesuai dengan invers dari transformasinya dalam hal ini menggunakan transformasi eksponensial (jika tranformasi awalnya adalah natural log). Untuk data dengan bentuk distribusi logaritmik (kemencengan positif), interval prediksi yang digunakan disajikan pada Persamaan (15) (dua sisi) dan Persamaan (16) (satu sisi).\n\\[\\begin{equation}\rPI=\\exp\\left(\\overline{X}-t_{\\left(\\frac{\\alpha}{2},n-1\\right)}\\cdot\\sqrt{s^2+\\left(\\frac{s^2}{n}\\right)}\\right)\\ sampai\\ \\exp\\left(\\overline{X}+t_{\\left(\\frac{\\alpha}{2},n-1\\right)}\\cdot\\sqrt{s^2+\\left(\\frac{s^2}{n}\\right)}\\right)\r\\tag{15}\r\\end{equation}\\]\r\\[\\begin{equation}\rPI=\\exp\\left(\\overline{X}-t_{\\left(\\alpha,n-1\\right)}\\cdot\\sqrt{s^2+\\left(\\frac{s^2}{n}\\right)}\\right)\\ sampai\\ \\ \\exp\\left(\\overline{X}+t_{\\left(\\alpha,n-1\\right)}\\cdot\\sqrt{s^2+\\left(\\frac{s^2}{n}\\right)}\\right)\r\\tag{16}\r\\end{equation}\\]\rdimana \\(y=\\ln{(x)}\\), \\(\\overline{y}\\) adalah nilai rata-rata dari tranformasi logaritmik data, dan \\(s^2_y\\) adalah varians dari tranformasi logaritmik data.\nDengan menggunakan contoh soal sebelumnya misalkan terdapat observasi baru konsentrasi arsenik sebesar 350 ppb. Kita perlu menentukan apakah observasi baru tersebut berasal dari distribusi yang sama berdasarkan data pada Tabel 3.\nBerdasarkan hasil visualisasi diketahui bahwa distribusi data yang dihasilkan memiliki bentuk kemencengan positif sehingga interval prediksi asimetris dapat digunakan. Dengan menggunakan \\(\\alpha\\)=5% prediksi interval dua sisi dapat dihitung menggunakan Persamaan (15).\n\\[\r\\ln\\left(PI\\right)\\ =\\ 3,71-t_{\\left(0.025,24\\right)}\\cdot\\sqrt{1,96^2+\\frac{1,96^2}{25}\\ }sampai\\ \\ 3,71+t_{\\left(0.025,24\\right)}\\cdot\\sqrt{1,96^2+\\frac{1,96^2}{25}\\ }\r\\] \\[\r\\ln\\left(PI\\right)\\ =\\ 3,71-2,064\\cdot2,11\\ sampai\\ \\ 3,71+2,064\\cdot2,11\r\\]\n\\[\r\\ln\\left(PI\\right)\\ =\\ -1,19\\ \\ sampai\\ \\ 7,53\r\\]\n\\[\rPI=\\ 0,31\\ \\ sampai\\ \\ 1476.07\r\\]\nBerdasarkan hasil yang diperoleh diketahui bahwa observasi baru berada diantara rentang tersebut. Rentang yang dihasilkan cukup besar yang disebabkan karena tinkat kepercayaan yang digunakan juga besar (95%). Pembaca dapat juga menggunakan tingkat kepercayaan yang lain seperti 99% dan 90%. Semakin besar alpha yang digunakan interval prediksi yang dihasilkan semakin kecil. Namun perlu diingat bahwa semakin kecil rentangnya maka error (alpha) juga semakin besar.\nPembaca juga dapat menggunakan bentuk transformasi lain untuk membentuk data yang lebih simetris dan memnuhi asumsi distribusi normal. Bentuk transformasi lain akan mengubah bentuk persamaan yang digunakan. Transformasi kuadrat misalnya akan mengubah transformasi pada ersamaan (15) dan Persamaan (16) menjadi akar kuadrat.\nPada R interval prediksi dengan bentuk transformasi data logaritmik dapat dituliskan sebagai berikut:\nPI_asim \u0026lt;- function(x, obs, alpha, side){\r# transformasi logaritmik (kemencengan positif)\rx_trans = log(x)\r# menghitung nilai mean\rave = mean(x_trans)\r# menghitung nilai varians dara\rvar = var(x_trans)\r# menghitung df\rn = length(x)\rdf = n-1\r# perhitungan rentang satu sisi\rpi_l1 = exp(ave-qt((1-alpha), df)*sqrt(var+(var/n)))\rpi_u1 = exp(ave+qt((1-alpha), df)*sqrt(var+(var/n)))\r# perhitungan rentang dua sisi\rpi_l2 = exp(ave-qt((1-alpha/2), df)*sqrt(var+(var/n)))\rpi_u2 = exp(ave+qt((1-alpha/2), df)*sqrt(var+(var/n)))\r# decision making\rif(side==\u0026quot;upper\u0026quot; \u0026amp; obs\u0026gt;pi_u1){\rcat(\u0026quot;PI Atas =\u0026quot;,pi_u1,\u0026quot;,observasi baru=\u0026quot;,obs)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi lebih besar dibandingkan sebagian besar nilai yang ada\u0026quot;)\r}else if(side==\u0026quot;lower\u0026quot; \u0026amp; obs\u0026lt;pi_l1){\rcat(\u0026quot;PI Bawah =\u0026quot;,pi_l1,\u0026quot;,observasi baru=\u0026quot;,obs)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi lebih kecil dibandingkan sebagian besar nilai yang ada\u0026quot;)\r}else if(side==\u0026quot;two side\u0026quot; \u0026amp; obs\u0026gt;pi_u2){\rcat(\u0026quot;PI Bawah =\u0026quot;,pi_l2,\u0026quot;,observasi baru=\u0026quot;,obs, \u0026quot;,PI Atas =\u0026quot;,pi_u2)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi lebih besar dibandingkan sebagian besar nilai yang ada\u0026quot;)\r}else if(side==\u0026quot;two side\u0026quot; \u0026amp; obs\u0026lt;pi_l2){\rcat(\u0026quot;PI Bawah =\u0026quot;,pi_l2,\u0026quot;,observasi baru=\u0026quot;,obs, \u0026quot;,PI Atas =\u0026quot;,pi_u2)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi lebih kecil dibandingkan sebagian besar nilai yang ada\u0026quot;)\r}else if(side==\u0026quot;upper\u0026quot; \u0026amp; obs\u0026lt;pi_u1){\rcat(\u0026quot;PI Atas =\u0026quot;,pi_u1,\u0026quot;,observasi baru=\u0026quot;,obs)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi sama dengan sebagian besar nilai yang ada\u0026quot;)\r}else if(side==\u0026quot;lower\u0026quot; \u0026amp; obs\u0026gt;pi_l1){\rcat(\u0026quot;PI Bawah =\u0026quot;,pi_l1,\u0026quot;,observasi baru=\u0026quot;,obs)\rcat(\u0026quot;\\n----------------------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi sama dengan sebagian besar nilai yang ada\u0026quot;)\r}else{\rcat(\u0026quot;PI Bawah =\u0026quot;,pi_l2, \u0026quot;,observasi baru=\u0026quot;,obs,\u0026quot;,PI Atas =\u0026quot;,pi_u2)\rcat(\u0026quot;\\n---------------------------------------------------------\u0026quot;)\rcat(\u0026quot;\\nKesimpulan:\u0026quot;)\rcat(\u0026quot;\\nnilai observasi sama dengan sebagian besar nilai yang ada\u0026quot;)\r}\r}\r\rNote: \n\rx: vektor numerik\ralpha: alpha level yang digunakan\robs: observasi baru yang akan dibandingkan\rside: untuk memilih jenis uji digunakan. nilai yang mungkin adalah upper (membandingkan dengan limit atas uji satu sisi), lower (membandingkan dengan limit bawah uji satu sisi) dan two side (uji dua sisi).\r\r\r# interval prediksi satu sisi\rPI_asim(x = gwardat$konsentrasi, obs = 350, alpha=0.05, side=2)\r## PI Bawah = 0.386043 ,observasi baru= 350 ,PI Atas = 1476.073\r## ---------------------------------------------------------\r## Kesimpulan:\r## nilai observasi sama dengan sebagian besar nilai yang ada\r\r\r10.7 Interval Kepercayaan Persentil\rKuantil atau persentil telah digunakan secara tradisional dalam sumber daya air untuk menggambarkan frekuensi kejadian banjir. Dengan demikian banjir 100 tahun adalah persentil ke-99 (0,99 kuantil) dari distribusi puncak banjir tahunan. Besarnya banjir yang diperkirakan hanya akan dilampaui sekali dalam 100 tahun. Banjir 20 tahun besarnya besarnya yang diperkirakan hanya akan dilampaui sekali dalam 20 tahun (5 kali dalam 100 tahun), atau merupakan persentil ke-95 dari puncak tahunan. Demikian pula, banjir 2 tahun adalah median atau persentil ke-50 dari puncak tahunan. Persentil banjir ditentukan dengan asumsi bahwa aliran puncak mengikuti distribusi yang ditentukan seperti distribusi Log Pearson type III atau distribusi Gumbel.\nInteral kepercayaan persentil berbeda dengan interval kepercayaan median. Hal yang paling jelas terlihat adalah interval kepercayaan persentil mengukur interval kepercayaan pada setiap persentil data yang ada, sedangkan intervak kepercayaan media hanya mengukur pada lokasi pusat data atau persentil ke-50.\nInterval kepercayaan persentil juga disebut sebagai interval toleransi. Nilai persentil digunakan sebagai koefisien cakupan dari interal toleransi. Pada chapter ini akan dibahas lebih jauh mengenai metode perhitungan interval toleransi baikdengan metode parametrik maupun dengan metode nonparametrik.\n10.7.1 Interval Kepercayaan Nonparametrik Persentil\rMetode perhitungan interval kepercayaan nonparametrik persentil mirip dengan perhitungan interval kepercayaan median. Kita akan menggunakan kembali tabel binomial jika sampel kita kecil untuk menentukan limit atas dan bawah yang merupakan nilai kritis dari alpha yang telah kita tetapkan. Nilai kritis ini selanjutnya akan ditransformasikan kedalam bentuk rangking pada data yang menunjukkan titik observasi ujung pada interval kepercayaan.\nTabel binomial dimasukkan pada kolom dengan nilai \\(p\\), persentil yang diinginkan interval kepercayaannya. Jadi untuk interval kepercayaan pada persentil ke-75, kolom \\(p=0,75\\) digunakan. Cari pada baris kolom tersebut sampai \\(n\\) dengan probabilitas mendekati alpha level (\\(\\alpha/2\\)) ditemukan. Nilai kritis \\(x_l\\) bawah adalah bilangan bulat yang sesuai dengan probabilitas \\(p^*\\). Nilai kritis kedua \\(x_u\\) juga diperoleh dengan melanjutkan pada kolom tersebut sampai menemukan probabilitas \\(p\u0026#39;=\\left(1-\\frac{\\alpha}{2}\\right)\\). Nilai kritis \\(x_l\\) dan \\(x_u\\) digunakan untuk menghitung rangking \\(R_l\\) dan \\(R_u\\) yang sesuai dengan nilai data di ujung atas dan bawah limit kepercayaan (Persamaan (17) dan Persamaan (18)). Level interval kepercayaan yang dihasilkan akan sama dengan \\(\\left(p\u0026#39;-p\\cdot\\right)\\).\n\\[\\begin{equation}\rR_l=x_l+1\r\\tag{17}\r\\end{equation}\\]\r\\[\\begin{equation}\rR_u=x_u\r\\tag{18}\r\\end{equation}\\]\rUntuk memahami mengenai penerapan interval kepercayaan persentil diberikan sebuah contoh kita diminta untuk menentukan 95% interval kepercayaan nilai persentil ke-20 (\\(C_{0.20}\\)) data konsentrasi arsenik pada Tabel 3 (p=0,2).\nBerdasarkan data pada Tabel 3, nilai persentil ke-20 (\\(\\overline{C}_{0.20}\\))= 3.36ppb, yaitu data yang berada pada rangking 0,2*(26)=5,2 atau dua per sepuluh jarak antara data ke-5 dan ke-6. Untuk menentukan rentang kepercayaan persentil ke-20 sebenarnya dari data, kita perlu menggunakan kembali tabel binomial dengan menginputkan nilai p=0,2. nilai kritis \\(x_l\\) diperoleh dengan mencari probabilitas data pada kolom p=0,2 yang mendekati nilai \\(\\alpha/2\\)=0,025 adalah 1 (\\(p\u0026#39;\\)=0,027, error probabilitas sisi bawah distribusi). Dengan menggunakan Persamaan (17), diperoleh \\(R_l=2\\). Dengan cara sama untuk sisi atas distribusi nilai kritis atas \\(x_u\\) diperoleh dengan menginputkan nilai p=0,20 dengan nilai probabilitas mendekati \\(1-\\frac{\\alpha}{2}\\)= 0,975 diperoleh sebesar 9 (\\(p\u0026#39;\\)=0,983, error probabilitas sisi atas distribusi). Sehingga rentang kepercayaang 95,6% (0,983-0,027=0,956) untuk persentil ke-20 berada pada range data dengan rangkin ke-2 dan ke-9, atau\n\\[\r1,5\\le C_{0.20}\\le8\\ pada\\ \\alpha=0,044\r\\]\nJika data yang kita miliki cukup besar dengan jumlah sampel \\(n\u0026gt;20\\) (sebagian buku menyebutkan \\(n\u0026gt;30\\)), kita dapat menggunakan distribusi normal untuk memperkirakan rentang kepercayaan persentil.Persamaan yang digunakan untuk menentukan batas atas dan bawah disajikan pada Persamaan (19) dan Persamaan (20).\n\\[\\begin{equation}\rR_l=np+z_{\\frac{\\alpha}{2}}\\cdot\\sqrt{np\\left(1-p\\right)}+0,5\r\\tag{19}\r\\end{equation}\\]\r\\[\\begin{equation}\rR_l=np+z_{\\left[1-\\frac{\\alpha}{2}\\right]}\\cdot\\sqrt{np\\left(1-p\\right)}+0,5\r\\tag{20}\r\\end{equation}\\]\rDengan menggunakan contoh sebelumnya kita dapat menghitung kembali rentang kepercayaan 95% persentil ke-20 menggunakan Persamaan (19) dan Persamaan (20) diperoleh rangking data batas bawah dan atas sebagai berikut:\n\\[\rR_l=25\\cdot0,2+\\left(-1,96\\right)\\cdot\\sqrt{25\\cdot0,2\\left(1-0,2\\right)}+0,5\\ =\\ 5-1,96\\cdot2+0,5=1,6\r\\]\n\\[\rR_u=25\\cdot0,2+1,96\\cdot\\sqrt{25\\cdot0,2\\left(1-0,2\\right)}+0,5\\ =\\ 5+1,96\\cdot2+0,5=9,4\r\\]\nBerdasarkan hasil perhitungan diperoleh rangking data batas bawah dan batas atas secara berurutan adalah data ke-2 (batas bawah) dan data-9 (batas atas). Hasil yang diperoleh ini sama dengan yang telah diperoleh sebelumnya.\nPada R kita dapat membentuk fungsi untuk menghitung interval kepercayaan persentil sesuai dengan yang kita inginkan seperti lokasi persentil yang ingin kita uji serta jenis uji yang digunakan berdasarkan jumlah sampel yang kita inputkan. Selain itu rentang kepercayaan ini dapat pula digunakann untuk menghitung rentang kepercayaan median atau persentil ke-50.\nCI_npPercent \u0026lt;- function(x, p, alpha){\r# jumlah observasi\rn = length(x)\r# mengurutkan data\rx = sort(x)\r# membuat vektor yang akan menyimpan\r# hasil loop\rbl = rep(NA,n)\rbu = rep(NA,n)\r# decision makin\rif(n\u0026lt;= 20){\r# looping\rfor(i in 1:n){\rbl[i] = pbinom(i, n, p)\rif(b\u0026gt;alpha/2){\rbreak\r}\r}\rfor(i in 1:n){\rbu[i] = pbinom(i, n, p)\rif(b\u0026gt;(1-(alpha/2))){\rbreak\r}\r}\r# menghitung selisih terhadap alpha dbl = abs(alpha-bl)\rdbu = abs(alpha-bu)\r# mencari titik kritis\rmin_bl = which.min(dbl)\rmin_bu = which.min(dbu)\r# menhitung rangking nilai bawah dan atas\rrl = min_bl + 1\rru = min-bu\r# mencari data sesuai rangking bawah dan atas\rLCI = x[rl]\rUCI = x[ru]\r}else{\r# menghitung rangking nilai bawah dan atas\rrl = (n*p)+qnorm(alpha/2)*sqrt((n*p)*(1-p))+0.5\rru = (n*p)+(qnorm(1-(alpha/2))*sqrt((n*p)*(1-p)))+0.5\r# mencari data sesuai rangking bawah dan atas\rLCI = x[floor(rl)]+ ((rl-floor(rl))/(ceiling(rl)-floor(rl)))*(x[ceiling(rl)]-x[floor(rl)])\rUCI = x[floor(ru)]+ ((ru-floor(ru))/(ceiling(ru)-floor(ru)))*(x[ceiling(ru)]-x[floor(ru)])\r}\rcat(\u0026quot;Lower CI=\u0026quot;, LCI,\u0026quot; \u0026lt;= C(\u0026quot;, p, \u0026quot;) \u0026lt;= \u0026quot;, \u0026quot;Upper CI=\u0026quot;, UCI)\r}\r\rNote: \n\rx: vektor numerik.\rp: persentil yang ingin dicari. Nilai berkisar antara 0 sampai 1.\ralpha: alpha level yang digunakan.\r\r\rPembaca dapat menjalankan fungsi tersebut mengggunakan data pada contoh soal sebelumnya yaitu mencari interval kepercayaan persentil ke-20. Jalankan sintaks berikut untuk mengetahui hasil yang diperoleh.\nCI_npPercent(x= gwardat$konsentrasi, p= 0.2, alpha=0.05)\r\r10.7.2 Uji Nonparametrik Untuk Persentil\rPengujian persentil dilakukan untuk mengecek apakah sebuah persentil berbeda (lebih besar atau lebih kecil) dibandingkan dengan sejumlah nilai. Sebagai contoh misalkan terdapat median kualitas harian suatu parameter tidak boleh melebihi standar yang berlaku sebesar \\(X_0\\) ppb. Contoh lain dalam bidang hidrologi periode ulang hujan (PUH) 10 tahun atau persentil ke-90 dari debit puncak tahunan suatu kawasan dapat dilakukan pengujian apakah nilai yang ada dilapangan berbeda dengan PUH 10 tahunan yang telah kita hitung untuk digunakan dalam mendesain saluran drainase. Pembahasan pengujian persentil tersebut tidak akan sampai menyinggung pengujian hipotesis yang akan dibahas pada Chapter selanjutnya. Pembahasan akan berkisar membandingkan suatu nilai dengan interval kepercayaan seperti yang telah dijelaskan pada pembahasan terkait interval prediksi.\nPengujian apakah sebuah nilai \\(X_0\\) berbeda dengan sejumlah rentang nilai yang ditetapkan dapat dilakukan dengan pengujian dua sisi dan satu sisi. Pengujian satu sisi melihat apakah suatu nilai \\(X_0\\) berada diluar interval kepercayaan persentil atau diantara nilai batas bawah \\(X_l\\) dan nilai batas atasnya \\(X_u\\) (lihat Gambar 10). Sedangkan pengujian satu sisi melihat apakah suatu nilai lebih besar atau lebih kecil (tergantung apakah pengujian satu sisi sebelah atas distribusi atau sebelah bawah distribusi) dari interval kepercayaan persentil yang digunakan (lihat Gambar 11 dan Gambar 12).\n\rFigure 10: Interval estimasi persentil Xp sebagai penguji apakah Xp=X0. A) X0 didalam interval estimasi sehingga Xp tidak berbeda secara signifikan dari X0, B) X0 berada diluar rentang estimasi sehingga Xp berbeda secara signifikan dari X0. (Helsel dan Hirsch, 2002)\r\r\rFigure 11: Interval estimasi persentil Xp sebagai penguji apakah Xp\u0026gt;X0. A) X0 didalam interval estimasi sehingga Xp tidak signifikan lebih besar dari X0, B) X0 berada diluar rentang estimasi sehingga Xp signifikan lebih besar dari X0. (Helsel dan Hirsch, 2002)\r\r\rFigure 12: Interval estimasi persentil Xp sebagai penguji apakah Xp\u0026gt;X0. A) X0 didalam interval estimasi sehingga Xp tidak signifikan lebih kecil dari X0, B) X0 berada diluar rentang estimasi sehingga Xp signifikan lebih kecil dari X0. (Helsel dan Hirsch, 2002)\r\rUntuk menghitungnya secara nonparametrik menggunakan Persamaan (19) dan Persamaan (20) untuk jumlah sampel kecil sedangkan untuk sampel besar kita dapat menggunakan Persamaan (19) dan Persamaan (20).\nDengan menggunakan kembali data pada Tabel 3 kita akan menghitung apakah kadar arsenik kualitas air tanah tersebut melebihi baku mutu arsenik pada air minum dengan baku mutu konsentrasi arsenik tidak melampaui 300 ppb. Dengan menggunakan nilai \\(\\alpha\\)=0,05 dan batas bawah persentil yang digunakan sebagai acuan pembanding adalah persentil ke-90 dapat dihitung sebagai berikut:\n\\[\r\\overline{C}_{0.90}=\\left(25+1\\right)\\cdot0,9=23,4\\ \\left(data\\ point\\right)=300+0,4\\left(340-300\\right)=316\\ ppb\r\\] Karena jumlah sampel lebih besar dari 20, maka kita dapat menghitung batas atas data menggunakan Persamaan (20).\n\\[\rR_l=np+z_{0,05}\\sqrt{np\\left(1-p\\right)}=25\\cdot0,9+\\left(-1,64\\right)\\cdot\\sqrt{2,25}+0,5=20,5\r\\] Kita dapat membulatkan hasilnya menjadi observasi 20 atau 21. Interpolasi linier dapat dilakukan sehingga diperoleh nilai observasi sebesar 215 ppb. Nilai ini lebih kecil dibandingkan \\(X_0\\)=300 ppb, sehingga baku mutu arsenik belum terlampaui oleh kualitas air tanah tersebut.\nKita dapat menggunakan fungsi CI_npPercent() untuk menghitung rentang persentil yang kita inginkan. Untuk pengujian satu sisi nilai alpha yang akan diinputkan perlu dikali oleh dua karena fungsi tersebut pada dasarnya digunakan untuk menghitung rentang kepercayaan persentil secara nonparametrik (nilai alpha dibagi pada kedua sisi). Berikut adalah contoh sintaks untuk menguji apakah sampel yang kita miliki melebihi baku mutu (persentil ke-90 dan alpha=5%):\nCI_npPercent(gwardat$konsentrasi, 0.9, 0.1)\r\r10.7.3 Interval Kepercayaan Parametrik Untuk Persentil\rInterval kepercayaan untuk persentil juga dapat dihitung dengan mengasumsikan bahwa data mengikuti distribusi tertentu. Asumsi distribusi digunakan karena sering ada data yang tidak cukup untuk menghitung persentil dengan presisi yang diperlukan. Menambahkan informasi yang terkandung dalam distribusi akan meningkatkan ketepatan estimasi selama asumsi distribusi masuk akal. Namun ketika distribusi yang diasumsikan tidak sesuai dengan data dengan baik, estimasi yang dihasilkan kurang akurat, dan lebih menyesatkan, daripada jika tidak ada yang diasumsikan. Sayangnya, situasi di mana asumsi paling dibutuhkan ketika ukuran sampel yang kecil, adalah situasi yang sama di mana sulit untuk menentukan apakah data mengikuti distribusi yang diasumsikan.\nPada interval kepercayaan parametrik asumsi terhadap kecocokan data terhadap suatu distribusi perlu diperhatikan. Data di lingkungan umumnya memiliki bentuk distribusimengikuti distribusi lognormal. Selain itu, distribusi yang sering sekali digunakan adalah distribusi Pearson Tipe III dan Gumbel. Kedua pendekatan distribusi tersebut akan mempengaruhi metode perhitungan yang digunakan. Sehingga pengetahuan yang lebih baik mengenaik distribusi tersebut diperlukan. Pada buku ini kita hanya akan membahas mengenai perhitungan interval kepercayaan menggunakan distribusi lognormal. Pembaca dapat membaca mengenai penerapan distribusi lainnya melalui junal yang ditulis oleh Wei dan Song (2019).\nPerhitungan estimasi titik dan interval untuk persentil dengan asumsi distribusi lognormal dapat dilakukan dengan mudah. Pertama sampel rata-rata \\(y\\) dan sampel simpangan baku \\(s_y\\) logaritma dihitung. Estimasi titik kemudian dihitung menggunakan Persamaan (21).\n\\[\\begin{equation}\rX_p=\\exp\\left(\\overline{y}+z_p\\cdot s_y\\right)\r\\tag{21}\r\\end{equation}\\]\rdimana \\(z_p\\) merupakan kuantil ke-\\(p\\) dari distribusi normal standard dan \\(y=\\ln{(x)}\\).\nEstimasi interval untuk median sebelumnya diberikan pada Persamaan (7) dengan asumsi bahwa data mengikuti distribusi lognormal. Untuk persentil lainnya, interval kepercayaan dihitung menggunakan distribusi t non-sentral (Stedinger, 1983). Tabel distribusi itu ditemukan dalam artikel Stedinger, dengan list yang lebih lengkap terdapat pada perpustakaan online atau perangkat lunak matematika. Interval kepercayaan pada \\(X_p\\) dihitung menggunakan Persamaan (22).\n\\[\\begin{equation}\rCI\\left(X_p\\right)=\\exp\\left(\\overline{y}+\\zeta_{\\frac{\\alpha}{2}}\\cdot s_y,\\ \\overline{y}+\\zeta_{\\left[1-\\frac{\\alpha}{2}\\right]}\\cdot s_y\\right)\r\\tag{22}\r\\end{equation}\\]\rdimana \\(\\zeta{\\alpha/2}\\) merupakan \\(\\alpha/2\\) dari kuantil distribusi t non-sentral untuk persentil dengan ukuran sampel \\(n\\) yang diinginkan.\nUntuk lebih memahami penerapannya pembaca dapat mengerjakan contoh soal pada bagian sebelumnya. Dengan menggunakan estimasi interval 90% kita perlu menentukan interval estimasi persentil ke-90 dari data konsentrasi arsenik dengan asumsi distribusi yang digunakan berupa distribusi lognormal.\nDengan menggunakan Persamaan (21) estimasi titik persentil ke-90 dapat dihitung.\n\\[\rC_{0,90}=\\exp\\left(3,17+1,28\\cdot1,96\\right)=292,6\\ ppb\r\\] Nilai tersebut lebih rentanh dibanding estimasi konsentrasi sebelumnya asumsi data mengikuti distribusi lognormal dengan konsentrasi persentil ke-90 arsenik sebesar 316 ppb.\nDengan menggunakan Persamaan (22), interval kepercayaan 90% dapat dihitung.\n\\[\r\\exp\\left(3,17+0,898\\cdot1,96\\right)\u0026lt;C_{0,90}\u0026lt;\\exp\\left(3,17+1,838\\cdot1,96\\right)\r\\]\n\\[\r138,4\u0026lt;C_{0,90}\u0026lt;873,5\r\\]\n\r10.7.4 Uji Parametrik Untuk Persentil\rSeperti pada bagian sebelumnya kita ingin melihat apakah persentil dari sekumpulan data berbeda dengan nilai tertentu (dapat berupa baku mutu). Pengujian dilakukan dengan melihat apakah nilai tertentu tersebut berada diantara interval kepercayaan persentil dari data (uji dua sisi), lebih besar atau lebih kecil dari batas bawah atau batas atas interval kepercayaan persentil (uji satu sisi). Langkah pengujian dilakukan sama dengan sebelumnya dengan menghitung terlebih dulu batas atas atau batas bawah persentil data yang selanjutnya dibandingkan dengan nilai tertentu.\nDengan menggunakan hasil dari perhitungan sebelumnya, dengan menggunakan alpha=0,05 kita perlu menentukan apakah batas bawah interval kepercayaan melampaui baku mutu arsenik sebesar 300 ppb (uji satu sisi). Berdasarkan hasil perhitungan diperoleh batas bawah interval kepercayaan persentil ke-90 sebesar 138,4 ppb atau lebih kecil dibandingkan batas yang ditentukan, sehingga disimpulkan bahwa konsentrasi arsenik persentil ke-90 pada data tidak melampaui baku mutu yang ditentukan.\n\r\r10.8 Interval Kepercayaan Menggunakan Metode Bootstrap\rBootstrap merupakan metode inferensi populasi menggunakan data sampel. Metode ini dikembangkan oleh Bradley Efron pada tahun 1979. Jika pembaca ingin lebih mengenal metode ini pembaca dapat membaca makalahnya di tautan berikut. Pembaca dapat membaca makalah tersebut secara gratis.\nBootstrap mengandalkan pengambilan sampel dengan pengembalian dari data sampel. Teknik ini dapat digunakan untuk memperkirakan standard error (se) dari setiap statistik dan untuk memperoleh interval kepercayaan (CI) untuk itu. Bootstrap sangat berguna ketika CI tidak memiliki bentuk tertutup, atau memiliki bentuk yang sangat rumit.\nMisalkan kita memiliki sejumlah sampel dengan ukuran \\(n\\): \\(X=\\left\\{x_1,x_2,...,x_n\\right\\}\\) dan kita tertarik dengan CI dari beberapa statistik data \\(T=t\\left(X\\right)\\). Metode ini sangat mudah untuk dikerjakan. Kita hanya perlu mengulang sejumlah \\(R\\) kali skema berikut: Untuk pengulangan ke-\\(i\\), sampling dengan pengembalian \\(n\\) data dari data sampel yang tersedia. Namai sampel baru tersebut sebagai sampel bootstrap ke-\\(i\\) , \\(X_i\\), dan hitung statistik (mean, median atu persentil) yang ingin dihitung interval kepercayaannya.\nSebagai hasilnya, kita akan mendapatkan nilai R dari statistik yang telah kita hitung: \\(T_1,T_2,\\ ....,\\ T_R\\). Kita dapat menyebutnya sebagai realisasi bootstrap dari \\(T\\) atau distribusi bootstrap dari \\(T\\). Berdasarkan hal tersebut, kita dapat menghitung CI untuk T.\nPada contoh kali ini penulis akan menyajikan cara melakukan bootstrap untuk menghitung interval kepercayaan pada mean, median, dan persentil. Data yang penulis gunakan adalah data gwardat pada Tabel 3.\nBootstrap pada R dilakukan dengan menggunakan library boot. Berikut adalah contoh pertama menghitung interval kepercayaan median:\n# memuat paket\rlibrary(boot)\r# membuat hasil yang diperoleh lebih random\r# dan reproducible\rset.seed(100)\r# membuat fungsi boot\rmed.boot.func \u0026lt;- function(x,i){\rmedian(x[i])\r}\r# melakukan bootstrap\rmedian.boot \u0026lt;- boot(gwardat$konsentrasi,\r# memasukkan fungsi boot\rmed.boot.func,\r# menentukan jumlah replikasi\rR=1000)\r# print hasil\rmedian.boot\r## ## ORDINARY NONPARAMETRIC BOOTSTRAP\r## ## ## Call:\r## boot(data = gwardat$konsentrasi, statistic = med.boot.func, R = 1000)\r## ## ## Bootstrap Statistics :\r## original bias std. error\r## t1* 19 9.2795 27.3119\rBerdasarkan hasil yang diperoleh diketahui bahwa median dataset original sebesar 19. Pada hasil juga diperoleh nilai bias bootstrap. Nilai bias tersebut merupakan selisih dari nilai rata-rata 1000 median hasil bootstrap dikurangi dengan median sampel keseluruhan (original median). Standard error merupakan standard deviasi dari 1000 median yang terhitung.\nUntuk mengetahui distribusi sampling yang telah kita lakukan. kita dapat melihat distribusi dengan mengeplotkan semua sampel bootstrap pada histogram dan QQ-plot dengan menjalankan sintaks berikut:\n\rFigure 13: Distribusi bootstrap median\r\rBerdasarkan Gambar 13 diketahui bahwa median tidak berdistribusi normal. Hal ini ditunjukkan dari distribusi pada histogram yang membentuk kemencengan positif. Selain itu, distribusi data pada QQ-plot juga tidak mengikuti garis referensi yang ada sehingga dapat disimpulkan bahwa distribusi median bootstrap tidak berdistribusi normal.\nUntuk menghitung interval kepercayaan median dengan tingkat kepercayaan 95%, kita dapat menggunakan fungsi boot.ci(). Berikut adalah sintaks yang digunakan:\nboot.ci(boot.out=median.boot, conf=0.95)\r## Warning in boot.ci(boot.out = median.boot, conf = 0.95): bootstrap\r## variances needed for studentized intervals\r## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\r## Based on 1000 bootstrap replicates\r## ## CALL : ## boot.ci(boot.out = median.boot, conf = 0.95)\r## ## Intervals : ## Level Normal Basic ## 95% (-43.81, 63.25 ) (-72.00, 33.20 ) ## ## Level Percentile BCa ## 95% ( 4.8, 110.0 ) ( 4.8, 100.0 ) ## Calculations and Intervals on Original Scale\rTerdapat 4 buah hasil dari 4 buah metode yang dihasilkan sebagai output fungsi tersebut. Metode Normal mengasumsikan distribusi median bootstrap berdistribusi normal. Berdasarkan hasil visualisasi yang diperoleh diketahui bahwa distribusi data cenderung memiliki kemencengan positif sehingga metode ini tidak dapat digunakan, Selain itu, rentang yang dihasilkan juga terdapat nilai negatif yang mustahik dihasilkan pada konsentrasi arsenik (sebagian besar parameter lingkungan memiliki nilai terkecil \\(\\le0\\)). Metode Basic memiliki asumsi bahwa tidak ada bias antara median data dengan median rata-rata hasil bootstrap. Berdasarkan hasil perhitungan yang dilakukan terlihat bahwa terdapat bias pada hasil bootstrap yang cukup besar sehingga metode ini tidak dapat diterapkan. Metode ketiga adalah metode persentil. Metode ini mengasumsikan bahwa distribusi median simetris, yang telah disinggung sebelumnya bahwa distribusi median tidak simetris sehingga metode ini tidak dapat diterapkan pada kasus ini. Metode terakhir adalah metode BCa (bias-corrected and accelerated) mengoreksi bias dan membuat lebih sedikit asumsi. Metode ini akan sering banyak kita gunakan pada data kita. Berdasarkan seluruh hasil yang telah diperoleh dapat kita simpulkan bahwa metode BCa cukup baik dalam menjelaskan interval kepercayaan median. Selain itu, metode persentil juga mempunyai hasil yang relatif mirip dengan BCa meskipun dari asumsi yang digunakan keempat metode tersebut tidak ada yang terpenuhi.\nPesan peringatan dalam output hasil menunjukkan bahwa interval kepercayaan kelima, disebut sebagai studentized interval, tidak dapat dihitung karena varians untuk sampel bootstrap tidak disediakan. Interval kepercayaan studentized berusaha untuk mengoreksi bias dengan “studentizing” setiap median yang dihitung (misal: mengurangi rata-rata median dan kemudian membaginya dengan standard error). Tampaknya tidak ada rumus umum untuk menghitung standard error untuk median, tetapi ada pedoman dalam literatur untuk memperkirakan kesalahan standar ketika populasi data yang mendasarinya diasumsikan terdistribusi secara normal. Dalam contoh ini, interval BCa tampaknya cukup baik. Perhatikan bahwa dalam beberapa kasus, mungkin ada peringatan bahwa “beberapa interval BCa mungkin tidak stabil.” Dalam hal itu, hasil BCa harus diabaikan jika intervalnya tampak tidak masuk akal, dan pilihan dibuat dari opsi lain yang tersisa, berdasarkan pada Ulasan histogram dan plot probabilitas estimasi bootstrap.\nSetelah pembaca memahami prosedur melakukan bootstrap pada median, pembaca dapat melakukan bootstrap pada persentil dan mean. Untuk bootstrap mean jalankan sintaks berikut:\n# membuat hasil yang diperoleh lebih random\r# dan reproducible\rset.seed(100)\r# membuat fungsi boot\rmean.boot.func \u0026lt;- function(x,i){\rmean(x[i])\r}\r# melakukan bootstrap\rmean.boot \u0026lt;- boot(gwardat$konsentrasi,\r# memasukkan fungsi boot\rmean.boot.func,\r# menentukan jumlah replikasi\rR=1000)\r# print hasil\rmean.boot\r## ## ORDINARY NONPARAMETRIC BOOTSTRAP\r## ## ## Call:\r## boot(data = gwardat$konsentrasi, statistic = mean.boot.func, ## R = 1000)\r## ## ## Bootstrap Statistics :\r## original bias std. error\r## t1* 98.352 -1.396536 27.84389\rDistribusi mean bootstrap disajikan pada Gambar 14\n\rFigure 14: Distribusi bootstrap mean\r\rBerdasrkan hasil yang diperoleh, distribusi mean bootstrap mengikuti distribusi normal. Untuk memperoleh interval kepercayaan mean bootstrap jalankan sintaks berikut:\nboot.ci(boot.out=mean.boot, conf=0.95)\r## Warning in boot.ci(boot.out = mean.boot, conf = 0.95): bootstrap variances\r## needed for studentized intervals\r## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\r## Based on 1000 bootstrap replicates\r## ## CALL : ## boot.ci(boot.out = mean.boot, conf = 0.95)\r## ## Intervals : ## Level Normal Basic ## 95% ( 45.18, 154.32 ) ( 39.21, 149.05 ) ## ## Level Percentile BCa ## 95% ( 47.66, 157.50 ) ( 56.43, 175.06 ) ## Calculations and Intervals on Original Scale\r## Some BCa intervals may be unstable\rBerdasarkan hasil yang diperoleh dapat dilihat bahwa metode BCa tidak dapat digunakan karena hasil yang diperoleh tidak stabil, Ketiga metode lainnya dapat digunakan karena asumsi normalitas (simetri) terpenuhi. Selain itu bias yang dihasilkan relatif kecil sehingga metode Basic juga dapat digunakan.\nBootstrap terkahir yang kita lakukan adalah untuk memperoleh interval kepercayaan persentil dalam hal ini penulis akan mencobanya dengan persentil ke-90. Berikut alah sintaks yang digunakan:\n# membuat hasil yang diperoleh lebih random\r# dan reproducible\rset.seed(100)\r# membuat fungsi boot\rp90.boot.func \u0026lt;- function(x,i){\rquantile(x[i], probs=0.9)\r}\r# melakukan bootstrap\rp90.boot \u0026lt;- boot(gwardat$konsentrasi,\r# memasukkan fungsi boot\rp90.boot.func,\r# menentukan jumlah replikasi\rR=1000)\r# print hasil\rp90.boot\r## ## ORDINARY NONPARAMETRIC BOOTSTRAP\r## ## ## Call:\r## boot(data = gwardat$konsentrasi, statistic = p90.boot.func, R = 1000)\r## ## ## Bootstrap Statistics :\r## original bias std. error\r## t1* 280 -0.9156 85.66162\rVisualisasi distribusi bootstrap persentil 90 disajikan pada Gambar 15\n\rFigure 15: Distribusi bootstrap persentil 90\r\rBentuk visualisasi distribusi bootstrap persentil ke-90 yang dihasilkan pada Gambar 15 terlihat sedikit memiliki kemencengan positif. untuk menghitung interval kepercayaan 95% persentil ke-90 jalankan sintaks berikut:\nboot.ci(boot.out=p90.boot, conf=0.95)\r## Warning in boot.ci(boot.out = p90.boot, conf = 0.95): bootstrap variances\r## needed for studentized intervals\r## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS\r## Based on 1000 bootstrap replicates\r## ## CALL : ## boot.ci(boot.out = p90.boot, conf = 0.95)\r## ## Intervals : ## Level Normal Basic ## 95% (113.0, 448.8 ) ( 76.0, 448.0 ) ## ## Level Percentile BCa ## 95% (112, 484 ) (120, 580 ) ## Calculations and Intervals on Original Scale\rBerdasarkan keempat hasil yang diperoleh, metode BCa cukup baik digunakan sebab distribusi bootstrap yang dihasilkan tidak memenuhi asumsi ketiga metode lainnya.\n\r10.9 Kegunaan Lain Dari Interval Kepercayaan\rSelain digunakan untuk menghitung interval estimasi, interval kepercayaan dapat pula digunakan sebagai pendeteksi adanya outlier, kontrol kualitas, dan penentuan ukuran sampel yang akan digunakan pada suatu penelitian agar hasil yang diperoleh lebih presisi. Pembahasan juga akan disertai apakah normalitas pada distribusi data akan mempengaruhi performa dari ketiga jenis kegunaan interval kepercayaan.\n10.9.1 Implikasi Non-Normalitas Pada Pendeteksian Outlier\rOutlier merupakan pengamatan yang tampak berbeda karakteristiknya dibandingkan sebagian besar pengamatan yang ada. Pengamatan ini seringkli dihapus dari prosedur analisis yang mengharuskan distribusi suatu data mengikuti distribusi normal. Penghapusan observasi ini bisa jadi tidak baik dilakukan sebab bisa saja observasi tersebut valid. Observasi yang bersifat outlier bisa jadi merupakan observasi terpenting sebab bisa saja dapat memberikan gambaran penting pada suatu kondisi ekstrim atau hubungan kausatif yang penting. Penghapusan ini tidak perlu dilakukan selam prosedur pengukuran yang sejenis tersedia dan tidak mengharuskan suatu distribusi data mengikuti distribusi tertentu, meskipun terdapat kelebihan dan kekurangan yang perlu kita perhatikan.\nUntuk menghapus observasi yang kita identifikasikan sebagai outlier, aturan atau tes perlu dilakukan seperti tes yang diajukan oleh Beckman dan Cook (1983). Tes yang paling umum didasarkan pada interval-t, dan mengasumsikan data mengikuti distribusi normal. Biasanya Persamaan (13) untuk interval pediksi data yang mengikuti distribusi normal disederhanakan dengan mengabaikan nilai \\(\\frac{s^2}{n}\\). Nilai diluar interval prediksi tersebut selanjutnya dapat dinyatakan sebagai oulier. Uji lain yang dapat dilakukan adalah dengan visualisasi menggunakan box plot. Nilai diluar \\(Q1-1,5IQR\\) atau \\(Q3+1,5IQR\\) dinyatakan sebagai outlier. Namun pada Chapter ini tidak akan dibahas lebih lanjut sebab pada Chapter 7 telah dibahas mengenai deteksi outlier mellaui visualisasi data.\n\r10.9.2 Implikasi Non-Normalitas Pada Kontrol Kualitas\rPresentasi visual interval kepercayaan yang digunakan secara luas dalam proses industri adalah kontrol chart. Sejumlah kecil produk disampel dari total kemungkinan pada titik waktu tertentu, dan rerata dihitung. Pengambilan sampel diulang pada interval reguler atau acak, tergantung pada desain, menghasilkan serangkaian cara sampel. Ini digunakan untuk membangun satu jenis kontrol chart, xbar chart. Chart ini secara visual mendeteksi ketika rata-rata sampel masa depan menjadi berbeda dari yang digunakan untuk membangun grafik. Keputusan perbedaan didasarkan pada melebihi interval kepercayaan parametrik di sekitar rata-rata yang telah dijelaskan dibagian lain Chapter ini.\nMisalkan laboratorium kimia mengukur larutan standar yang sama beberapa kali selama sehari untuk menentukan apakah peralatan dan operator menghasilkan hasil yang konsisten. Untuk serangkaian pengukuran \\(n\\) pada interval waktu \\(m\\), ukuran sampel total \\(N=N\\cdot M\\). Perkiraan konsentrasi terbaik untuk standar itu adalah rata-rata keseluruhan yang dihitung menggunakan Persamaan (23).\n\\[\\begin{equation}\r\\overline{X}=\\sum_{i=1}^N\\frac{X_i}{N}\r\\tag{23}\r\\end{equation}\\]\r\\(\\overline{X}\\) diplot sebagai garis tengah grafik. Interval kepercayaan pada rata-rata tersebut dijelaskan oleh Persamaan (8), menggunakan ukuran sampel \\(n\\) yang tersedia untuk menghitung setiap nilai rata-rata individu. Batas interval tersebut juga diplotkan sebagai garis paralel pada chart kontrol kualitas. Nilai rata-rata yang akan berada diluar batas plot rata-rata ini hanya sebesar \\(\\alpha\\cdot100\\%\\) dari waktu jika rata-rata berditribusi normal. Observasi yang berada di luar batas lebih sering daripada ini diambil untuk menunjukkan bahwa sesuatu dalam proses telah berubah.\nJika \\(n\\) besar (katakanlah 30 atau lebih), Teorema Limit Pusat menyatakan bahwa rata-rata akan terdistribusi secara normal meskipun data yang mendasarinya mungkin tidak. Namun jika \\(n\\) jauh lebih kecil, seperti yang sering terjadi, berarti mungkin tidak mengikuti pola ini. Khususnya, untuk data yang memiliki kemencengan (data dengan outlier hanya pada satu sisi), distribusi di sekitar rata-rata mungkin masih memiliki kemencengan. Hasilnya adalah nilai besar untuk simpangan baku, dan pita kepercayaan yang lebar. Oleh karena itu, chart akan memiliki kekuatan yang lebih rendah untuk mendeteksi observasi yang mulai menjauh dari nilai rata-rata yang diharapkan daripada jika data tidak memiliki kemencengan.\nChart kontrol juga diproduksi untuk menggambarkan varians proses. Chart kontrol juga menggunakan nilai range (R chart) atau simpangan baku (S chart). Kedua grafik bahkan lebih sensitif terhadap perubahan data dari kondisi normal dibandingkan \\(\\overline{X}\\) chart. Keduanya akan mengalami kesulitan dalam mendeteksi perubahan varian ketika data yang mendasarinya tidak normal, dan ukuran sampel \\(n\\) untuk setiap rata-rata kecil.\n\r10.9.3 Non-Normalitas Terhadap Desain Sampling\rPersamaan t-interval juga digunakan untuk menentukan jumlah sampel yang diperlukan untuk memperkirakan rata-rata dengan tingkat presisi yang ditentukan. Namun, persamaan tersebut membutuhkan data untuk kira-kira mengikuti distribusi normal. Persamaan tersebut harus mempertimbangkan power serta lebar interval. Artinya kita harus memutuskan apakah mean adalah karakteristik yang paling tepat untuk mengukur data yang memiliki kemencengan.\nUntuk memperkirakan ukuran sampel telah cukup untuk menentukan interval estimasi dengan lebar spesifik dapat menggunakan Persamaan (24).\n\\[\\begin{equation}\rn=\\left(\\frac{t_{\\frac{\\alpha}{2},n-1}\\cdot s}{\\Delta}\\right)^2\r\\tag{24}\r\\end{equation}\\]\rdimana \\(s\\) merupakan simpangan baku sampel dan \\(\\Delta\\) merupakan setengah lebar interval yang diinginkan. Seperti yang telah dibahas di atas, untuk ukuran sampel kurang dari 30 hingga 50 dan bahkan lebih besar dengan data yang sangat menceng, perhitungan ini mungkin memiliki kesalahan besar. Perkiraan \\(s\\) akan tidak akurat, dan akan sangat sangat meningkat nilainya karena kemencenga dan/atau outlier apapun. Karenanya, estimasi \\(n\\) yang dihasilkan akan besar. Sebagai contoh, Hakanson (1984) memperkirakan jumlah sampel yang diperlukan untuk memberikan lebar interval yang masuk akal untuk karakteristik sedimen sungai dan danau, termasuk kimia sedimen. Berdasarkan koefisien variasi yang dilaporkan dalam artikel, data untuk sedimen sungai cukup menceng, seperti yang mungkin diharapkan. Ukuran sampel yang diperlukan untuk sungai dihitung pada 200 dan lebih tinggi.\nSebelum menggunakan persamaan sederhana seperti itu, data yang menceng harus ditransformasi terlebih dahulu sehingga lebih simetris, jika bukan berdistribusi normal. Misalnya, logaritma akan secara drastis menurunkan taksiran ukuran sampel untuk data miring, setara dengan Persamaan (15). Ukuran sampel akan dihasilkan yang memungkinkan median (rata-rata geometris) diperkirakan dalam faktor toleransi multiplikasi sama dengan \\(\\pm2\\Delta\\)dalam satuan log.\nMasalah kedua dengan Persamaan (24) untuk memperkirakan ukuran sampel, bahkan ketika data mengikuti distribusi normal, ditunjukkan oleh Kupper dan Hafner (1989). Mereka menunjukkan Persamaan (24) meremehkan ukuran sampel sebenarnya yang diperlukan untuk tingkat presisi tertentu, bahkan untuk perkiraan \\(n\\le40\\). Hal ini disebabkan karena Persamaan (24) tidak mengakui bahwa simpangan baku \\(s\\) hanya estimasi dari nilai sebenarnya \\(\\sigma\\). Mereka menyarankan menambahkan probabilitas toleransi ke Persamaan (24), mirip dengan statement of power. Maka perkiraan lebar interval setidaknya sekecil lebar interval yang diinginkan untuk beberapa persentase tertentu (katakanlah 90 atau 95%) dari waktu tersebut. Misalnya, ketika \\(n\\) akan sama dengan 40 berdasarkan Persamaan (24), lebar interval yang dihasilkan akan lebih kecil dari lebar yang diinginkan \\(2\\Delta\\) hanya sekitar 42% dari waktu. Ukuran sampel seharusnya menjadi 53 untuk memastikan lebar interval berada dalam kisaran toleransi 90% dari waktu.\nUkuran sampel yang diperlukan untuk estimasi interval median atau untuk melakukan tes nonparametrik dari Chapter selanjutnya dapat diturunkan tanpa asumsi normalitas yang diperlukan di atas untuk interval-t. Noether (1987) menjelaskan estimasi ukuran sampel yang lebih kuat ini, yang memasukkan pertimbangan power sehingga lebih valid daripada Persamaan (24). Namun, baik estimasi normalitas distribusi data atau nonparametric mempertimbangkan efek penting dan sering diamati dari musiman atau tren, dan karenanya mungkin tidak pernah memberikan perkiraan yang cukup akurat untuk menjadi sesuatu yang lebih dari sekadar panduan kasar.\nReferensi\nBachman, L. J. 1984. Field and laboratory analyses of water from the Columbia Aquifer in Eastern Maryland. Ground Water 22. 460-467.\rDamanhuri, E. 2011. Statitika Lingkunga. Penerbit ITB.\rDeryto, T. tanpa tahun. Bootstrap in R. Datacamp. https://www.datacamp.com/community/tutorials/bootstrap-r\rEfron, B. 1979. Bootstrap Methods: Another Look at The Jacknife. The Annuals of Statistics. Vol:7(1). 1-26.\rHelsel, D.R., Hirsch, R.M. 2002. statistical Methods in Water Resources. USGS.\rKupper, L. L., and K. B. Hafner. 1989. How appropriate are popular sample size formulas?. American Statistician 43. 101-105.\rNoether, G. E. 1987. Sample size determination for some common nonparametric tests. Journal American Statistical Assoc.. 82, 645-647.\rOfungwu, J. 2014. Statistical Applications For Environmental Analysis and Risk Assessment. John Wiley \u0026amp; Sons, Inc.\rTing Wei, Songbai Song. 2019. Confidence interval estimation for precipitation quantiles based on principle of maximum entropy. Entropy. 21.\r\r\r\r","date":1554224400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554224400,"objectID":"5ce7c5b2d454fcaeda51192b2ac086b1","permalink":"/tutorial/10_penaksiran_secara_statistika/","publishdate":"2019-04-03T00:00:00+07:00","relpermalink":"/tutorial/10_penaksiran_secara_statistika/","section":"tutorial","summary":"body{\rtext-align: justify}\r\r\rDaftar Isi\n\rDefinisi Interval Estimasi\rInterpretasi Interval Estimasi\rInterval Kepercayaan Median\rInterval Kepercayaan Mean\rInterval Prediksi Nonparametrik\rTransformasi DataInterval Prediksi Parametrik\rInterval Kepercayaan Persentil (Interval Toleransi)\rInterval Kepercayaan Menggunakan Metode Bootstrap\rKegunaan Lain Dari Interval Kepercayaan\r\r\rPada Chapter 6-Ringkasan Numerik kita telah belajar beberapa atribut kunci dari data seperti \\(\\overline{X}\\) dan \\(s\\). Kedua nilai tersebut disebut sebagai nilai estimasi sampel dari populasi (untuk mean \\(\\mu\\) dan simpangan baku \\(\\sigma\\)).","tags":null,"title":"10. Penaksiran Secara Statistika","type":"docs"},{"authors":null,"categories":null,"content":"\r\rbody{\rtext-align: justify}\r\r\rDaftar Isi\n\rAturan Dasar Probabilitas\rTeori Bayes\rEkspektasi Matematis\r\r\rProbabilitas merupakan kemungkinan suatu peristiwa akan terjadi. Probabilitas memiliki rentang nilai dari 0 sampai dengan 1. Probabilitas 0 artinya suatu peristiwa (event) mustahil atau tidak pernah terjadi, sedangkan probabilitas 1 menunjukkan suatu peristiwa yang selalu terjadi.\nContoh sederhana dari probabilitas dalam kehidupan sehari-hari adalah ketika kita melempar koin ke udara untuk melihat kemungkinan sisi yang akan tampak saat koin tersebut jatuh ke tanah. Peristiwa yang mungkin akan terjadi adalah mata uang akan menampilkan sisi depan (head) atau sisi belakang (tail). Kemungkinan untuk mendapatkan tail maupun head adalah sama yaitu 0,5.\nPada contoh pelempan koin, kita misalkan kejadian munculnya sisi head adalah \\(A\\), sedangkan peluang munculnya selain sisi head (sisi lainnya) adalah \\(A\u0026#39;\\) Secara sederhana peluang munculnya suatu kejadian \\(A\\) pada contoh tersebut dapat dituliskan kedalam Persamaan (1) dan Persamaan (1).\n\\[\\begin{equation}\rP\\left(A\\right)+P\\left(A\u0026#39;\\right)=1\r\\tag{1}\r\\end{equation}\\]\rdimana\n\\[\\begin{equation}\rP_A=\\frac{Jumlah\\ peristiwa\\ A}{Jumlah\\ peristiwa\\ yang\\ mungkin\\ terjadi}\r\\tag{2}\r\\end{equation}\\]\rPada contoh pelemparan koin, kita ingin mengetahui peluang munculnya head pada pelemparan koin. Jumlah peristiwa yang mungkin terjadi saat pelemparan koin ada 2 yaitu munculnya head atau tail. Peluang munculnya sisi head dapat dihitung menggunakan Persamaan (1) seperti berikut:\n\\[\rP_{head}=\\frac{Jumlah\\ peristiwa\\ head}{Jumlah\\ peristiwa\\ yang\\ mungkin\\ terjadi}=\\frac{1}{2}=0,5\r\\]\nProbabilitas suatu peristiwa dapat dibedakan kedalam 3 kategori, yaitu:\nProbabilitas apriori: probabilitas yang ditentukan sebelumnya tanpa perlu melakukan suatu eksperimen atau kita dapat memperkirakan sebelumnya peristiwa apa saja yang dapat terjadi. Contoh: pelemparan koin, pelemparan dadu,dll.\rProbabilitas frekuensi relatif (empiris): probabilitas yang ditentukan berdasarkan fakta setelah kejadian. Contoh: Berdasarkan hasil survey 80 dari 100 orang responden mahasiswa sadar akan pentingnya memilah sampah, sehingga peluang seorang mahasiswa sadar akan pentingnya pemilahan sampah berdasarkan hasil survey tersebut adalah \\(P_A=\\frac{80}{100}=0,8\\).\rProbabilitas subyektif: probabilitas yang dilakukan berdasarkan pertimbangan perseorangan (seorang ahli atau orang yang berpengalaman). Contoh: probabilitas 10 kantong kompos memiliki berat \u0026lt; 1 kg menurut seorang penjual berdasarkan pengalamannya adalah 0,1 atau dari 10 kantong kompos terdapat satu kantong yang beratnya \u0026lt; 1 kg.\r\r8.1 Aturan Dasar Probabilitas\rSecara umum terdapat dua buah aturan dasar yang digunakan dalam perhitungan probabilitas yaitu aturan penjumlahan dan aturan perkalian. Kedua aturan tersebut akan penulis bahas secara detail pada bagian ini.\nSebelum kita membahas keduanya sebaiknya kita bahas terlebih dahulu pengertian umum yang merupakan elemen dasar dalam memahami konsep probabilitas. Berikut adalah istilah-istilah yang digunakan dalam probabilitas:\nRuang sampel (sample space): gabungan dari semua kemungkinan, dan kemungkinan secara individual yang disebut sebagai titik sampel. Suatu peristiwa didefinisikan sebagai sub-himpunan (subset) dari ruang sampel. Ruang sampel bisa bersifat diskrit atau kontinu, yang dapat bernilai berhingga (finite) maupun tak berhingga. Peristiwa dalam pelemparan koin merupakan contoh ruang sampel berhingga. Contoh lainnya adalah pada pelemparan 2 buah dadu. Ruang sampel yang mungkin terbentuk merupakan kombinasi dari keenam masing-masing mata dadu. Berikut adalah contoh sintaks R untuk menghasilkan ruang sampel pada 2 buah dadu:\r\r# install.packages(\u0026quot;prob\u0026quot;)\rlibrary(prob)\r# ruang sampel 2 buah dadu\rrolldie(2)\r## X1 X2\r## 1 1 1\r## 2 2 1\r## 3 3 1\r## 4 4 1\r## 5 5 1\r## 6 6 1\r## 7 1 2\r## 8 2 2\r## 9 3 2\r## 10 4 2\r## 11 5 2\r## 12 6 2\r## 13 1 3\r## 14 2 3\r## 15 3 3\r## 16 4 3\r## 17 5 3\r## 18 6 3\r## 19 1 4\r## 20 2 4\r## 21 3 4\r## 22 4 4\r## 23 5 4\r## 24 6 4\r## 25 1 5\r## 26 2 5\r## 27 3 5\r## 28 4 5\r## 29 5 5\r## 30 6 5\r## 31 1 6\r## 32 2 6\r## 33 3 6\r## 34 4 6\r## 35 5 6\r## 36 6 6\rBerdasarkan sintaks tersebut terdapat 36 ruang sampel pada pelemparan 2 buah dadu. Ruang sampel yang dihasilkan dapat ditulis \\(Ruang\\ sampel\\ S=\\left\\{\\left(X1,X2\\right)\\left|1\\le X1\\le6;\\ 1\\le X2\\le6\\right|\\right\\}\\).\nPeristiwa mustahil (impossible event): dinyatakan dengan \\(\\phi\\), merupakan peristiwa yang tidak memiliki titik sampel. Dengan demikian , peristiwa tersebut mempunyai himpunan kosong.\rPeristiwa tertentu (certain event): dinyatakan dengan S, merupakan semua peristiwa yang mengandung semua titik sampel dalam ruang sampel.\rPeristiwa komplementer (complementary event): Untuk suatu peristiwa dalam ruang sampel S, peristiwa komplementer dinyatakan dengan E yang mencakup semua titik sampel dalam S yang tidak terkandung dalam E.\r\rSetelah pembaca memahami seluruh istilah tersebut, kita akan kembali menjelaskan kedua aturan dasar perhitungan probabilitas yaitu aturan penjumlahan dan perkalian.\nAturan penjumlahan merupakan aturan yang digunakan untuk menghitung suatu peristiwa A atau peristiwa lain yaitu peristiwa B yang akan terjadi dan ditulis sebagai \\(P\\left(A\\ atau\\ B\\right)\\) atau \\(P\\left(A\\cup B\\right)\\). Terdapat dua buah aturan penjumlahan yaitu:\nAturan penjumlahan peristiwa mutually exclusive.\rAturan penjumlahan untuk peristiwa not mutually exclusive.\r\rAturan selanjutnya adalah aturan perkalian yaitu aturan yang digunakan untuk menghitung bahwa peristiwa A dan peristiwa B akan terjadi bersamaan dan ditulis sebagai \\(P\\left(A\\ dan\\ B\\right)\\) atau \\(P\\left(A\\cap B\\right)\\). Aturan ini terdiri atas:\nAturan perkalian peristiwa independent (bebas).\rAturan perkalian peristiwa dependent (tidak bebas).\r\r8.1.1 Peristiwa Mutually Exclusive\rPeristiwa mutually exclusive merupakan suatu kondisi dimana peristiwa peristiwa satu tidak memungkinkan terjadinya peristiwa lainnya (tidak mungkin terjadi bersamaan). Terjadinya peristiwa A atu B merupakan penjumlahan kemungkinan terjadinya kedua peristiwa tersebut. Probabilitas peritiwa mutually exclusive dapat dituliskan menggunakan Persamaan (3).\n\\[\\begin{equation}\rP\\left(A\\cup B\\right)=P\\left(A\\right)+P\\left(B\\right)\r\\tag{3}\r\\end{equation}\\]\rUntuk memudahkan pembaca memahami peristiwa mutually exclusive bayangkan pembaca diminta melemparkan sebuah dadu. Pembaca diminta untuk menentukan peluang munculnya angka 1 atau 6 pada dadu. Kedua peristiwa tersebut tidak mungkin terjadi bersamaan karena hanya dilakukan menggunakan satu dadu. Selain itu, jumlah himpunan masing-masing peristiwa pertama dan kedua hanyalah satu sehingga tidak memungkinkan adanya irisan pada kedua peristiwa tersebut. Untuk menghitungnya kita dapat langsung menggunakan Persamaan (3).\n\\[\rP\\left(1\\cup 6\\right)=P\\left(1\\right)+P\\left(6\\right)=\\frac{1}{6}+\\frac{1}{6}=\\frac{1}{3}\r\\]\nPeristiwa pada contoh soal tersebut dapat digambarkan menggunakan diagram venn yang ditunjukkan pada Gambar 1).\n## Warning: package \u0026#39;knitr\u0026#39; was built under R version 3.5.3\r\rFigure 1: Diagram venn peristiwa mutually exclusive\r\rJika pembaca ingin menggunakan R untuk menghitung probabilitas peristiwa mutually exclusive, pembaca dapat menggunakan fungsi Prob() pada library prob untuk menghitung secara langsung probabilitas dari subset data. Berikut adalah contoh sintak untuk menghitung probabilitas munculnya angka 1 atau 6 dari pelemparan sebuah dadu:\n# menentukan ruang sampel (S)\rS \u0026lt;- rolldie(1, makespace=TRUE)\r# print\rS\r## X1 probs\r## 1 1 0.1666667\r## 2 2 0.1666667\r## 3 3 0.1666667\r## 4 4 0.1666667\r## 5 5 0.1666667\r## 6 6 0.1666667\r# membuat subset peristiwa 1 dan 2\rlibrary(dplyr)\r## ## Attaching package: \u0026#39;dplyr\u0026#39;\r## The following objects are masked from \u0026#39;package:prob\u0026#39;:\r## ## intersect, setdiff, union\r## The following objects are masked from \u0026#39;package:timeSeries\u0026#39;:\r## ## filter, lag\r## The following objects are masked from \u0026#39;package:stats\u0026#39;:\r## ## filter, lag\r## The following objects are masked from \u0026#39;package:base\u0026#39;:\r## ## intersect, setdiff, setequal, union\rP1 \u0026lt;- filter(S, X1==1)\rP6 \u0026lt;- filter(S, X1==6)\r# menghitung probabilitas gabungan\rP1$probs + P6$probs\r## [1] 0.3333333\r# atau\rProb(P1) + Prob(P6)\r## [1] 0.3333333\rPersamaan (3) dapat diperluas tidak hanya berlaku pada dua buah peristiwa. Jika jenis peristiwa A yang ada sebanyak \\(n\\), maka Persamaan (3) dapat dituliskan kembali menjadi Persamaan (4).\n\\[\\begin{equation}\rP\\left(A_1\\cup A_2\\cup...\\cup A_n\\right)=P\\left(A_1\\right)+P\\left(A_2\\right)+...+P\\left(A_n\\right)\r\\tag{4}\r\\end{equation}\\]\rKumpulan peristiwa yang terjadi \\(\\left\\{A_1,\\ A_2,...,A_n\\right\\}\\) pada ruang sampel \\(S\\) disebut sebagai partisi S jika \\(A_1,\\ A_2,...,A_n\\) merupakan peristiwa dan \\(A_1\\cup A_2\\cup...\\cup A_n=S\\). Sehingga probabilitas seluruh partisi tersebut dapat dituliskan pada Persamaan (5).\n\\[\\begin{equation}\rP\\left(A_1\\cup A_2\\cup...\\cup A_n\\right)=P\\left(A_1\\right)+P\\left(A_2\\right)+...+P\\left(A_n\\right)=P\\left(S\\right)=1\r\\tag{5}\r\\end{equation}\\]\r\r8.1.2 Peristiwa Not Mutually Exclusive\rBila dua buah peristiwa tidak mutually exclusive, maka kedua peristiwa tersebut dapat terjadi secara bersamaan atau memiliki himpunan yang saling beririsan jika ditinjau dari pembahasan pelemparan dadu sebelumnya. Probabilitas suatu peristiwa yang tidak mutually exclusive dapat dituliskan berdasarkan Persamaan (6).\n\\[\\begin{equation}\rP\\left(A\\cup B\\right)=P\\left(A\\right)+P\\left(B\\right)-P\\left(A\\cap B\\right)\r\\tag{6}\r\\end{equation}\\]\rUntuk memahami peristiwa yang tidak mutually exclusive, pembaca dapat membayangkan kembali melempar sebuah dadu. Pembaca diminta menghitung probabilitas keluar angka ganjil pada dadu atau angka prima pada dadu. Kedua peristiwa tersebut memiliki himpunannya masing-masing. Untuk peristiwa angka ganjil himpunan yang terjadi adalah ganjil={1, 3, 5}, sedangkan untuk angka prima adalah prima={1, 2, 3, 5}. Kedua peristiwa tersebut memiliki irisan himpunan yaitu saat mata dadu menunjukkan angka 1, 3, dan 5. Nilai probabilitas kedua peristiwa tersebut tidak bisa dihitung dengan langsung menjumlahkan probabilitas keduanya masing-masing karena terdapat satu peristiwa yang merupakan bagian dari peristiwa lain sehingga peristiwa tersebut sebagian perlu dihilangkan dari probabilitas salah satunya seperti yang ditulikan pada Persamaan (6). Berdasarkan persamaan tersebut probabilitas yang peristiwa tersebut adalah sebagai berikut:\n\\[\rP\\left(ganjil\\cup prima\\right)=P\\left(ganjil\\right)+P\\left(prima\\right)-P\\left(ganjil\\cap prima\\right)=\\frac{3}{6}+\\frac{4}{6}-\\frac{3}{6}=\\frac{3+4-3}{6}=\\frac{2}{3}\r\\]\nPeristiwa not mutually exclusiev dapat digambarkan menggunakan diagram venn yang ditunjukkan pada Gambar 2).\n\rFigure 2: Diagram venn peristiwa not mutually exclusive\r\rPada R peristiwa tersebut dapat dihitung menggunakan sintaks berikut:\n# kita akan menggunakan kembali objek S pada sintaks sebelumnya\r# melakukan subset pada masing-masing peristiwa\rganjil \u0026lt;-subset(S, X1 %in% c(1, 3, 5))\rprima \u0026lt;-subset(S, X1 %in% c(1, 2, 3, 5))\r# menghitung irirsan kedua peristiwa\ririsan \u0026lt;- intersect(ganjil, prima)\r# menghitung probabilitas yang terbentuk\rProb(ganjil)+Prob(prima)-Prob(irisan)\r## [1] 0.6666667\rUntuk contoh yang lain misalkan seorang konsultan pengendalian kerugian diberikan data kerugian klien akibat kebakaran. Terdapat 250 kasus kebakaran dengan sejumlah penyebab. Penyebab utama disebabkan oleh membuang putung rokok sembarangan sebanyak 108 kasus, peralatan memasak sebanyak 95 kasus, pembakaran sebanyak 12 kasus, dan sumber kebakaran tidak diketahui sebanyak 35 kasus. Konsultan pengendalian kerugian ingin mengetahui berapa probabilitas untuk memilih klaim kebakaran dari kelompok dengan penyebab utama akibat aktivitas merokok sembarangan atau akibat pembakaran. Karena konsultan menentukan probabilitas “satu atau yang lain,” ia akan menentukan probabilitas berdasarkan peristiwa majemuk. Konsultan kemudian harus menentukan apakah peristiwa tersebut mutually exclusive atau tidak. Untuk melakukannya ia harus menjawab pertanyaan “Dapatkan seseorang melakukan klaim bahwa peristiwa kebakaran dapat disebabkan oleh aktivitas merokok dan pembakaran yang dilakukan secara bersamaan?. Konsultan menentukan bahwa ini tidak mungkin Oleh karena itu, peristiwa-peristiwa tersebut mutually exclusive dan probabilitas dari kedua peristiwa yang terjadi pada saat yang sama adalah nol. Probabilitas selanjutnya dapat dihitung menggunakan Persamaan (6).\n\\[\rP\\left(merokok\\cup pembakaran\\right)=P\\left(merokor\\right)+P\\left(pembakaran\\right)-P\\left(merokok\\cap pembakaran\\right)\r\\]\n\\[\rP\\left(merokok\\cup pembakaran\\right)=\\left(\\frac{108}{250}\\right)+\\left(\\frac{12}{250}\\right)-0=0,48\\ atau\\ 48\\%\r\\]\nPersamaan (6) dapat diperluas tidak hanya menggunakan dua buah peristiwa tapi dapat dihitung nilai probabilitasnya untuk lebih dari dua peristiwa. Pada Persamaan (7) disajikan persamaan untuk menghitung probabilitas untuk 3 buah peristiwa.\n\\[\\begin{equation}\rP\\left(A\\cup B\\cup C\\right)=P\\left(A\\right)+P\\left(B\\right)+P\\left(C\\right)-P\\left(A\\cap B\\right)-P\\left(A\\cup C\\right)-P\\left(B\\cup C\\right)+P\\left(A\\cup B\\cup C\\right)\r\\tag{7}\r\\end{equation}\\]\rUntuk peristiwa yang lebih banyak kita perlu menggambarkan terlebih dahulu diagram venn dari ruang sampel yang akan kita gunakan.\n\r8.1.3 Peristiwa Dependent\rPeristiwa dependent terjadi bila probabilitas terjadinya satu peristiwa (peristiwa A) dipengaruhi oleh probabilitas terjadinya peristiwa lainnya (peristiwa B) atau \\(P\\left(B\\mid A\\right)\\). Peristiwa ini merupakan probabilitas kondisional karena terjadinya B dipengaruhi oleh terjadinya A. Pendekatan yang digunakan dituliskan pada Persamaan (8).\n\\[\\begin{equation}\rP\\left(A\\mid B\\right)=\\frac{P\\left(A\\cap B\\right)}{P\\left(A\\right)}\\ \\text{dimana P(A)\u0026gt;0}\r\\tag{8}\r\\end{equation}\\]\rUntuk memahami probabbilitas kondisional bayangkan pembaca harus melakukan survey terkait studi AMDAL di suatu kota. Responden yang digunakan merupakan seseorang yang telah menyelesaikan kuliahnya atau telah memperoleh gelar sarjana. Kategorisasi terhadap populasi dilakukan berdasarkan jenis kelamin dan status pekerjaan dengan jumlah yang proporsional dengan jumlah populasinya yang dapat dilihat pada Tabel 1. Sampel diambil dari populasi tersebut sesuai dengan proporsi jenis kelamin dan status pekerjaan. Pada studi ini ingin diketahui manfaat dari pembangunan industri pendirian industri baru bagi kota tersebut.\n\rTable 1:  Populasi orang yang telah menyelesaikan masa studinya di suatu kota.\r\rJenis Kelamin\rBekerja\rBelum Bekerja\rTotal\r\r\r\rLaki-Laki\r460\r40\r500\r\rPerempuan\r140\r260\r400\r\rTotal\r600\r300\r900\r\r\r\rProses survey dilakukan dengan metode wawancara. Responden yang telah dilakukan wawancara selanjutnya tidak boleh diwawancarai lagi sehingga pada jumlah keseluruhan sampel terus berkurang. Hitunglah probabilitas kondisional dari pengambilan responden laki-laki akibat pengambilan responden seseorang yang telah bekerja?.\nBerdasarkan contoh tersebut terdapat dua buah peristiwa yaitu peristiwa responden yang telah bekerja (dilambangkan dengan E) dan responden laki-laki (dilambangkan dengan M) atau dapat dituliskan sebagai berikut:\nM : seorang laki-laki yang terpilih. E : seseorang yang dipilih dan telah bekerja.\nProbabilitas kondisional dari pengambilan responden laki-laki akibat pengambilan responden seseorang yang telah bekerja selanjutnya dihitung seperti berikut:\n\\[\rP\\left(M\\mid E\\right)=\\frac{460}{600}=\\frac{23}{30}\r\\]\nMisalkan \\(n\\left(A\\right)\\) merupakan notasi yang menyatakan jumlah elemen dari suatu set A. Dengan menggunakan notasi tersebut, dimana setiap orang dewasa yang telah menyelesaikan studinya memiliki kesempatan yang sama untuk dipilih sebagai responden dalam penelitian dapat dituliskan sebagai berikut:\n\\[\rP\\left(M\\mid E\\right)=\\frac{n\\left(E\\cap M\\right)}{n\\left(E\\right)}=\\frac{\\frac{n\\left(E\\cap M\\right)}{n\\left(S\\right)}}{\\frac{n\\left(E\\right)}{n\\left(S\\right)}}\r\\]\n\\[\rP\\left(M\\mid E\\right)=\\frac{P\\left(E\\cap M\\right)}{P\\left(E\\right)}\r\\]\nPersamaan yang dihasilkan sesuai dengan Persamaan (8), dimana \\(P\\left(E\\cap M\\right)\\) dan \\(P\\left(E\\right)\\) dihitung berdasarkan besarnya ruang sampel S. Untuk memverivikasi hasil yang telah diperoleh sebelumnya, kita dapat melakukan perhitungan seperti berikut:\n\\[\rP\\left(E\\right)=\\frac{600}{900}\r\\] serta\n\\[\rP\\left(E\\cap M\\right)=\\frac{460}{900}=\\frac{23}{45}\r\\]\nSehingga\n\\[\rP\\left(E\\ \\mid M\\right)=\\frac{\\frac{23}{45}}{\\frac{2}{3}}=\\frac{23}{30}\r\\]\nBerdasarkan hasil yang diperoleh telah dapat dibuktikan bahwa probabilitas kondisional dari pengambilan responden laki-laki akibat pengambilan responden seseorang yang telah bekerja sebesar \\(\\frac{23}{30}\\). Probabilitas lainnya dapat pembaca hitung sendiri untuk lebih memperdalam pengetahuan pembaca mengenai probabilitas kondisional.\nPada R dengan menggunakan contoh soal sebelumnya kita dapat melakukan perhitungan probabilitas kondisional pengambilan sampel laki-laki akibat dari pengambilan sampel seseorang yang telah bekerja. Sintaks yang digunakan adalah sebagai berikut:\n# membuat data frame\rS \u0026lt;- data.frame(\u0026quot;jenis_kelamin\u0026quot;=c(\u0026quot;laki-laki\u0026quot;,\u0026quot;perempuan\u0026quot;),\u0026quot;bekerja\u0026quot;=c(460,140), \u0026quot;belum_bekerja\u0026quot;=c(40,260))\r# reshaping\rlibrary(tidyr)\r## Warning: package \u0026#39;tidyr\u0026#39; was built under R version 3.5.3\rS\u0026lt;-gather(S, key=\u0026quot;status_pekerjaan\u0026quot;,value=\u0026quot;frekuensi\u0026quot;,-jenis_kelamin)\r# melakukan subset dan menghitung probabilitas\r# peluang responden merupakan pegawai\rE \u0026lt;- filter(S, status_pekerjaan==\u0026quot;bekerja\u0026quot;)\rP_E \u0026lt;- sum(E$frekuensi)/sum(S$frekuensi)\r# peluang reponden laki-laki dan berkerja\rE_M \u0026lt;- filter(S, status_pekerjaan==\u0026quot;bekerja\u0026quot;\u0026amp;jenis_kelamin==\u0026quot;laki-laki\u0026quot;)\rP_E_M \u0026lt;-sum(E_M$frekuensi)/sum(S$frekuensi)\r# Probabilitas kondisional\rP_E_M/P_E\r## [1] 0.7666667\r\r8.1.4 Peristiwa Independent\rUntuk menentukan probabilitas dua atau lebih peristiwa akan terjadi bersamaan, perlu ditentukan terlebih dahulu apakaha peristiwa-peristiwa tersebut bersifat bebas. Misalnya dalam melempar 2 buah dadu, probabilitas munculnya angka 1 pada dadu pertama adalah \\(\\frac{1}{6}\\) dan probabilitas munculnya angka 2 pada dadu kedua juga sama dengan dadu pertama. Jika kita menginginkan kedua nilai tersebut muncul bersamaan pada saat pelemparan, maka probabilitas kejadiannya adalah hasil perkalian kedua probabilitas peristiwa pada masing-masing dadu yaitu \\(\\frac{1}{6}\\cdot\\frac{1}{6}=\\frac{1}{36}\\). Pendekatan perhitungan probabilitas untuk peristiwa independent dapat dituliskan pada Persamaan (9).\n\\[\\begin{equation}\rP\\left(A\\cap B\\right)=P\\left(A\\right)\\cdot P\\left(B\\right)\r\\tag{9}\r\\end{equation}\\]\rDengan menggunakan contoh soal sebelumnya, kita akan menentukan probabilitas responden penelitian kita adalah laki-laki (L) dan bekerja (E). Berdasarkan Persamaan (9), probabilitas terpilihnya jenis responden tersebut adalah sebagai berikut:\n\\[\rP\\left(L\\cap E\\right)=\\frac{500}{900}\\cdot\\frac{300}{900}=\\frac{5}{27}\r\\]\nDengan menggunakan R sintaks yang digunakan adalah sebagai berikut:\n# subset responden laki-laki\rL \u0026lt;- filter(S, jenis_kelamin==\u0026quot;laki-laki\u0026quot;)\rE \u0026lt;- filter(S, status_pekerjaan==\u0026quot;bekerja\u0026quot;)\r# probabilitas\rP_L \u0026lt;- sum(L$frekuensi)/sum(S$frekuensi)\rP_E \u0026lt;- sum(E$frekuensi)/sum(S$frekuensi)\r# Probabilitas peristiwa independen\rP_L*P_E\r## [1] 0.3703704\r\r\r8.2 Teori Bayes\rTeori Bayes memberikan formula probabilitas suatu peristiwa yang tergantung pada kontribusi dan ragam pada tahap sebelumnya. Formula tersebut dapat dituliskan pada Persamaan (10).\n\\[\\begin{equation}\rP\\left(B_k\\mid A\\right)=\\frac{P\\left(B_k\\right)\\cdot P\\left(A\\mid B_k\\right)}{\\sum_{i=1}^nP\\left(B_i\\right)\\cdot P\\left(A\\mid B_i\\right)}\\ \\text{dimana k=1,2,...,n}\r\\tag{10}\r\\end{equation}\\]\rUntuk membuktikan persamaan tersebut, kita akan menggunakan Persamaan (8) dengan melihat \\(P\\left(B_k\\cap A\\right)\\) dengan dua cara yang berbeda. Untuk lebih mudahnya, misalkan nilai \\(P\\left(B_k\\right)\u0026gt;0\\) untuk seluruh \\(k\\), sehingga:\n\\[\\begin{equation}\rP\\left(A\\right)\\cdot P\\left(B_k\\mid A\\right)=P\\left(B_k\\cap A\\right)=P\\left(B_k\\right)\\cdot P\\left(A\\mid B_k\\right)\r\\tag{11}\r\\end{equation}\\]\rsejak nilai \\(P\\left(A\\right)\u0026gt;0\\) kita dapat membaginya untuk mendapatkan\n\\[\\begin{equation}\rP\\left(B_k\\mid A\\right)=\\frac{P\\left(B_k\\right)\\cdot P\\left(A\\mid B_k\\right)}{P\\left(A\\right)}\r\\tag{12}\r\\end{equation}\\]\rSekarang ingat kembaili bahwa \\(\\left\\{B_k\\right\\}\\) adalah partisi, teorema probabilitas total probabilitas total memberikan penyebut pada persamaan terkahir menjadi\n\\[\\begin{equation}\rP\\left(A\\right)=\\sum_{k=1}^nP\\left(B_k\\cap A\\right)=\\sum_{k=1}^nP\\left(B_k\\right)\\cdot P\\left(A\\mid B_k\\right)\r\\tag{13}\r\\end{equation}\\]\rApa artinya? Biasanya dalam aplikasinya kita diberikan (atau tahu) probabilitas apriori \\(P\\left(B_k\\right)\\). Kita keluar dan mengumpulkan sejumlah data yang kita gunakan untuk mewakili peristiwa A. Kita ingin tahu: bagaimana kita dapat memperbaharui \\(P\\left(B_k\\mid A\\right)\\) menjadi \\(P\\left(B_k\\mid A\\right)\\)? Jawabannya adalah dengan teori Bayes.\nUntuk memahaminya misalkan sebuah instalasi air menggunakan tawas sebagai koagulannya. Tawas ini disuplai dari 4 perusahaan pemasok bahan kimia. Spesifikasi yang diinginkan adalah paling tidak tawas tersebut mengandung kadar efektif 60%. Data tentang perusaan pemasok dan kegagalan untuk memenuhi standar yang diinginkan adalah:\n\rPerusahaan 1: memasok 20% dengan kegagalan 1 dalam 20 atau kegagalan = 0,05,\rPerusahaan 2: memasok 60% dengan kegagalan 1 dalam 10 atau kegagalan = 0,10,\rPerusahaan 3: memasok 15% dengan kegagalan 1 dalam 10 atau kegagalan = 0,10,\rPerusahaan 4: memasok 5% dengan kegagalan 1 dalam 20 atau kegagalan = 0,05.\r\rBila dari stok tawas digudang tersebut direksi ingin mengetahui berapa kemungkinan terjadinya kegagalan pada stok tawas dari perusaan 1, dengan menggunakan teori Bayes kita dapat menghitungnya seperti berikut:\n\\[\rP\\left(B_i\\mid A\\right)=\\frac{0,20\\cdot0,05}{\\left(0,6\\cdot0,1+0,15\\cdot0,1+0,05\\cdot0,05\\right)}=0,114\r\\]\n\r8.3 Ekspektasi Matematis\rMisalkan Menteri Kesehatan Republik Indonesia merilis hasil studi yang menyatakan usia harapan hidup masyarakat Indonesia adalah 70 tahun. Ini tidak berarti saat kita berusia 65 tahun kita akan meninggal 5 tahun berikutnya. Pengertian usia harapan hidup ini didasarkan pada probabilitas yaitu ekspektasi matematis yang dituliskan pada Persamaan (14).\n\\[\\begin{equation}\rE\\left(X\\right)=\\sum_{i=1}^nx_i\\cdot P\\left(X_i\\right)\r\\tag{14}\r\\end{equation}\\]\rMisalkan terdapat eksperimen yang menghasilkan i buah peristiwa, dan masing-masing mempunyai probabilitas terjadi: p1,p2,p3,..,pi.\nsehingga: p1+p2+p3+…+pk=1 maka ekspektasinya adalah \\(E=p1\\cdot x1+p2\\cdot x2+p3\\cdot x3+...+pi\\cdot xi\\). Hasil perjumlahan tersebut akan menghasilkan Persamaan (14).\nUntuk memahami penerapan ekspektasi matematis, misalkan sebuah konsultan sedang menyiapkan proposal untuk sebuah proyek. Biaya untuk menyiapkan proposal adalah 5 juta rupiah, sedang keuntunga kotor bila proyek ini diperoleh adalah:\n\r50 juta rupiah dengan probabilitas 0,20\r30 juta rupiah dengan probabilitas 0,50\r10 juta rupiah dengan probabilitas 0,20\r0 rupiah dengan probabilitas 0,10.\r\rBila kemungkinan mendapatkan proyek tersebut adalah 0,30, maka keuntungan yang diharapkan adalah:\n\rProbabilitas memperoleh keuntungan 45 juta rupiah (keuntungan kotor-modal)=probabilitas mendapatkan proyek x keuntungan proyek tersebut=0,30 x 0,20 = 0,06\rProbabilitas memperoleh keuntungan 25 juta = 0,30 x 0,50 = 0,15\rProbabilitas memperoleh keuntungan 5 juta = 0,30 x 0,20 = 0,06\rProbabilitas memperoleh kerugian 5 juta = (0,30 x 0,10)+0,70 = 0,73\r\rMaka ekspektasinya = (45 juta x 0,06)+(5 juta x 0,15)+(5 juta x 0,06)-(5 juta x 0,73)=3,1 juta. Dengan demikian perusahaan tersebut dapat memutuskan apakah akan meneruskan membuat proposal tersebut, dengan kemungkinan merugi sebesar 5 juta rupiah (biaya membuat proposal) dan kemungkinan untung 3 juta rupiah.\nReferensi\nDamanhuri, E. 2011. Statitika Lingkunga. Penerbit ITB.\rKerns, G.Jay. 2018. Introduction to Probability and Statistics Using R Third Edition. GNU Free Documentation License.\rJanicak, C.A. 2007. Applied Statistics in Occupational Safety and Health. Government Institutes.\rWalpole, E. R., Myers, H.M., Myers, S.L., Keying Ye. 2011. Probability $ Statistics for Engineering \u0026amp; Scientists Ninth Edition. Prentice Hall.\r\r\r","date":1554224400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554224400,"objectID":"96ed8acad6a9e4fbffc8a5cbd5095d2e","permalink":"/tutorial/08-probabilitas/","publishdate":"2019-04-03T00:00:00+07:00","relpermalink":"/tutorial/08-probabilitas/","section":"tutorial","summary":"body{\rtext-align: justify}\r\r\rDaftar Isi\n\rAturan Dasar Probabilitas\rTeori Bayes\rEkspektasi Matematis\r\r\rProbabilitas merupakan kemungkinan suatu peristiwa akan terjadi. Probabilitas memiliki rentang nilai dari 0 sampai dengan 1. Probabilitas 0 artinya suatu peristiwa (event) mustahil atau tidak pernah terjadi, sedangkan probabilitas 1 menunjukkan suatu peristiwa yang selalu terjadi.\nContoh sederhana dari probabilitas dalam kehidupan sehari-hari adalah ketika kita melempar koin ke udara untuk melihat kemungkinan sisi yang akan tampak saat koin tersebut jatuh ke tanah.","tags":null,"title":"8. Probabilitas","type":"docs"},{"authors":null,"categories":null,"content":"\r\rbody{\rtext-align: justify}\r\r\rDaftar Isi\n\rUkuran Pemusatan Data\rUkuran Sebaran Data\rRingkasan Data Menggunakan Fungsi summary dan stat.desc\rUkuran Kemencengan Data\rOutlier\rTransformasi Data\r\r\rPada bidang lingkungan kita sering kali menemui sebuah pernyataan “konsentrasi rata-rata TSS pada sungai tersebut adalah 30 mg/l” atau “kedalaman penampang saluran tersebut berkisar antara 1 sampai 2 meter”. Kedua pernyataan tersebut merupakan sebuah penyapaian informasi terkait karakteristik data yang ada. Pernyataan yang pertama menyatakan karakteristik nilai pemusatan data, sedangkan yang kedua menyatakan karakteristik sebaran suatu data.\nKarakteristik lain yang sering digunakan untuk menjelaskan suatu data adalah bentuk distibusi suatu data dan estimasi nilai ekstrim seperti nilai masimum dan minimum suatu data. Seluruh karakteristik data tersebut perlu dihitung untuk memperoleh informasi numerik pada data.\nPada chapter ini kita akan membahas terkait metode untuk membuat ringkasan dan deksripsi data. Pembahasan akan terdiri dari ukuran nilai pemusatan data, ukuran sebaran atau variabilitas data dan bentuk distribusi data. Selain itu kita akan membahas nilai ekstrim yang ada pada sebuah data dan transformasi data.\n6.1 Ukuran Pemusatan Data\rNilai rata-rata (mean) dan nilai tengah (median) merupakan dua nilai yang paling umum digunakan untuk menyatakan lokasi pemusatan data meskipun kedua nilai bukanlah satu atau dua ukuran yang tersedia. Apa sajakah properti dari kedua ukuran tersebut dan kapan salah satu atau keduanya dapat digunakan bersamaan?.\n6.1.1 Pengukuran Klasik-Mean\rNilai mean (\\(\\overline{X}\\)) diperoleh dengan menjumlahkan seluruh data dan membaginya dengan jumlah observasinya yang dapat dituliskan seperti Persamaan (1):\n\\[\\begin{equation}\r\\overline{X}=\\text{}\\sum_{_{i=1}}^n\\frac{X_i}{n}\r\\tag{1}\r\\end{equation}\\]\rNilai mean yang disimbolkan dengan “X bar” merupakan nilai mean untuk sampel. Nilai mean untuk populasi disimbolkan oleh huruf Yunani “mu atau \\(\\mu\\)”.\nPada Persamaan (1), jika data terdiri dari banyak grup maka nilai rata-rata dihitung berdasarkan jumlah nilai observasi dikali dengan bobotnya. Nilai mean tersebut disebut sebagai weighted mean yang dapat ditulis berdasarkan Persamaan Persamaan (2).\n\\[\\begin{equation}\r\\overline{X}\\ =\\text{}\\sum_{_{i=1}}^n\\overline{X_i}\\cdot\\frac{n_i}{n}\r\\tag{2}\r\\end{equation}\\]\rdimana \\(\\overline{X_i}\\) merupakan nilai rata-rata grup ke-i dan \\(\\frac{n_i}{n}\\) merupakan bobot pengali yang berupa rasio antara observasi grup ke-i dengan keseluruhan observasi.\nKita biasanya akan berhadapan dengan nilai observasi yang baru sehingga nilai mean yang telah ada akan ikut berubah. Perubahan nilai mean tersebut disebabkan karena setiap observasi yang disertakan dalam perhitungan mean memiliki pengaruhnya masing-masing. Jika observasi tersebut cenderung ekstrim besar maka nilai mean akan bergeser menuju kearahnya begitu juga sebaliknya.\nPengaruh dari sebuah nilai observasi ke-j atau \\(X_j\\) dapat dilihat dengan menghitung seluruh observasi secara bersamaan kecuali observasi ke-j pada sebuah grup. Dapat dituliskan pada Persamaan (4)\n\\[\\begin{equation}\r\\overline{X} =\\text{}\\overline{X_{\\left(j\\right)}}\\ \\cdot\\frac{\\left(n-1\\right)}{n}+X_j\\cdot\\frac{1}{n}\r\\tag{3}\r\\end{equation}\\]\r\\[\\begin{equation}\r\\overline{X} =\\overline{X}_{\\left(j\\right)}+\\left(X_j-\\overline{X}_{\\left(j\\right)}\\right)\\cdot\\frac{1}{n}\r\\tag{4}\r\\end{equation}\\]\rdimana \\(\\overline{X}_{\\left(j\\right)}\\) adalah nilai mean seluruh observasi kecuali \\(X_j\\). Setiap observasi yang mempengaruhi nilai mean keseluruhan (\\(\\overline{X}\\)) didefinisikan oleh \\(\\left(X_j-\\overline{X}_{\\left(j\\right)}\\right)\\) sebagai jarak antara observasi tersebut dengan nilai rata-rata yang tidak termasuk observasi tersebut di dalamnya. Sehingga seluruh nilai observasi tidak memiliki pengaruh yang sama terhadap nilai rata-rata seluruh observasi.\nOutlier merupakan observasi yang memiliki nilai yang ekstrim tinggi atau rendah dibanding seluruh observasi yang ada sehingga memiliki pengaruh yang besar terhadap nilai mean keseluruhan (\\(\\overline{X}\\)). Pengaruhnya yang sangat besar terhadap nilai rata-rata keseluruhan akan menyebabkan nilai rata-rata akan bergeser ke arah outlier tersebut. Selain itu penampilan dari distribusi frekuensi yang terbentuk akan terlihat memiliki ekor yang panjang.\nUntuk lebih memahami pengaruh observasi terhadap nilai rata-rata, disajikan dua buah gambar yaitu: Gambar 1 dan Gambar 2\n## Warning: package \u0026#39;knitr\u0026#39; was built under R version 3.5.3\r\rFigure 1: Nilai mean (segitiga) sebagai titik kesetimbangan pada data.\r\r\rFigure 2: Pergeseran nilai mean (segitiga) ke kiri setelah penghilangan outlier.\r\rPada Gambar 1 disajikan 7 buah data konsentrasi TSS di suatu sungai. Nilai rata-rata TSS pada sungai tersebut adalah 11 mg/l. Jika kita amati sebagian besar data (6 observasi) berada pada rentang nilai konsentrasi TSS 2 sampai 12 mg/l. Observasi yang lain terletak jauh dari mayoritas observasi lainnya yaitu sebesar 37 mg/l. Observasi yang berbeda secara ekstrim dari nilai secara umum pada suatu data disebut sebagai outlier. Nilai outlier tersebut menyebabkan nilai rata-rata yang terbentuk tidak representatif terhadap keseluruhan data yang ada dan cenderung menggeser nilai rata-rata mendekati nilai outlier tersebut. Nilai observasi yang ekstrim biasanya muncul dari adanya kesalahan perlakuan terhadap sampel seperti botol sampel yang digunakan tidak bersih atau prosedur analisa yang dilakukan tidak standar sehingga memungkinkan adanya partikulat udara yang terukur pada proses penimbangan.\nSalah satu cara untuk menangani adanya outlier tersebut adalah dengan menghapus observasi yang merupakan outlier. Pada Gambar 2 terlihat bahwa penghapusan outlier telah menggeser nilai rata-rata ke kiri. Nilai rata-rata yang baru tersebut jika diperhatikan dari Gambar 2 lebih menggambarkan keseluruhan data yang ada. Tidak terlihat adanya nilai yang berada jauh jaraknya dari nilai rata-rata yang baru.\nPada contoh tersebut dapat kita simpulkan bahwa nilai mean sangat sensitif terhadap adanya outlier. Pada prakteknya nilai mean tidaklah berdiri sendiri selama proses analisa. Nilai mean memerlukan nilai lain seperti median untuk menganalisa apakah data yang diperoleh tidak simetris yang dapat mengindikasikan adanya outlier.\nPada R untuk menghitung nilai rata-rata, kita dapat menggunakan fungsi mean(). Format fungsi yang digunakan dituliskan pada persamaan berikut:\nmean(x, trim = 0, na.rm = FALSE)\r\rNote:\n\rx: objek atau vektor numerik.\rtrim: menyatakan fraksi data (berkisar antara 0 sampai 0,5) yang perlu dilakukan pemotongan (trim) pada observasi awal dan akhir x (yang telah diurutkan) sebelum nilai mean dihitung. na.rm: nilai logis yang menyatakan apakah missing value perlu disertakan dalam perhitungan atau tidak. Jika disertakan maka output yang akan dihasilkan adalah NA.\r\r\rAnalisa Nilai Mean Grup Data Tunggal (Single Group)\nUntuk lebih memahami penerapannya pada R, pada Tabel 1 berikut disajikan data terkait debit air suatu sungai.\n## Warning: package \u0026#39;tibble\u0026#39; was built under R version 3.5.3\r\rTable 1: Data Debit Sampel (m3/detik)\r\robservasi\rdebit\r\r\r\r1\r457\r\r2\r185\r\r3\r133\r\r4\r160\r\r5\r119\r\r6\r115\r\r7\r101\r\r8\r58\r\r9\r68\r\r10\r50\r\r11\r65\r\r12\r128\r\r\r\rData pada Tabel 1 dapat divisualisasikan seperti pada Gambar 3:\n\rFigure 3: Visualisasi debit sungai pada sampel\r\rBerdasarkan Gambar 3, terdapat outlier yang ditunjukkan pada debit sungai yang lebih besar dari 400 m3/detik. Hasil tersebut dapat terjadi salah satunya karena adanya kondisi ekstrim seperti banjir yang menyebabkan sungai meluap atau terjadi kesalahan pengukuran dari alat ukur yang ada di lapangan.\nUntuk menghitung nilai rata-rata debit pada data tersebut, masukkan variabel debit yang telah penulis simpan sebagai objek sungai kedalam fungsi mean() seperti berikut:\nmean(sungai$debit)\r## [1] 136.5833\rBerdasarkan hasil yang diperoleh, dapat dilihat bahwa nilai rata-rata debit pada sungai tersebut adalah 136.5833333 \\(m^3/detik\\).\nKita dapat menghitung nilai mean dengan terlebih dahulu menghilangkan outlier pada data. Untuk melakukannya kita perlu melakukan subset terhadap data tanpa outlier di dalamnya sebelum data tersebut dimasukkan kedalam fungsi mean(). Berikut sintaks yang digunakan untuk melakukan hal tersebut:\n# memuat paket\rlibrary(dplyr)\r# melakukan filter terhadap data\rsungai_subset\u0026lt;-sungai%\u0026gt;%\rfilter(debit\u0026lt;=400)\r# menghitung mean\rmean(sungai_subset$debit)\r## [1] 107.4545\rBerdasarkan hasil yang diperoleh terlihat bahwa nilai rata-rata yang baru lebih kecil dari yang sebelumnya (bergeser ke kiri) dengan nilai mean debit sungai yang baru sebesar 107.4545455 \\(m^3/detik\\). Hal ini terjadi karena pengaruh dari data outlier yang telah dihilangkan.\nAnalisa Nilai Rata-Rata Berdarsarkan Grup Data\nPada contoh sebelumnya kita telah melakukan perhitungan nilai mean untuk studi kasus grup tunggal. Pada contoh ini akan disajikan contoh kasus perhitungan nilai mean untuk data berkelompok.\nDataset pada contoh kasus ini diambil dari buku Statistical Methods in Water Resources. Data yang digunakan adalah data konsentrasi TDS dan Uranium di airtanah dengan perbedaan konsentrasi bikarbonate dalam air tanah yaitu \\(\\leq 50\\)% (0) dan \\(\u0026gt;50\\)% (1). Dataset yang digunakan disajikan pada Tabel 2.\n\rNote:  data yang digunakan dapat diunduh pada link berikut google.drive. Simpan dataset tersebut pada working directory pembaca agar mudah dalam proses membaca data.\n\r# memuat library\rlibrary(readxl)\r## Warning: package \u0026#39;readxl\u0026#39; was built under R version 3.5.3\r# memuat data excel\rdata_gw \u0026lt;- read_excel(\u0026quot;hhappc.xls\u0026quot;, sheet=\u0026quot;appc16\u0026quot;)\r# membuang kolom ke-4\rdata_gw\u0026lt;-data_gw %\u0026gt;%\rselect(TDS, Uranium, Bicarbonate) %\u0026gt;%\rmutate(Bicarbonate=as.factor(Bicarbonate))\r\rTable 2: Kosentrasi TDS dan Uranium dalam berbagai kondisi kesadahan\r\rTDS\rUranium\rBicarbonate\r\r\r\r682.65\r0.9315\r0\r\r819.12\r1.9380\r0\r\r303.76\r0.2919\r0\r\r1151.40\r11.9042\r0\r\r582.42\r1.5674\r0\r\r1043.39\r2.0623\r0\r\r634.84\r3.8858\r0\r\r1087.25\r0.9772\r0\r\r1123.51\r1.9354\r0\r\r688.09\r0.4367\r0\r\r1174.54\r10.1142\r0\r\r599.50\r0.7551\r0\r\r1240.81\r6.8559\r0\r\r538.35\r0.4806\r0\r\r607.75\r1.1452\r0\r\r705.89\r6.0876\r0\r\r1290.57\r10.8823\r0\r\r526.09\r0.1473\r0\r\r784.68\r2.6741\r0\r\r953.14\r3.0918\r0\r\r1149.31\r0.7592\r0\r\r1074.22\r3.7101\r0\r\r1116.59\r7.2446\r0\r\r301.20\r5.7129\r1\r\r265.45\r4.7366\r1\r\r295.88\r2.8057\r1\r\r442.36\r5.6290\r1\r\r342.71\r3.0950\r1\r\r361.30\r3.5774\r1\r\r262.07\r1.7711\r1\r\r546.22\r11.2724\r1\r\r273.89\r4.9807\r1\r\r281.38\r4.0833\r1\r\r588.86\r14.6342\r1\r\r574.11\r12.3835\r1\r\r307.09\r1.5291\r1\r\r409.37\r4.4647\r1\r\r327.07\r2.4574\r1\r\r425.69\r6.3042\r1\r\r310.05\r4.5441\r1\r\r289.75\r0.9672\r1\r\r408.18\r2.1568\r1\r\r383.04\r8.3810\r1\r\r255.19\r2.7957\r1\r\r\r\rVisualisasi data Tabel 2, disajikan pada Gambar 4 dan Gambar 5:\n## Warning: package \u0026#39;ggthemes\u0026#39; was built under R version 3.5.3\r\rFigure 4: Visualisasi konsentrasi TDS pada air tanah\r\r\rFigure 5: Visualisasi konsentrasi Uranium pada air tanah\r\rPada dataset tersebut kita ingin melihat apakah terdapat perbedaan antara konsentrasi TDS dan uranium pada kondisi kesadahan bikarbonat \\(\\leq 50\\)% dan \\(\u0026gt; 50\\)%. Untuk melakukannya pada R kita perlu mengelompokkan data tersebut terlebih dahulu berdasarkan variabel bikarbonat. Setelah itu nilai rata-rata dapat dihitung. Berikut sintaks yang digunakan:\ndata_gw %\u0026gt;%\rgroup_by(Bicarbonate) %\u0026gt;%\rsummarize(TDS = mean(TDS), Uranium = mean(Uranium))\r## # A tibble: 2 x 3\r## Bicarbonate TDS Uranium\r## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0 864. 3.47\r## 2 1 364. 5.16\rBerdasarkan hasil yang diperoleh konsentrasi TDS dan Uranium dipengaruhi oleh kesadahan airtanah. Pada konsentrasi Bikarbonate \u0026gt; 50% konsentrasi TDS akan lebih rendah sedangkan konsentrasi Uranium sebaliknya. Untuk menguji apakah nilai tersebut berbeda signifikan, kita perlu melakukan uji hipotesis yang akan dibahas pada Chapter selanjutnya.\n\r6.1.2 Median Sebagai Ukuran Pemusatan Data yang Resistan\rMedian atau persentil 50 (\\(P_{50}\\)) merupakan nilai pusat dari distribusi suatu data yang telah dirangkin berdasarkan besar nilai orbservasinya. Untuk data dengan jumlah observasi ganjil median adalah titik tengah yang memiliki jumlah observasi yang sama baik di atas nilai media maupun di bawahnya. Untuk data dengan jumlah observasi genap, media merupakan rata-rata dari dua titik observasi pusat. Untuk memperoleh median dari suatu distribusi data, langkah pertama yang perlu dilakukan adalah mengurutkan data dari observasi dengan nilai terkecil sampai dengan yang besar sehingga \\(x_1\\) merupakan observasi terkecil hingga \\(x_n\\) merupakan observasi terbesar. Persamaan (5) (untuk data ganjil) dan Persamaan (6) (untuk data genap) merupakan persamaan untuk menghitung median berdasarkan jumlah observasi yang ada.\n\\[\\begin{equation}\rMedian (P_{0.5}) =\\frac{X_{\\left(n+1\\right)}}{2}\r\\tag{5}\r\\end{equation}\\]\r\\[\\begin{equation}\rMedian (P_{0.5}) =\\frac{1}{2}\\cdot\\left(X_{\\left(\\frac{n}{2}\\right)}+X_{\\left(\\frac{n}{2}\\right)+1}\\right)\r\\tag{6}\r\\end{equation}\\]\rMedian hanya dipengaruhi minimal oleh besarnya nilai observasi tunggal, yang ditentukan semata-mata oleh urutan relatif observasi. Resitensi terhadap efek dari perubahan nilai atau kehadiran pengamatan terpencil (outlier) sering merupakan sifat yang diinginkan. Meski demikian median memiliki kelemahan utama yaitu kurang representatif dalam mendeskripsikan rata-rata dari data dibandingkan mean. Hal ini disebabkan karena median tidak menggunakan seluruh nilai yang ada pada data.\nAnalisa Nilai Median Grup Data Tunggal (Single Group)\nKita akan menggunakan kembali data pada Tabel 1 untuk menghitung median data tersebut. Pada R median dihitung menggunakan fungsi median(). Fotmat yang digunakan adalah sebagai berikut:\nmedian(x, na.rm = FALSE)\r\rNote:\n\rx: objek atau vektor numerik.\rna.rm: nilai logis yang menyatakan apakah missing value perlu disertakan dalam komputasi atau tidak.\r\r\rUntuk data pada Tabel 1, median dapat dihitung menggunakan sintaks berikut:\nmedian(sungai$debit)\r## [1] 117\rBerdasarkan hasil komputasi diperoleh median debit sungai sebesar 117 \\(m^3/detik\\). Nilai tersebut tidak berbeda juah dengan nilai mean tanpa outlier data sungai sebesar 107.4545455 \\(m^3/detik\\).\nJika kita melakukan perhitungan menggunakan menggunakan data sungai_subset (tanpa outlier), maka diperoleh 115 \\(m^3/detik\\) yang nilainya juga tidak bergeser jauh dengan median sebelumnya yang membuktikan bahwa median resisten terhadap outlier.\nAnalisa Nilai Median Berdarsarkan Grup Data\nPaca contoh ini kita akan menggunakan kembali data pada Tabel 2. Sintaks berikut adalah cara menghitung median untuk data berkelompok:\ndata_gw %\u0026gt;%\rgroup_by(Bicarbonate) %\u0026gt;%\rsummarize(TDS=median(TDS), Uranium=median(Uranium))\r## # A tibble: 2 x 3\r## Bicarbonate TDS Uranium\r## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0 819. 1.94\r## 2 1 327. 4.46\rPada median TDS kita tidak menemui perbedaan dengan nilai rata-ratanya. Hal ini disebabkan karena bentuk distribusinya yang relatif simetris. Sedangkan pada Uranium distribusi yang terbentuk memiliki kemencengan (skewness) positif. Hal ini menyebabkan nilai mean yang terbentuk akan sangat dipengaruhi oleh observasi dengan nilai ekstrim yang dimiliki.\n\r6.1.3 Ukuran Pemusatan Data Lainnya\rUkuran pemusatan data lainnya yang kurang sering digunakan adalah modus, rata-rata geometrik (geometric mean), dan trimmed mean. Modus merupakan nilai observasi yang sering muncul. Jika kita visualisasikan menggunakan histogram maka modus merupakan bar tertinggi pada histogram. Modus lebih dapat diaplikasikan pada data berkelompok yang nilai observasinya merupakan integer (finite number) dibanding data dengan nilai kontinyu. Modus sangat mudah diperoleh, namun sangat buruk sebagai ukuran pemusatan data untuk jenis data kontinyu karena sering bergantung pengelompokan data yang sewenang-wenang atu semaunya.\nGeometric mean sering digunakan untuk distribusi data memiliki bentuk kemencengan positif. Geometric mean merupakan rata-rata logaritmik yang diubah kembali ke unit asalnya. Untuk menghitungnya digunakan Persamaan (7).\n\\[\\begin{equation}\rGM = \\exp\\left(\\overline{Y}\\right)\r\\tag{7}\r\\end{equation}\\]\rdimana\n\\[\\begin{equation}\rY_i = \\ln\\left(X_i\\right)\r\\tag{8}\r\\end{equation}\\]\rUntuk data yang memiliki kemencengan positif, geometric mean biasanya cukup dekat dengan median. Bahkan, ketika logaritma data simetris, geometric mean adalah estimasi median. Ini karena median dan geometric mean sama. Ketika ditransformasikan kembali ke satuan asli, rerata geometris terus menjadi estimasi untuk median, tetapi bukan merupakan estimasi untuk rerata.\nPada R geometric mean dapat kita hitung menggunakan sintaks fungsi yang kita buat sendiri:\ngeomean \u0026lt;- function(x){\ry = log(x)\rGM = exp(mean(y))\rreturn(GM)\r}\rData pada Tabel 1 merupakan data dengan kemencengan positif. Nilai geometric mean data tersebut dihitung menggunakan sintaks berikut:\ngeomean(sungai$debit)\r## [1] 112.4315\rBerdasarkan hasil komputasi diperoleh nilai geometric mean debit sungai sebesar 112.431498 \\(m^3/detik\\). Nilai yang diperoleh tidak berbeda dengan nilai median sebesar 117 \\(m^3/detik\\).\nKompromi antara median dan mean tersedia dengan memotong beberapa observasi terendah dan tertinggi, dan menghitung mean dari apa yang tersisa. Perkiraan pemusatan data seperti itu tidak dipengaruhi oleh observasi yang paling ekstrem (dan mungkin anomali), seperti mean. Namun mereka memungkinkan besarnya sebagian besar nilai untuk mempengaruhi estimasi, tidak seperti median. Estimator ini disebut “trimmed mean”, dan persentase data yang diinginkan dapat dipangkas. Pemangkasan yang paling umum adalah menghapus 25 persen dari data di setiap ujung - rata-rata yang dihasilkan dari 50 persen pusat data biasanya disebut “trimmed mean”, tetapi lebih tepatnya 25 persen trimmed mean. “trimmed mean 0%” adalah mean sampel itu sendiri, sementara memangkas semua kecuali 1 atau 2 nilai pusat menghasilkan median. Persentase pemangkasan harus secara eksplisit dinyatakan saat digunakan. Trimmed mean adalah estimator yang resistan, karena tidak sangat dipengaruhi oleh outlier, dan bekerja dengan baik untuk berbagai macam bentuk distribusi (normal, lognormal, dll). Ini dapat dianggap sebagai rata-rata tertimbang (weighted mean), di mana data di luar ‘jendela’ cutoff diberi bobot 0, dan mereka yang berada di dalam jendela bobot 1,0 (lihat Gambar 6).\n\rFigure 6: Jendela diagram trimmed mean.\r\rPada R trimmed mean dapat dihitung dengan spesifikasi argumen trim pada fungsi mean(). Pada data debit sungai (Tabel 1) dihitung trimmed mean dengan data yang dipangkas adalah 5% di kedua ujung observasi atau trim=0.1.\nmean(sungai$debit, trim=0.1)\r## [1] 113.2\rNilai yang diperoleh sekarang mendekati nilai median dan geometric mean yaitu sebesar 113.2 \\(m^3/detik\\).\n\r\r6.2 Ukuran Sebaran Data\rSaat kita mengetahui kedalaman rata-rata sungai, kita pasti ingin mengetahui berapa rentang atau variasi dari kedalamannya. Kita tidak cukup hanya dengan mengetahui nilai pemusatan datanya saja, kita juga perlu mengetahui seberapa besar variasi atau variabilitas datanya.\nVariabilitas suatu data diukur dengan melihat sebaran data dari nilai rata-ratanya (mean). Semakin besar sebaran suatu data, semakin tidak berarti nilai rata-ratanya karena nilai rata-ratanya bisa sangat berbeda dari sejumlah nilai pada datanya.\n6.2.1 Pengukuran Klasik (Varian dan Simpangan Baku)\rVarian sampel dan nilai akar dari varian sampel (Simpangan Baku) merupakan ukuran penyebaran data klasik. Sama dengan mean varian dan simpangan baku dipengaruhi oleh outlier. Semakin besar nilai keduanya, semakin besar variabilitas datanya. Kedua ukuran tersebut dinyatakan pada Persamaan (9) dan Persamaan (10).\nVarian Sampel\n\\[\\begin{equation}\rs^2=\\sum_{i=1}^n\\frac{\\left(X_i-\\overline{X}\\right)^2}{\\left(n-1\\right)}\r\\tag{9}\r\\end{equation}\\]\rsimpangan baku\n\\[\\begin{equation}\rs=\\sqrt{s^2}\r\\tag{10}\r\\end{equation}\\]\rKedua nilai tersebut di hitung berdasarkan kuadrat deviasi nilai observasi dari rata-ratanya, sehingga jika pada data terdapat outlier maka nilai outlier akan memperbesar deviasi data dari nilai mean. Ketika outlier hadir, pengukuran menjadi tidak stabil. Hal ini akan memberi kesan sebaran data menjadi jauh lebih besar daripada yang ditunjukkan oleh mayoritas nilai pada data.\nVarian dan simpangan baku pada R dihitung menggunakan fungsi var() (varian) dan sd(). Format yang digunakan adalah sebagai berikut:\nvar(x, na.rm = FALSE)\rsd(x, na.rm = FALSE)\r\rNote:\n\rx: objek atau vektor numerik.\rna.rm: nilai logis yang menyatakan apakah missing value perlu disertakan dalam komputasi atau tidak.\r\r\rAnalisa Varian dan simpangan baku Grup Tunggal\nKita akan menggunakan kembali data pada Tabel 1 untuk menghitung varian dan simpangan baku data tersebut. Berikut adalah sintaks untuk melakukannya:\n# varian data sungai\rvar(sungai$debit)\r## [1] 11926.08\r# simpangan baku data sungai\rsd(sungai$debit)\r## [1] 109.2066\rSekarang mari kita bandingkan dengan data yang tidak menyertakan outlier.\n# varian data sungai\rvar(sungai_subset$debit)\r## [1] 1918.673\r# simpangan baku data sungai\rsd(sungai_subset$debit)\r## [1] 43.80266\rBerdasarkan hasil yang diperoleh terlihat bahwa nilai varian dan simpangan baku data dengan outlier jauh lebih besar dibanding data tanpa outlier.\nAnalisa Varian dan simpangan baku Multi Grup\nPaca contoh ini kita akan menggunakan kembali data pada Tabel 2. Sintaks berikut adalah cara menghitung varian dan simpangan baku untuk data berkelompok:\ndata_gw %\u0026gt;%\rgroup_by(Bicarbonate) %\u0026gt;%\rsummarize(var_TDS=var(TDS), var_Uranium=var(Uranium),\rsd_TDS=sd(TDS), sd_Uranium=sd(Uranium))\r## # A tibble: 2 x 5\r## Bicarbonate var_TDS var_Uranium sd_TDS sd_Uranium\r## \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0 79471. 13.0 282. 3.61\r## 2 1 10559. 13.5 103. 3.68\rJika kita perhatikan nilai varian dan simpangan baku Uranium pada dua kondisi kesadahan memiliki nilai yang nyaris sama. Hal sebaliknya terjadi pada variabel TDS yang menunjukkan perbedaan pada dua ukuran sebaran datanya. TDS pada kesadahan \u0026gt;50% memiliki varian dan simpangan baku yang lebih kecil dibanding kondisi kesadahan satunya, yang menunjukkan data pada kondisi kesadahan \u0026gt;50% lebih tidak tersebar dibanding kesadahan satunya.\n\r6.2.2 Ukuran Sebaran Data yang Resisten Terhadap Outlier\rSimpangan kuartil atau interquartile range (IQR) merupakan ukuran sebaran data yang resisten dan paling sering digunakan. IQR mengukur kisaran 50% pusat data sehingga pengukuran tidak dipengaruhi oleh adanya outlier pada 25% pada data pada setiap ujungnya. Untuk visualisasinya kita dapat melihat kembali pada ambar 6.\nIQR didefinisikan sebagai persentil ke-75 dikurangi dengan persentil ke-25. Persentil ke-75, ke-50 (median) dan ke-25 membagi data menjadi empat tempat berukuran sama. Persentil ke-75 (\\(P_{.75}\\)), juga disebut kuartil atas, adalah nilai yang melebihi tidak lebih dari 75% data dan dilampaui oleh tidak lebih dari 25 persen data. Persentil ke-25 (\\(P_{.25}\\)) atau kuartil lebih rendah adalah nilai yang melebihi tidak lebih dari 25% dari data dan dilampaui oleh tidak lebih dari 75%. Dengan mempertimbangkan data yang telah diurutkan dari yang terkecil ke yang terbesar: \\(X_{i}\\), \\(i=1,...n\\). Persentil (\\(P_j\\)) dihitung berdasarkan Persamaan (11).\n\\[\\begin{equation}\rP_j=X_{\\left(n+1\\right)\\cdot j}\r\\tag{11}\r\\end{equation}\\]\rdimana \\(n\\) merupakan ukuran sampel \\(X_j\\), dan \\(j\\) merupakan fraksi data yang kurang dari atau sama dengan nilai persentil (untuk persentil ke-25, 50, dan 75, \\(j=.25, .50., dan .75\\)).\nPada R, IQR dapat dihitung secara langsung menggunakan fungsi IQR() atau secara tidak langsung menggunakan fungsi quantile(). Penggunaan fungsi quantile() digunakan untuk mencari persentil dari data. Telah dijelaskan sebelumnya bahwa IQR merupakan selisih dari persentil 75 dan persentil 25. Format yang digunakan untuk menghitung IQR adalah sebagai berikut:\n# secara langsung\rIQR(x, na.rm=FALSE)\r# secara tidak langsung\rquantile(x, 3/4)-quantile(x, 1/4)\r# atau\rquantile(x, .75)-quantile(x, .25)\r\rNote:\n\rx: objek atau vektor numerik.\rna.rm: nilai logis yang menyatakan apakah missing value perlu disertakan dalam komputasi atau tidak.\r\r\rPada Tabel 1, kita dapat menghitung IQR dari data. Berikut adalah contoh sintaks yang digunakan:\nIQR(sungai$debit)\r## [1] 72.5\rSalah satu penaksir penyebaran yang resisten selain IQR adalah Median Absolute Deviation, atau MAD. MAD dihitung dengan pertama-tama mendaftar nilai absolut dari semua selisih \\(|d|\\) antara masing-masing pengamatan dan median. Median dari nilai absolut ini adalah MAD yang ditulis berdasarkan Persamaan (12).\n\\[\\begin{equation}\rMAD\\ \\left(X_i\\right)=median\\left|d\\right|\r\\tag{12}\r\\end{equation}\\]\rdimana\n\\[\\begin{equation}\rd_i=X_i-median\\left(X_i\\right)\r\\tag{13}\r\\end{equation}\\]\rPada R, MAD tidak dapat dihitung secara langsung. Kita perlu membuat user defined function untuk dapat digunakan sewaktu-waktu. Berikut adalah fungsi yang dibuat:\nMAD \u0026lt;- function(x){\r# median data\rm = median(x)\r# MAD\rd = abs(x-m)\rmad = mean(d)\r# print\rreturn (mad)\r}\rPada Tabel 1, kita dapat menghitung MAD dari data menggunakan fungsi yang telah dibuat. Berikut adalah contoh sintaks yang digunakan:\nMAD(sungai$debit)\r## [1] 60.41667\r\r\r6.3 Ringkasan Data Menggunakan Fungsi summary dan stat.des\rRingkasan data menggunakan fungsi summary() akan memberikan ringkasan data seperti nilai mean, kuartil, nilai minimum dan maksimum, serta missing value. Jika data berupa variabel tunggal maka output yang dihasilkan berupa nilai-nilai yang telah penulis sebutkan sebelumnya. Berikut adalah contoh sintaks yang digunakan:\nsummary(sungai$debit)\r## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 50.00 67.25 117.00 136.58 139.75 457.00\rJika objek yang diinputkan kedalam fungsi tersebut adalah data frame, maka ringkasan data akan diberikan pada setiap kolom dengan ketentuan berikut:\n\rjika kolom berupa variabel numerik maka output yang diperoleh berupa mean, median, min, max dan kuartil.\rjika kolom berupa factor maka output yang dihasilkan berupa rekapan jumlah observasi pada masing-masing grup.\r\rBerikut adalah contoh sintaks penerapannya:\nsummary(data_gw)\r## TDS Uranium Bicarbonate\r## Min. : 255.2 Min. : 0.1473 0:23 ## 1st Qu.: 322.8 1st Qu.: 1.5578 1:21 ## Median : 560.2 Median : 3.0934 ## Mean : 625.7 Mean : 4.2764 ## 3rd Qu.: 852.6 3rd Qu.: 5.8066 ## Max. :1290.6 Max. :14.6342\rRingkasan data lain dapat dilakukan dengan menggunakan fungsi stat.desc() dari library pastecs. Kelebihan dari ringkasan data menggunakan fungsi ini adalah kita tidak hanya memperoleh ringkasan data dengan ouput seperti diatas, namun kita juga memperoleh output berupa nilai standadr error (SE), confidence interval (CI), dan koefisien variasi (coef.var) yang merupakan hasil bagi dari simpangan baku dibagi dengan nilai rata-rata.\nBerikut adalah sintak yang digunakan untuk menghasilkan ringkasan data menggunakan fungsi stat.desc():\n# memasang paket\rinstall.packages(\u0026quot;pastecs\u0026quot;)\r# memuat paket\rlibrary(pastecs)\r## Warning: package \u0026#39;pastecs\u0026#39; was built under R version 3.5.3\r# ringkasan data\rstat.desc(data_gw)\r## TDS Uranium Bicarbonate\r## nbr.val 4.400000e+01 44.0000000 NA\r## nbr.null 0.000000e+00 0.0000000 NA\r## nbr.na 0.000000e+00 0.0000000 NA\r## min 2.551900e+02 0.1473000 NA\r## max 1.290570e+03 14.6342000 NA\r## range 1.035380e+03 14.4869000 NA\r## sum 2.752873e+04 188.1604000 NA\r## median 5.601650e+02 3.0934000 NA\r## mean 6.256530e+02 4.2763727 NA\r## SE.mean 4.985747e+01 0.5572310 NA\r## CI.mean.0.95 1.005472e+02 1.1237633 NA\r## var 1.093738e+05 13.6622791 NA\r## std.dev 3.307171e+02 3.6962520 NA\r## coef.var 5.285951e-01 0.8643428 NA\r\r6.4 Ukuran Kemencengan Data\rKetika data memiliki kemencengan, nilai mean tidak sama dengan median, tetapi bergeser ke arah ekor distribusi. Jadi untuk kemencengan positif, nilai mean melebihi lebih dari 50% dari data, seperti pada Gambar 7 dan Gambar 8. Simpangan baku juga meningkat dengan data di bagian ekor. Data yang menceng juga mempertanyakan penerapan tes hipotesis yang didasarkan pada asumsi bahwa data memiliki distribusi normal. Tes-tes ini, yang disebut tes parametrik, mungkin bernilai dipertanyakan ketika diterapkan pada data seperti data sumber daya air, karena data seringkali tidak normal atau bahkan simetris.\n\rFigure 7: a) Kemencengan negatif, b) Kemencengan positif.\r\r\rFigure 8: Box plot untuk data dengan a) Kemencengan negatif, b) Kemencengan positif.\r\r6.4.1 Ukuran Kemencengan Klasik\rKoefisien kemencengan (\\(g\\)) merupakan ukuran kemencengan yang sering digunakan. Koefisien kemencengan dituliskan pada Persamaan (14).\n\\[\\begin{equation}\rg=\\frac{n}{\\left(n-1\\right)\\left(n-2\\right)}\\sum_{i=1}^n\\frac{\\left(x_i-\\overline{X}\\right)^3}{s^3}\r\\tag{14}\r\\end{equation}\\]\rKemencengan positif (ekor panjang kekanan) memiliki nilai \\(g\\) positif sedangkan kemencengan negatif (ekor panjang kekiri) memiliki nilai \\(g\\) negatif. Sekali lagi, Pengaruh beberapa outlier adalah penting - suatu distribusi simetris yang memiliki satu outlier akan menghasilkan ukuran kemencengan (\\(g\\)) yang besar (dan mungkin menyesatkan).\nPada R Kita dapat menghitung sendiri koefisien kemencengan (\\(g\\)) menggunakan user define function. Berikut adalah contoh sintaks fungsi yang dibuat:\nskew \u0026lt;- function(x){\rave = mean(x)\rn = length(x)\rsd = sd(x)\rg=(n/((n-1)*(n-2)))*sum(((x-ave)^3)/(sd^3))\rreturn(g)\r}\rPada contoh sebelumnya dengan menggunakan fungsi yang telah dibuat diperoleh koefisien kemencengan sebagai berikut:\nskew(data_gw$Uranium)\r## [1] 1.184417\r\r6.4.2 Ukuran Kemencengan yang Resisten\rUkuran kemencengan yang lebih resisten adalah *quartile skew coefficient8 (\\(qs\\)). Merupakan ukuran kemencengan didasarkan pada ketiga nilai kuartil data seperti yang ditunjukkan pada Persamaan (15) yang menyatakan perbedaan pada jarak kuartil atas dan bawah terhadap median dibagi dengan IQR.\n\\[\\begin{equation}\rqs=\\frac{\\left(P_{.75}-P_{.50}\\right)-\\left(P_{.75}-P_{.25}\\right)}{P_{.75}-P_{.25}}\r\\tag{15}\r\\end{equation}\\]\rKemencengan positif akan memiliki nilai \\(qs\\) positif dan begitupun sebaliknya. Pada R kita dapat menghitung nilai \\(qs\\) menggunakan user define function. Berikut adalah contoh sintaks fungsi yang dibuat:\nqs \u0026lt;- function(x){\rp75 = quantile(x, 3/4)\rp50 = median(x)\rp25 = quantile(x, 1/4)\rskew = ((p75-p50)-(p50-p25))/(p75-p25)\rreturn(skew)\r}\rPada contoh sebelumnya dengan menggunakan fungsi yang telah dibuat diperoleh koefisien kemencengan sebagai berikut:\nqs(data_gw$Uranium)\r## 75% ## 0.2771639\r\r\r6.5 Outlier\rOutlier merupakan pengamatan yang nilainya sangat berbeda dari yang lain dalam kumpulan data, sering menimbulkan kekhawatiran atau alarm. Meskipun sebenarnya kita tidak perlu khawatir dengan adanya outlier . Outlier sering ditangani dengan membuangnya sebelum mendeskripsikan data, atau sebelum beberapa prosedur uji hipotesis chapter-chapter selanjutnya. Sekali lagi, mereka seharusnya tidak perlu dikhawatirkan. Outlier mungkin merupakan poin paling penting dalam kumpulan data dan harus diselidiki lebih lanjut.\nUntuk lebih memahami kenapa outlier begitu penting pada data kita berikut merupakan contoh kasus dari asal kata outlier. Misalkan bahwa data pada “lubang” ozon Antartika, suatu daerah dengan konsentrasi ozon yang sangat rendah, telah dikumpulkan selama kurang lebih 10 tahun sebelum penemuan aktualnya. Namun, rutinitas pengecekan data otomatis selama pemrosesan data menyertakan instruksi untuk menghapus “outlier”. Definisi outlier didasarkan pada konsentrasi ozon yang ditemukan pada pertengahan garis lintang. Dengan demikian semua data yang tidak biasa ini tidak pernah dilihat atau dipelajari selama beberapa waktu. Jika outlier dihapus, risiko diambil hanya dengan melihat apa yang diharapkan dilihat. Jika hal tersebut dilakukan maka anomali yang terjadi pada atmosfer dapat luput kita pelajari.\nBerdasarkan kasus tersebut kita perlu dengan baik mempertimbangkan apakah outlier pada data perlu dihapus atau tidak. Jika berkaitan dengan pembuatan model, penghapusan outlier merupakan sesuatu yang dapat memperbaiki akurasi dari model. Namun, pada sebuah penelitian terkadang diperlukan informasi lebih lanjut mengapa terdapat outlier pada data sehingga kita dapat memperoleh pengetahuan baru dari proses pencarian tersebut.\nOutlier dapat terjadi karena tiga hal, yaitu:\nKesalahan pengukuran atau perekaman data.\rObservasi dari populasi tidak sama dengan sebagian besar data seperti misalnya data debit banji akibat jebolnya sebuah bendungan akan berbeda dengan debit banjir akibat presipitasi.\rKejadian langka pada sebuah populasi yang sedikit memiliki kemencengan pada distribusinya.\r\rMetode grafis seperti box plot sangat membantu dalam mengidentifikasi outlier. Setiap kali outlier terjadi, pertama-tama verifikasi bahwa tidak ada penyalinan, titik desimal, atau kesalahan nyata lainnya yang telah dibuat. Jika tidak, tidak mungkin untuk menentukan apakah titik itu valid. Upaya yang dilakukan untuk verifikasi, seperti menjalankan kembali sampel di laboratorium, akan tergantung pada manfaat yang diperoleh versus biaya verifikasi. Kejadian masa lalu mungkin tidak dapat diduplikasi. Jika tidak ada kesalahan yang dapat dideteksi dan diperbaiki, ** outlier tidak boleh dibuang hanya berdasarkan fakta bahwa mereka tampak tidak biasa**. Outlier sering dibuang untuk membuat data cocok dengan distribusi teoretis yang sudah terbentuk sebelumnya seperti distribusi normal. Tidak ada alasan untuk menganggap bahwa mereka seharusnya dibuang! Seluruh rangkaian data dapat muncul dari distribusi yang memiliki kemencengan, dan mengambil logaritma atau transformasi lain dapat menghasilkan data yang cukup simetris. Bahkan jika tidak ada transformasi yang mencapai simetri, outlier tidak perlu dibuang. Daripada menghilangkan data aktual (dan mungkin sangat penting) untuk menggunakan prosedur analisis yang membutuhkan simetri atau normalitas, prosedur yang tahan terhadap outlier harus digunakan. Jika menghitung rata-rata tampak bernilai kecil karena outlier, median telah terbukti menjadi ukuran lokasi yang lebih tepat untuk data yang memiliki kemencengan. Jika melakukan uji-t (dijelaskan pada chapter selanjutnya) tampaknya tidak valid karena set data yang tidak normal, gunakan rank-sum test sebagai gantinya.\nSingkatnya, biarkan panduan data prosedur analisis yang digunakan, daripada mengubah data untuk menggunakan beberapa prosedur yang memiliki persyaratan terlalu ketat untuk situasi yang dihadapi.\n\r6.6 Transformasi Data\rTransformasi data dilakukan untuk memenuhi tiga tujuan, antara lain:\nmembuat data lebih simetris,\rmembuat data lebih linier, dan\rmembuat data memiliki varian yang konsisten.\r\rBeberapa ilmuwan lingkungan takut bahwa dengan mentransformasikan data, hasilnya diperoleh yang sesuai dengan gagasan yang telah terbentuk sebelumnya. Oleh karena itu, transformasi adalah metode untuk melihat apa yang ingin kita lihat dari data. Namun dalam kenyataannya, masalah serius dapat terjadi ketika prosedur dengan asumsi simetri, linieritas, atau homoseksualitas (varians konstan) digunakan pada data yang tidak memiliki karakteristik yang diperlukan ini. Transformasi dapat menghasilkan karakteristik ini, dan dengan demikian penggunaan variabel yang diubah memenuhi tujuan.\nSatu unit pengukuran tidak lebih valid secara apriori daripada yang lainnya. Sebagai contoh, logaritma negatif konsentrasi ion hidrogen (pH), sama validnya dengan sistem pengukuran dengan konsentrasi ion hidrogen itu sendiri. Transformasi seperti akar kuadrat kedalaman air pada sumur sumur, atau akar kubik volume curah hujan, seharusnya tidak mengandung stigma lebih daripada pH. Skala pengukuran ini mungkin lebih sesuai untuk analisis data daripada unit aslinya. Hoaglin (1988) telah menulis artikel yang bagus tentang transformasi tersembunyi, secara konsisten diterima begitu saja, yang umum digunakan oleh semua orang. Oktaf dalam musik adalah transformasi frekuensi logaritmik. Setiap kali piano dimainkan, transformasi logaritmik digunakan! Begitu pula dengan skala Richter untukgempa bumi, mil per galon untuk konsumsi bensin, f-stop untuk eksposur kamera, dll. semua menggunakan transformasi. Dalam ilmu analisis data, keputusan yang menggunakan skala pengukuran harus ditentukan oleh data, bukan dengan kriteria yang ditentukan sebelumnya. Tujuan penggunaan transformasi adalah untuk kesimetrian, linieritas, dan homoskedastisitas. Selain itu, penggunaan banyak teknik tahan seperti persentil dan prosedur uji nonparametrik (akan dibahas kemudian) tidak berbeda dengan skala pengukuran. Hasil rank-sum test, setara nonparametrik dari uji-t, akan persis sama apakah unit asli atau logaritma dari unit tersebut digunakan.\nUntuk membuat distribusi asimetris menjadi lebih simetris, data dapat diubah atau diekspresikan kembali menjadi unit baru. Unit-unit baru ini mengubah jarak antara pengamatan pada plot garis. Efeknya adalah memperluas atau mengecilkan jarak ke pengamatan ekstrem di satu sisi median, membuatnya lebih pada setiap sisinya. Transformasi yang paling umum digunakan dalam bidang lingkungan adalah logaritma, seperti Log debit air, konduktivitas hidrolik, atau konsentrasi sering diambil sebelum analisis statistik dilakukan.\nTransformasi data biasanya melibatkan fungsi power seperti pada fungsi \\(y=x^\\theta\\), dimana x merupakan data yang belum ditransformasi, y adalah data yang telah ditransformasi, dan \\(\\theta\\) merupakan power eksponensial. Pada Gambar 9 nilai \\(\\theta\\) di-list kedalam “ladder of powers” (Velleman dan Hoaglin, 1981 dalam helsel dan Hirsch, 2002), sebuah struktur yang berguna untuk menentukan nilai \\(\\theta\\) yang tepat.\n\rFigure 9: Ladder of power\r\rSeperti yang dapat dilihat dari ladder of powers, setiap transformasi dengan \\(\\theta\\) kurang dari 1 dapat digunakan untuk membuat data dengan kemencengan positif lebih simetris. Dengan membuat box plot atau plot Q-Q dari data yang diubah kita dapat mengetahui apakah transformasi yang telah dilakukan sesuai. Jika transformasi logaritmik memberikan kompensasi yang berlebihan untuk kemiringan yang tepat dan menghasilkan distribusi yang sedikit kiri (kemencengan negatif), transformasi ‘lebih ringan’ dengan \\(\\theta\\) lebih dekat ke 1, seperti transformasi kuadrat atau akar kubik, harus digunakan. Transformasi dengan \\(\\theta\\)\u0026gt; 1 akan membantu membuat data yang condong ke kiri lebih simetris.\nNamun, kecenderungan untuk mencari transformasi ‘terbaik’ harus dihindari. Misalnya, ketika berhadapan dengan beberapa set data yang serupa, mungkin lebih baik untuk menemukan satu transformasi yang bekerja cukup baik untuk semua, daripada menggunakan yang sedikit berbeda untuk masing-masingnya. Harus diingat bahwa setiap set data adalah sampel dari populasi yang lebih besar, dan sampel lain dari populasi yang sama kemungkinan akan menunjukkan transformasi ‘terbaik’ yang sedikit berbeda. Penentuan ‘terbaik’ dalam ketelitian tinggi adalah pendekatan yang jarang sepadan dengan usaha.\nPada Gambar 5 kosentrasi distribusi Uranium pada tiap grup memiliki kemencengan positif. Untuk membuatnya simetris kita perlu melakukan transformasi yang sesuai jenis transformasi yang dilakukan dapat dimulai dari akar kuadrat sampai invers akar kuadrat (berdasarkan Gambar 9). Pada contoh ini kita akan mencoba melakukan trasnformasi logaritmik. Berikut adalah contoh visualisasi hasil transformasinya (lihat Gambar 10:\n\rFigure 10: Visualisasi konsentrasi Uranium hasil tansformasi pada air tanah\r\rBerdasarkan hasil transformasi, kita telah memperoleh ditribusi yang cukup simetris untuk kedua grup data tersebut. Pembaca dapat mencobanya menggunakan transformasi lainnya sendiri.\nReferensi\nDamanhuri, E. 2011. Statitika Lingkunga. Penerbit ITB.\rHelsel, D.R., Hirsch, R.M. 2002. statistical Methods in Water Resources. USGS.\rOfungwu, J. 2014. Statistical Applications For Environmental Analysis and Risk Assessment. John Wiley \u0026amp; Sons, Inc.\rRosadi, D. 2015. Analisis Statistika dengan R. Gadjah Mada University Press.\rSTHDA. Descriptive Statistics and Graphics. http://www.sthda.com/english/wiki/descriptive-statistics-and-graphics.\r\r\r","date":1554224400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554224400,"objectID":"3a45f80d1bcb9d21c00910084e917550","permalink":"/tutorial/06_ringkasan-numerik/","publishdate":"2019-04-03T00:00:00+07:00","relpermalink":"/tutorial/06_ringkasan-numerik/","section":"tutorial","summary":"body{\rtext-align: justify}\r\r\rDaftar Isi\n\rUkuran Pemusatan Data\rUkuran Sebaran Data\rRingkasan Data Menggunakan Fungsi summary dan stat.desc\rUkuran Kemencengan Data\rOutlier\rTransformasi Data\r\r\rPada bidang lingkungan kita sering kali menemui sebuah pernyataan “konsentrasi rata-rata TSS pada sungai tersebut adalah 30 mg/l” atau “kedalaman penampang saluran tersebut berkisar antara 1 sampai 2 meter”. Kedua pernyataan tersebut merupakan sebuah penyapaian informasi terkait karakteristik data yang ada.","tags":null,"title":"6. Ringkasan Data","type":"docs"},{"authors":null,"categories":null,"content":"\r\rbody{\rtext-align: justify}\r\r\rDaftar Isi\n\rGrafik Untuk Melihat Ditribusi Data\rGrafik Untuk Melihat Beda Distribusi Data Antar Grup\rGrafik Untuk Memvisualisasikan Korelasi Antar Variabel\rGrafik Yang Digunakan Untuk Memvisualisasikan Asosiasi Antar Variabel\rGrafik Yang Digunakan Untuk Memisualisasikan Ukuran Sampel dan Perubahan Sepanjang Waktu\r\r\rPada Chapter 4 dan 5 kita telah belajar bagaimana cara membuat grafik menggunakan R. Sejauh ini kita belum belajar kegunaan dari masing-masing grafik yang telah kita pelajarai. Pada Chapter ini kita tidak lagi akan membahas bagaimana membuat grafik menggunakan R. Kita akan fokus terhadap fungsi grafik tersebut dalam analisa kita. Secara umum grafik dibuat untuk memvisualisasikan distribusi, perbedaan antar sampel, korelasi dan asosiasi antar sampel, serta ukuran sampel.\nPenulis dan pembaca pasti sepakat bahwa visualisasi data merupakan tahapan awal yang perlu kita lakukan sebelum memutuskan untuk melakukan analisa data seperti uji hipotesis dan modeling. Angka yang ditampilkan dalam ringkasan data tidaklah cukup untuk melihat data terutama kaitannya dengan pengecekan terhadap asumsi model.\nPada Gambar 1 disajikan delapan buah scatterplot dengan koefisien korelasi yang sama persis. Komputasi statistik tanpa melihat pada visualisasi data akan menyebabkan misinterpretasi pada data. Grafik memberikan ringkasan visual data dengan cepat dan lengkap dibandingkan penyajian data dalam tabel angka.\n## Warning: package \u0026#39;knitr\u0026#39; was built under R version 3.5.3\r\rFigure 1: Scatterplot dengan koefisien korelasi r=0,7.\r\rGrafik sangat penting untuk dua tujuan:\nuntuk memberikan wawasan bagi analis ke dalam data di bawah pengawasan, dan\runtuk mengilustrasikan konsep-konsep penting ketika mempresentasikan hasil kepada orang lain.\r\rTugas pertama disebut Analisis Data Eksplorasi (EDA), dan merupakan subjek Chapter ini. Prosedur EDA seringkali merupakan (atau seharusnya) menjadi ‘pandangan pertama’ pada data. Pola dan teori tentang bagaimana sistem berperilaku dikembangkan dengan mengamati data melalui grafik. Ini adalah prosedur induktif - data dirangkum dibanding dilakukan pengujian. Hasil mereka memberikan panduan untuk pemilihan prosedur pengujian hipotesis deduktif yang tepat.\nSetelah analisis selesai, temuan harus dilaporkan kepada orang lain. Apakah laporan tertulis atau presentasi lisan, analis harus meyakinkan audiens bahwa kesimpulan yang dicapai didukung oleh data. Tidak ada cara yang lebih baik untuk melakukan ini selain melalui grafik. Banyak metode grafis yang sama yang merangkum informasi dengan ringkas untuk analis juga akan memberikan wawasan tentang data untuk pembaca atau audiens.\n7.1 Grafik Untuk Melihat Ditribusi Data\rAnalisis yang umumnya dilihat pada distribusi data adalah apakah data berdistribusi normal atau tidak. Hal ini akan mempengaruhi jenis analisis statistika yang digunakan pada data. Terdapat beberapa grafik yang dapat digunakan untuk melihat bentuk ditribusi data. Grafik-grafik tersebut antara lain: stem and leaf, histogram, density plot, QQ-plot, serta box plot atau violin plot. Pada analisis distribusi stem and leaf kurang populer untuk digunakan. Hal ini disebabkan karena visualisasinya kurang cocok diterapkan pada data dengan jumlah observasi besar. Selain itu, kita juga tidak bisa melakukan perbandingan antar grup menggunakan jenis visualisasi tersebut.\n7.1.1 Histogram\rHistogram adalah grafik yang sudah dikenal, dan konstruksinya dirinci dalam berbagai teks pengantar tentang statistik. Batang digambar dengan tinggi \\(n_i\\), atau fraksi \\(n_i/n\\), dari data yang termasuk dalam salah satu dari beberapa kategori atau interval (Gambar 2). Iman dan Conover (1983) mengemukakan bahwa untuk ukuran sampel \\(n\\), jumlah interval \\(k\\) harus bilangan bulat terkecil sehingga \\(2^k≥n\\).\nHistogram sangat berguna untuk menggambarkan perbedaan besar dalam bentuk data seperti apakah data simetris seperti distribusi normal atau memiliki kemencengan. Histogram tidak dapat digunakan untuk penilaian yang lebih tepat karena tampilan dipengaruhi oleh jumlah batang yang digunakan. Untuk lebih memahaminya perhatikan Gambar 2 dan Gambar 3. Kedua histogram tersebut tampak berbeda meskipun data input yang diberikan sama. Pada Gambar 2 kita akan melihat bahwa debit dengan kejadian terbanyak terjadi pada rentang 800-900 cfs, sedangkan pada Gambar 3 kita melihat bahwa debit dengan kejadian terbanyak terjadi pada 800-1200 cfs.\n# memuat library\rlibrary(readxl)\r## Warning: package \u0026#39;readxl\u0026#39; was built under R version 3.5.3\rlibrary(ggplot2)\rlibrary(ggthemes)\r## Warning: package \u0026#39;ggthemes\u0026#39; was built under R version 3.5.3\r# memuat data excel\rsungai \u0026lt;- read_excel(\u0026quot;hhappc.xls\u0026quot;, sheet=\u0026quot;appc1\u0026quot;)\r\rFigure 2: Histogram dengan bin.width=default debit sungai Saddle\r\r\rFigure 3: Histogram dengan bin.width=500 debit sungai Saddle\r\r\r7.1.2 Density Plot\rDensity plot memecahkan masalah yang dimiliki histogram dalam melihat grafik dengan menyajikan data bukan dari jumlah kejadian atau observasi, namun data disajikan berdasarkan frekuensi relatif data (density) yang digambarkan dalam bentuk smooth curve. Contoh density plot dapat dilijat pada Gambar 4. Dari grafik yang dihasilkan sekaran tampak jelas bahwa distibusi data memiliki kemencengan positif dengan frekuensi relatif debit terbanyak berada pada debit 1000 cfs.\n\rFigure 4: Density plot debit sungai Saddle\r\r\r7.1.3 QQ-plot\rKita telah mempelajari sebelumnya pada Chapter 5 bahwa QQ-plot data digunakan untuk mengecek apakah data yang kita miliki berdistribusi normal atau tidak. Contoh QQ-plot dapat dilijat pada Gambar 5. Pada grafik yang dihasilkan terlihat bahwa data tidak berdistribusi normal. Hal ini terlihat dari sebagian observasi pada debit \u0026lt;1000 cfs yang tidak mengikuti garis referensi.\nggplot(sungai, aes(sample=Flow))+\r# qq plot\rstat_qq()+\r# garis referensi\rstat_qq_line()+\rtheme_economist()\r\rFigure 5: QQ plot debit sungai Saddle\r\r\r7.1.4 Box Plot dan Violin Plot\rGrafik lain yang dapat digunakan untuk menggambarkan distribusi data adalah box plot dan violin plot. Box plot memberikan cara yang simpel untuk melihat ditribusi data seperti melihat posisi sejumlah kuartil, nilai minimum dan maksimum. Selain itu kita juga dapat melihat adanya outlier pada data.\nKita dapat menambah fungsionalitas dari box plot ini dengan menambahkan violin plot. Pada Chapter 5 kita telah belajar bahwa kita dapat menambahkan box plot pada violin plot atau sebaliknya sehingga memudahkan dalam mendeskripsikan bentuk distribusi data. Jika dengan box plot kita tidak dapat melihat secara baik bentuk dari data yang sesungguhnya karena hanya menampilkan lokasi sejumlah kuartil. Pada violin plot kita dapat melihat bentuk data yang ada melalui tampilan dua denisty plot (tampak seperti biola) yang digambarkan. Kekurangannya adalah kita tidak dapat melihat observasi mana yang menjadi outlier, sehingga kedua grafik ini biasa digambarkan secara bersamaan. Berikut adalah contoh box plot dan violin plot dari data debit sungai Saddle (Gambar 6).\nggplot(sungai, aes(x=\u0026quot;\u0026quot;, y=Flow))+\rgeom_violin(fill=\u0026quot;blue\u0026quot;, alpha=0.5, color=\u0026quot;white\u0026quot;)+\rgeom_boxplot(width=0.1)+\rtheme_economist()\r\rFigure 6: Box plot dan violin plot debit sungai Saddle\r\rBerdasarkan grafik yang dihasilkan pada Gambar 6 kita dapat melihat bahwa ditribusi data debit sungai memiliki kemencengan positif. Hal ini terjadi karena terdapat satu outlier pada data yang disebabkan karena nilai observasinya diluar dari nilai maksimum data yang ditetapkan sebagai \\(max=Q3 + 1,5*IQR\\).\n\r\r7.2 Grafik Untuk Melihat Beda Distribusi Data Antar Grup\rGrafik yang telah dijelaskan sebelumnya seperti box plot, violin plot, histogram, dan density plot merupakan grafik yang bagus untuk memvisualisasikan beda distribusi data antar grup untuk data numerik. Untuk data berupa kategori kita dapat menggunakan bar plot. Pada penerapannya bar plot juga dapat memvisualisasikan ringkasan data seperti nilai mean dan sebarannya pada data.\nPada contoh ini penulis hanya akan memberikan contoh penerapan menggunakan box plot dan bar plot menggunakan data konsentrasi Antrazine yang diukur pada bulan Juni dan September. Untuk melakukannya kita perlu memuat data dan melakukan transformasi terhadap datanya terlebih dahulu.\n# memuat data excel\ratrazine \u0026lt;- read_excel(\u0026quot;hhappc.xls\u0026quot;, sheet=\u0026quot;appc4\u0026quot;)\r# print\rhead(atrazine)\r## # A tibble: 6 x 2\r## June_atrazine Sept_atrazine\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 0.38 2.66 ## 2 0.04 0.63 ## 3 -0.01 0.59 ## 4 0.03 0.05 ## 5 0.03 0.84 ## 6 0.05 0.580\r# transformasi data\rlibrary(tidyr)\r## Warning: package \u0026#39;tidyr\u0026#39; was built under R version 3.5.3\ratrazine \u0026lt;- gather(atrazine,\rkey=\u0026quot;month\u0026quot;,\rvalue=\u0026quot;concentration\u0026quot;)\r# print\rhead(atrazine)\r## # A tibble: 6 x 2\r## month concentration\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 June_atrazine 0.38\r## 2 June_atrazine 0.04\r## 3 June_atrazine -0.01\r## 4 June_atrazine 0.03\r## 5 June_atrazine 0.03\r## 6 June_atrazine 0.05\rPada data konsentrasi Atrazine tersebut terdapat nilai negatif yang dalam hal ini merupakan kesalahan dalam pengukuran dari alat. Untuk membersihkannya kita dapat membuat nilai observasi tersebut menjadi NA.\natrazine$concentration[atrazine$concentration\u0026lt;0]\u0026lt;-NA\rhead(atrazine)\r## # A tibble: 6 x 2\r## month concentration\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 June_atrazine 0.38\r## 2 June_atrazine 0.04\r## 3 June_atrazine NA ## 4 June_atrazine 0.03\r## 5 June_atrazine 0.03\r## 6 June_atrazine 0.05\rSelanjutnya kita akan memvisualisasikan beda antara distribusi data pada kedua bulan menggunakan box plot (Gambar 7). Konsentrasi rata-rata Atrazine akan divisualisasikan menggunakan bar plot (Gambar 8).\nggplot(atrazine, aes(month, concentration, fill=month))+\rgeom_boxplot()+\rtheme_economist()+\rscale_fill_economist()\r\rFigure 7: Box plot konsentrasi Atrazine pada bulan Juni dan September\r\rlibrary(dplyr)\ratrazine %\u0026gt;%\rgroup_by(month) %\u0026gt;%\rsummarize(mean_atrazine=mean(concentration, na.rm=TRUE)) %\u0026gt;%\rggplot(aes(month, mean_atrazine, fill=month))+\rgeom_bar(stat=\u0026quot;identity\u0026quot;)+\rtheme_economist()+\rscale_fill_economist()\r\rFigure 8: Bar plot konsentrasi Atrazine pada bulan Juni dan September\r\rPada visualisasi yang dihasilkan terdapat perbedaan signifikan antara distribusi dan nilai rata-rata konsentrasi Atrazine pada dua periode tersebut. Hal ini disebabkan karena terdapat sebuah outlier pada periode Sepetember yang menyebabkan nilai rata-rata yang dihasilkan bergeser jauh kearah outlier. Pembaca dapat membuat visualisasi data pada data tersebut tanpa outlier dengan terlebih dahulu melakukan filter terhadap outlier.\n\r7.3 Grafik Untuk Memvisualisasikan Korelasi Antar Variabel\rScatterplot dapat digunakan untuk memvisualisasikan korelasi antar dua variabel. Pada bagian ini akan diberikan contoh visualisasi antara variabel konsentrasi TDS dan Uranium pada air tanah.\nUntuk melakukannya kita perlu memuat terlebih dahulu dataset yang digunakan. Visualisasi data disajikan pada Gambar 9.\n# memuat data excel\rgw \u0026lt;- read_excel(\u0026quot;hhappc.xls\u0026quot;, sheet=\u0026quot;appc16\u0026quot;)\rggplot(gw, aes(TDS, Uranium))+\rgeom_point()+\rgeom_smooth(method=\u0026quot;lm\u0026quot;)+\rtheme_economist()\r\rFigure 9: Scatterplot hubungan antara konsentrasi TDS dan Uranium pada airtanah\r\rBerdasarkan grafik yang dihasilkan terdapat hubungan linier antara konsentrasi TDS dan Uranium pada airtanah. Meningkatnya konsentrasi TDS pada air tanah juga menyebabkan peningkatan konsentrasi Uranium pada airtanah.\n\r7.4 Grafik Yang Digunakan Untuk Memvisualisasikan Asosiasi Antar Variabel\rAsosiasi antar variabel kategori dapat dilakukan baik dengan pie chart maupun dengan bar plot. Pie chart kurang sering digunakan untuk visualisasi multiple group sehingga bar plot lebih sering digunakan.\nPada contoh kali ini penulis akan melihat terdapat asoiasi antara musim dan strata terhadap jumlah Corbicula di sungai Tennessee. Untuk melakukannya kita perlu memuat terlebih dahulu dataset yang digunakan. Visualisasi data disajikan pada Gambar 10.\n# memuat data excel\rcorbicula\u0026lt;- read_excel(\u0026quot;hhappc.xls\u0026quot;, sheet=\u0026quot;appc8\u0026quot;)\r# print\rhead(corbicula)\r## # A tibble: 6 x 4\r## Year Season Strata Corbicula\r## \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1969 Winter 1 25\r## 2 1969 Winter 1 20\r## 3 1969 Winter 1 30\r## 4 1969 Spring 1 9\r## 5 1969 Spring 1 8\r## 6 1969 Spring 1 9\rcorbicula %\u0026gt;%\rmutate(Season=as.factor(Season),\rStrata=as.factor(Strata)) %\u0026gt;%\rgroup_by(Season,Strata) %\u0026gt;%\rsummarize(Corbicula=mean(Corbicula)) %\u0026gt;%\rggplot(aes(Season, Corbicula, fill=Strata))+\rgeom_bar(stat=\u0026quot;identity\u0026quot;,position=position_dodge2())+\rtheme_economist()+\rscale_fill_economist()\r\rFigure 10: Bar plot Jumlah rata-rata corbicula pada sungai Tennessee\r\rBerdasarkan grafik yang dihasilkan terdapat pengaruh musim dan strata terhadap jumlah corbicula di sungai Tennessee. Jumlah tertinggi berada saat musim semi pada strata 3, sedangkan terendah berada pada musim dingin juga pada strata 3.\n\r7.5 Grafik Yang Digunakan Untuk Memisualisasikan Ukuran Sampel dan Perubahan Sepanjang Waktu\rUntuk memvisualisasikan perubahan sepanjang waktu, kita dapat menggunakan line plot. Pada data corbicula kita ingin memvisualisasikan perubahan jumlah corbicula rata-rata pada setiap tahun. Visualisasi dari data disajikan pada Gambar 11.\ncorbicula %\u0026gt;%\rgroup_by(Year) %\u0026gt;%\rsummarize(Corbicula=mean(Corbicula)) %\u0026gt;%\rggplot(aes(Year, Corbicula))+\rgeom_line()+\rgeom_point(shape=1)+\rtheme_economist()\r\rFigure 11: Line plot perubahan jumlah rata-rata corbicula di sungai Tennessee\r\rBerdasarkan garfik yang dihasilkan dapat disimpulkan bahwa jumlah rata-rata corbicula menurun setiap tahunnya.\nReferensi\nGardener, M. 2012. Statistics for Ecologists Using R and Excel-Data collection, exploration, analysis and presentation. Pelagic Publishing.\rHelsel, D.R., Hirsch, R.M. 2002. statistical Methods in Water Resources. USGS.\rOfungwu, J. 2014. Statistical Applications For Environmental Analysis and Risk Assessment. John Wiley \u0026amp; Sons, Inc.\rPeck, R.Devore, J.L. 2012. Statistics The Exploration \u0026amp; Analysis of Data- Seventh Edition. Brooks/Cole.\r\r\r","date":1553446800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1553446800,"objectID":"e3d135708f1087be5026b264083ace0c","permalink":"/tutorial/07_eksplorasi-data-menggunakan-grafik/","publishdate":"2019-03-25T00:00:00+07:00","relpermalink":"/tutorial/07_eksplorasi-data-menggunakan-grafik/","section":"tutorial","summary":"body{\rtext-align: justify}\r\r\rDaftar Isi\n\rGrafik Untuk Melihat Ditribusi Data\rGrafik Untuk Melihat Beda Distribusi Data Antar Grup\rGrafik Untuk Memvisualisasikan Korelasi Antar Variabel\rGrafik Yang Digunakan Untuk Memvisualisasikan Asosiasi Antar Variabel\rGrafik Yang Digunakan Untuk Memisualisasikan Ukuran Sampel dan Perubahan Sepanjang Waktu\r\r\rPada Chapter 4 dan 5 kita telah belajar bagaimana cara membuat grafik menggunakan R. Sejauh ini kita belum belajar kegunaan dari masing-masing grafik yang telah kita pelajarai.","tags":null,"title":"7. Ekplorasi Data Menggunakan Grafik","type":"docs"},{"authors":null,"categories":null,"content":"\r\rbody{\rtext-align: justify}\r\r\rDaftar Isi\n\rScatterplot\rBox Plot dan Violin Plot\rBar Plot\rLine Plot\rPie Chart\rHistogram dan Density Plot\rQQ Plot\rDot Chart\rECDF Plot\rParameter Grafik\r\r\rLibrary ggplot2 merupakan implementasi dari The Grammar of Graphics yang ditulis oleh Leland Wilkinson. ggplot2 merupakan library yang dikembangkan oleh Hadley Wicham ketika ia sedang menempuh kuliah di Lowa State Universuty dan masih dikembangkan hingga sekarang.\nggplot2 merupakan paket visualisasi yang powerfull. Kita dapat menggunakannya bersamaan dengan piping operator yang disediakan oleh paket dplyr sehingga menambah kemudahan kita dalam melakukan analisis data.\nGrafik ggplot2 terdiri dari sejumlah komponen kunci. Berikut adalah sejumlah komponen kunci yang membentuk grafik ggplot2.\n\rdata frame: menyimpan semua data yang akan ditampilkan di plot.\raesthetic mapping: menggambarkan bagaimana data dipetakan ke warna, ukuran, bentuk, lokasi. Dalam plot diberikan pada fungsi aes()\rgeoms: objek geometris seperti titik, garis, bentuk.\rfacets: menjelaskan bagaimana plot bersyarat / panel harus dibangun.\rstats: transformasi statistik seperti binning, quantiles, smoothing.\rscales: skala apa yang digunakan oleh aesthetic map (contoh: pria = merah, wanita = biru).\rcoordinate system: menggambarkan sistem di mana lokasi geom akan digambarkan.\r\rSebelum kita mulai memcoba melakukan visualisasi data menggunakan ggplot2, kita perlu menginstall dan memuat terlebih dahulu library ggplot2. Berikut adalah sintaks yang digunakan untuk menginstall dan memuat paket ggplot2:\n# memasang paket\r# install.packages(\u0026#39;ggplot2\u0026#39;)\r# memuat paket\rlibrary(ggplot2)\rDataset yang akan kita gunakan adalah dataset gapminder. Dataset ini berisi data demografi penduduk dari berbagai negara dan benua. Untuk dapat menggunakannya kita perlu menginstall dan memuatnya terlebih dahulu. Berikut adalah sintaks untuk menginstall dan memuat dataset tersebut:\n# memasang paket\r# install.packages(\u0026quot;gapminder\u0026quot;)\r# memuat paket\rlibrary(gapminder)\r## Warning: package \u0026#39;gapminder\u0026#39; was built under R version 3.5.3\r# memuat paket dplyr dan tibble\rlibrary(dplyr)\rlibrary(tibble)\r## Warning: package \u0026#39;tibble\u0026#39; was built under R version 3.5.3\r# melihat struktur dataset\rglimpse(gapminder)\r## Observations: 1,704\r## Variables: 6\r## $ country \u0026lt;fct\u0026gt; Afghanistan, Afghanistan, Afghanistan, Afghanistan, ...\r## $ continent \u0026lt;fct\u0026gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia...\r## $ year \u0026lt;int\u0026gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992...\r## $ lifeExp \u0026lt;dbl\u0026gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.8...\r## $ pop \u0026lt;int\u0026gt; 8425333, 9240934, 10267083, 11537966, 13079460, 1488...\r## $ gdpPercap \u0026lt;dbl\u0026gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 78...\r# melihat variabel year\runique(gapminder$year)\r## [1] 1952 1957 1962 1967 1972 1977 1982 1987 1992 1997 2002 2007\rDataset gapminder memiliki 6 variabel dan 1704 observasi. 20 observasi pertama dataset gapminder dapat dilihat pada Tabel 1\n\rTable 1: 20 observasi pertama dataset gapminder\r\rcountry\rcontinent\ryear\rlifeExp\rpop\rgdpPercap\r\r\r\rAfghanistan\rAsia\r1952\r28.801\r8425333\r779.4453\r\rAfghanistan\rAsia\r1957\r30.332\r9240934\r820.8530\r\rAfghanistan\rAsia\r1962\r31.997\r10267083\r853.1007\r\rAfghanistan\rAsia\r1967\r34.020\r11537966\r836.1971\r\rAfghanistan\rAsia\r1972\r36.088\r13079460\r739.9811\r\rAfghanistan\rAsia\r1977\r38.438\r14880372\r786.1134\r\rAfghanistan\rAsia\r1982\r39.854\r12881816\r978.0114\r\rAfghanistan\rAsia\r1987\r40.822\r13867957\r852.3959\r\rAfghanistan\rAsia\r1992\r41.674\r16317921\r649.3414\r\rAfghanistan\rAsia\r1997\r41.763\r22227415\r635.3414\r\rAfghanistan\rAsia\r2002\r42.129\r25268405\r726.7341\r\rAfghanistan\rAsia\r2007\r43.828\r31889923\r974.5803\r\rAlbania\rEurope\r1952\r55.230\r1282697\r1601.0561\r\rAlbania\rEurope\r1957\r59.280\r1476505\r1942.2842\r\rAlbania\rEurope\r1962\r64.820\r1728137\r2312.8890\r\rAlbania\rEurope\r1967\r66.220\r1984060\r2760.1969\r\rAlbania\rEurope\r1972\r67.690\r2263554\r3313.4222\r\rAlbania\rEurope\r1977\r68.930\r2509048\r3533.0039\r\rAlbania\rEurope\r1982\r70.420\r2780097\r3630.8807\r\rAlbania\rEurope\r1987\r72.000\r3075321\r3738.9327\r\r\r\r5.1 Scatterplot\rScatterplot dapat dibuat pada ggplot2 menggunakan fungsi geom_point(). Format sederhananya dituliskan sebagai berikut:\nggplot(data, aes(...))+\rgeom_point(size, color, shape)\rBerikut adalah contoh sederhana scatterplot variabel lifeExp terhadap variabel gdpPercap. Output yang dihasilkan disajikan pada Gambar 1:\nggplot(gapminder, aes(gdpPercap, lifeExp))+\rgeom_point()\r\rFigure 1: Scatterplot lifeExp vs gdpPercap\r\rKita dapat mengubah warna, jenis, dan ukuran titik pada scatterplot. Pengubahan warna dan jenis titik berguna untuk menunjukkan grup data pada grafik. Sedangkan perubahan ukuran titik sangat berguna untuk menunjukkan nilai variabel lain khususnya variabel kontinyu pada sebuah titik. Berikut adalah contoh penerapannya. Output yang dihasilkan disajikan pada Gambar 2 sampai dengan Gambar 4:\nggplot(gapminder, aes(gdpPercap,lifeExp, color=continent))+\rgeom_point()+\r# merubah sumbu x kedalam fungsi log\rscale_x_log10()\r\rFigure 2: Scatterplot lifeExp vs gdpPercap tiap benua (1)\r\rggplot(gapminder, aes(gdpPercap,lifeExp, shape=continent))+\rgeom_point()+\r# merubah sumbu x kedalam fungsi log\rscale_x_log10()\r\rFigure 3: Scatterplot lifeExp vs gdpPercap tiap benua (2)\r\rggplot(gapminder, aes(gdpPercap,lifeExp, size=pop, color=continent))+\rgeom_point()+\r# merubah sumbu x kedalam fungsi log\rscale_x_log10()\r\rFigure 4: Scatterplot lifeExp vs gdpPercap dan populasi tiap negara dan benua\r\rUntuk menujukkan asosiasi antara dua variabel kontinyu kita juga dapat menambahkan garis regresi dan confidence interval garis regresinya. Fungsi yang digunakan adalah geom_smooth(). Secara default fungsi tersebut akan membuat garis loess regression pada grafik. Agar dapat membuat garis regresi linier kita perlu menambahkan argumen method=\u0026quot;lm\u0026quot;. Selain itu, jika kita tidak ingin menampilkan garis confidence interval kita dapat menambahkan argumen se=FALSE. Format sederhananya disajikan pada sintaks berikut:\ngeom_smooth(method=\u0026quot;auto\u0026quot;, se=TRUE, fullrange=FALSE, level=0.95)\r\rNote: \n\rmethod: metode penghalusan yang digunakan. Nilai yang dapat dimasukkan adalah lm, glm, gam, loess, rlm.\n\rmethod=“loess”: merupakan nilai default pada fungsi dan menghasilkan metode penghalusan loess regression.\rmethod=“lm”: menghasilkan metode penghalusan regresi linier. Kita juga dapat melakukan spesifikasi terhadap fungsi persamaan regresi yang digunakan dengan menambahkan argumen formula=y~x….\n\rse: nilai logis. Jika TRUE garis confidence interval akan ditampilkan sepanjang garis penghalusan.\rfullrange: nilai logis. Jika TRUE kecocokan mencakup seluruh plot.\rlevel: level confidence interal yang digunakan. Secara default bernilai 0.95.\n\r\r\rBerikut adalah contoh sintaks penerapan pada variabel gdpPercap dan lifeExp. Output yang dihasilkan disajikan pada Gambar 5:\nggplot(gapminder, aes(gdpPercap,lifeExp))+\rgeom_point()+\r# merubah sumbu x kedalam fungsi log\rscale_x_log10()+\r# menambahkan smoothing method\rgeom_smooth(method=\u0026quot;lm\u0026quot;, level=0.99)\r\rFigure 5: Scatterplot lifeExp vs gdpPercap dengan garis penghalusan regresi linier\r\r\r5.2 Box Plot dan Violin Plot\rBox plot merupakan visualisasi yang powerful dalam menggambarkan distribusi data, melihat adanya outlier, serta membandingkan distribusi antar data. Format visualisasi dapat dituliskan sebagai berikut:\nggplot(data, aes(...))+\rgeom_boxplot(geom_boxplot(outlier.colour=\u0026quot;black\u0026quot;, outlier.shape=16,\routlier.size=2, notch=FALSE))\r\rNote: \n\routlier.colour, outlier.shape, outlier.size: Warna, bentuk dan ukuran untuk titik-titik outlier.\rnotch: nilai logis. Jika TRUE, buat notched box plot. Notch menunjukkan confidence interval di sekitar median yang biasanya didasarkan pada median \\(\\pm1,58\\cdot\\frac{\\left(IQR\\right)}{\\sqrt{\\left(n\\right)}}\\). Notch digunakan untuk membandingkan kelompok; jika takik dua kotak tidak tumpang tindih, ini adalah bukti kuat bahwa median berbeda.\r\r\rBerikut merupakan contoh visualisasi variabel lifeExp pada dataset gapminder. Output yang dihasilkan disajikan pada Gambar 6:\nggplot(gapminder, aes(\u0026quot;\u0026quot;, lifeExp))+\rgeom_boxplot()\r\rFigure 6: Box plot variabel lifeExp\r\rKita dapat melakukan visualisasi bagi setiap kelompok data. Pada sintaks berikut visualisasi dilakukan untuk variabel lifeExp pada tiap continent. Pada contoh berikut akan ditampilkan cara menmabahkan titik rata-rata dan warna pada masing-masing grup. Output yang dihasilkan disajikan pada Gambar 7:\nggplot(gapminder, aes(continent, lifeExp, color=continent))+\rgeom_boxplot()+\rstat_summary(fun.y=mean, geom=\u0026quot;point\u0026quot;, shape=23, size=3, color=\u0026quot;red\u0026quot;)\r\rFigure 7: Box plot variabel lifeExp pada tiap continent\r\rMisalkan kita ingin mengetahui perubahan distribusi dari variabel lifeExp pada masing-masing continet pada tahun 1952 dan 2007. Untuk melakukannya kita perlu melakukan subset pada dataset gapminder untuk memfilter data pada tahun 1952 dan 2007. Data selanjutnya dilakukan input kedalam fungsi ggplot(). Berikut adalah contoh sintaks yang digunakan. Output yang dihasilkan disajikan pada Gambar 8:\ngapminder %\u0026gt;%\rfilter(year==1952 | year==2007) %\u0026gt;%\rggplot(aes(continent, lifeExp, fill=factor(year)))+\rgeom_boxplot(notch=TRUE)\r\rFigure 8: Box plot variabel lifeExp pada tiap continent (1952 dan 2007)\r\rBerdasarkan Gambar 8 terlihat bahwa usia harapan hidup pada tiap benua meningkat sejak tahun 1952 sampai 2007. Selain itu, peningkatan tersebut bersifat signifikan yang ditunjukkan dari tidak adanya notch yang saling overlap pada masing-masing benua.\nUntuk lebih detailnya kita akan coba melakukan visualisasi pada benua Asia untuk melihat perubahan variabel lifeExp. Berikut adalah sintaks yang digunakan dan output yang dihasilkan disajikan pada Gambar 9:\ngapminder %\u0026gt;%\rfilter(continent==\u0026quot;Asia\u0026quot;) %\u0026gt;%\rggplot(aes(factor(year), lifeExp))+\rgeom_boxplot()\r\rFigure 9: Box plot variabel lifeExp Benua Asia\r\rViolin plot memiliki kesamaan dengan box plot. Perbedaanya terletak pada violin plot tidak hanya menyajikan data titik-titikkuartil data, namun violin plot juga menampilkan kernel probabilitas distibusi data. Fungsi yang digunakan untuk membuatnya adalah geom_violin().\nPada dataset gapminder kita ingin meisualisasikan distribusi lifeExp pada masing-masing continent. Berikut adalah contoh sintaks untuk membuat visualisasi dasar violin plot. Output yang dihasilkan disajikan pada Gambar 10:\ngapminder %\u0026gt;%\rggplot(aes(continent, lifeExp, fill=continent))+\r# violin plot\rgeom_violin()\r\rFigure 10: Violin plot variabel lifeExp pada masing-masing benua\r\rKita juga dapat melakukan modifikasi terhadap violin plot tersebut seperti penambahan titik kuartil, titik mean dan modifikasi terhadap warna tampilaknnya. COntoh sintaksnya dan output disajikan pada Gambar 11:\ngapminder %\u0026gt;%\rggplot(aes(continent, lifeExp, fill=continent))+\r# violin plot\rgeom_violin()+\r# menambahkan boxplot dengan lebar 0.1\rgeom_boxplot(width=0.1, fill=\u0026quot;white\u0026quot;)+\r# menambahkan titik mean\rstat_summary(fun.y=mean, geom=\u0026quot;point\u0026quot;,\r# ukuran dan jenis titik\rsize=1, shape=23,\r# warna titik\rcolor=\u0026quot;red\u0026quot;, fill=\u0026quot;white\u0026quot;)\r\rFigure 11: Violin plot variabel lifeExp pada masing-masing benua (2)\r\r\r5.3 Bar Plot\rPada ggplot2 bar plot dapat dibuat menggunakan fungsi geom_bar(). Untuk membuat bar plot, langkah pertama yang perlu dilakukan adalah membuat tabulasi data variabel terlebih dahulu. Berikut adalah contoh sintaks untuk membuat bar plot dari rata-rata lifeExp pada masing-masing continent. Output yang dihasilkan disajikan pada Gambar 12:\ngapminder %\u0026gt;%\r# kelompokkan berdasarkan continet\rgroup_by(continent)%\u0026gt;%\r# membuat ringkasan data\rsummarize(mean_lifeExp=mean(lifeExp))%\u0026gt;%\r# urutkan dari yang terbesar\rarrange(desc(mean_lifeExp))%\u0026gt;%\r# plot\rggplot(aes(continent, mean_lifeExp))+\r# membuat bar plot berdasarkan nilai observasi\rgeom_bar(stat=\u0026quot;identity\u0026quot;)\r\rFigure 12: Bar plot rata-rata lifeExp masing-masing benua\r\rKita juga dapat membuat bar plot dengan garis confidence interval. Untuk melakukannya kita perlu terlebih dahulu menghitung standard error dari data. Standard error selanjutnya digunakan untuk menghitung nilai atas dan bawah dari nilai rata-rata. Berikut adalah contoh visualisasi bar plot dengan confidence interval (Gambar 13):\ngapminder %\u0026gt;%\r# kelompokkan berdasarkan continet\rgroup_by(continent)%\u0026gt;%\r# membuat ringkasan data\rsummarize(mean_lifeExp=mean(lifeExp),\rn=n(), sd=sd(lifeExp), se=sd/sqrt(n))%\u0026gt;%\r# plot\rggplot(aes(continent, mean_lifeExp))+\r# membuat bar plot\rgeom_bar(stat=\u0026quot;identity\u0026quot;, color=\u0026quot;white\u0026quot;)+\r# menambahkan error bar\rgeom_errorbar(aes(ymin=mean_lifeExp-se,\rymax=mean_lifeExp+se),\rwidth=0.2)\r\rFigure 13: Bar plot rata-rata lifeExp masing-masing benua dengan confidence interval\r\rKita juga dapat melakukannya pada visualisasi data beberapa grup. Berikut adalah contoh sintaks dan output (Gambar 14) bar plot dengan beberapa grup:\ngapminder %\u0026gt;%\r# filter data tahun 1952 dan 2007\rfilter(year==1952|year==2007)%\u0026gt;%\r# Ubah year menjadi factor\rmutate(year=as.factor(year))%\u0026gt;%\r# kelompokkan berdasarkan continet\rgroup_by(continent,year)%\u0026gt;%\r# membuat ringkasan data\rsummarize(mean_lifeExp=mean(lifeExp),\rn=n(), sd=sd(lifeExp), se=sd/sqrt(n))%\u0026gt;%\r# plot\rggplot(aes(continent, mean_lifeExp, fill=year))+\r# membuat bar plot\rgeom_bar(stat=\u0026quot;identity\u0026quot;, position=position_dodge())+\r# menambahkan error bar\rgeom_errorbar(aes(ymin=mean_lifeExp-se,\rymax=mean_lifeExp+se),\rwidth=0.2,\rposition=position_dodge(0.9))\r\rFigure 14: Bar plot rata-rata lifeExp masing-masing benua (1952 dan 2007) dengan confidence interval\r\r\r5.4 Line Plot\rLine plot dapat digunakan untuk menunjukkan adanya perubahan pada selang waktu tertentu. Pada ggplot2, line plot dapat dibuat menggunakan fungsi geom_line(). Berikut adalah contoh sintaks dan grafik (Gambar 15) untuk membuat line plot:\ngapminder%\u0026gt;%\r# kelompokkan data berdasarkan year dan continent\rgroup_by(year,continent)%\u0026gt;%\r# ringkasan data\rsummarize(mean_lifeExp=mean(lifeExp))%\u0026gt;%\r# plot\rggplot(aes(year, mean_lifeExp, linetype=continent))+\r# membuat line plot\rgeom_line()+\r# menambahkan point\rgeom_point()\r\rFigure 15: Line plot lifeExp masing-masing benua\r\rKita juga dapat menambahkan error bar pada line plot. Berikut adalah contoh sintak dan grafik (Gambar 16) yang dihasilkan:\ngapminder%\u0026gt;%\r# filter benua asia\rfilter(continent==\u0026quot;Asia\u0026quot;)%\u0026gt;%\r# kelompokkan data berdasarkan year dan continent\rgroup_by(year)%\u0026gt;%\r# ringkasan data\rsummarize(mean_lifeExp=mean(lifeExp), sd=sd(lifeExp))%\u0026gt;%\r# plot\rggplot(aes(year, mean_lifeExp))+\r# membuat line plot\rgeom_line()+\r# menambahkan point\rgeom_point(size=2)+\r# menambahkan error bar\rgeom_errorbar(aes(ymin=mean_lifeExp-sd,\rymax=mean_lifeExp+sd),\rwidth=0.2, color=\u0026quot;red\u0026quot;)\r\rFigure 16: Histogram lifeExp\r\r\r5.5 Pie Chart\rPie chart pada ggplot2 dapat dibuat menggunakan fungsi geom_bar() dan coord_polar().Berikut adalah contoh sintaks yang digunakan dan output (Gambar 17) yang dihasilkan:\ntotal \u0026lt;- sum(gapminder$pop)\rgapminder%\u0026gt;%\r# kelompokkan berdasarkan continent\rgroup_by(continent)%\u0026gt;%\r# ringkasan data summarize(pop=sum(as.numeric(pop)), percent=(pop/total)*100)%\u0026gt;%\rggplot(aes(x=\u0026quot;\u0026quot;, percent, fill=continent))+\rgeom_bar(stat=\u0026quot;identity\u0026quot;)+\rcoord_polar(\u0026quot;y\u0026quot;, start=0)\r\rFigure 17: Pie chart pop\r\r\r5.6 Histogram dan Desity Plot\rHistogram pada ggplot2 dapat dibuat dengan fungsi geom_histogram(). Berikut adalah sintaks untuk membuat hitogram pada variabel lifeExp. Output yang dihasilkan disajikan pada Gambar 18:\ngapminder %\u0026gt;%\rggplot(aes(lifeExp))+\rgeom_histogram()\r\rFigure 18: Histogram lifeExp\r\rKita dapat membuat grafik histogram berdasarkan grup data. Pada contoh sebelumnya dibuat histogram berdasarkan variabel continent. Berikut adalah sintaks dan output yang dihasilkan pada Gambar 19:\ngapminder %\u0026gt;%\rggplot(aes(lifeExp, fill=continent))+\rgeom_histogram(alpha=0.5, # atur posisi agar sesuai grup\rposition=\u0026quot;identity\u0026quot;,\rcolor=\u0026quot;black\u0026quot;)\r\rFigure 19: Histogram lifeExp berdasarkan benua\r\rDensity plot dapat dibuat dengan menggunakan fungsi geom_density(). Berikut adalah contoh sintaks untuk membuat density plot variabel lifeExp. Output yang dihasilkan disajikan pada Gambar 20:\ngapminder %\u0026gt;%\rggplot(aes(lifeExp))+\rgeom_density()\r\rFigure 20: Density plot lifeExp\r\rKita juga dapat membuat grafik density berdasarkan grup data. Pada contoh sebelumnya dibuat density plot berdasarkan variabel continent. Berikut adalah sintaks dan output yang dihasilkan pada Gambar 21:\ngapminder %\u0026gt;%\rggplot(aes(lifeExp, fill=continent))+\rgeom_density(alpha=0.5, # atur posisi agar sesuai grup\rposition=\u0026quot;identity\u0026quot;,\rcolor=\u0026quot;black\u0026quot;)\r\rFigure 21: Density plot lifeExp berdasarkan benua\r\rJika dinginkan kita juga dapat menambahkan density plot pada histogram. Pada Gambar 18 ditambahkan density plot sehingga dihasilkan output seperti Gambar 22.\ngapminder %\u0026gt;%\rggplot(aes(lifeExp))+\rgeom_histogram(aes(y=..density..),\r# spesifikasi warna bar\rcolor=\u0026quot;black\u0026quot;, fill=\u0026quot;white\u0026quot;)+\rgeom_density(fill=\u0026quot;red\u0026quot;, alpha=0.3)\r\rFigure 22: histogram dan density plot lifeExp\r\r\r5.7 QQ Plot\rQQ plot pada paket ggplot2 dapat dibuat dengan menggunakan fungsi stat_qq(). Berikut adalah contoh sintaks untuk melakukannya. Output yang dihasilkan disajikna pada Gambar 23.\nggplot(gapminder, aes(sample=lifeExp))+\r# qq plot\rstat_qq()+\r# garis referensi\rstat_qq_line()\r\rFigure 23: QQ plot variabel lifeExp\r\r\r5.8 Dot Plot\rDot plot dapat dibuat menggunakan fungsi geom_dotplot atau geom_jitter(). Perbedaan keduanya adalah geom_jitter() menambahkan noise pada plot sehingga mencegah terjadinya overplotting. Berikut adalah contoh sintaks untuk membuat dotplot pada multiple group dan output yang dihasilkan pada Gambar 24:\ngapminder %\u0026gt;%\rfilter(year==1952 | year==2007) %\u0026gt;%\rggplot(aes(continent, lifeExp, fill=factor(year)))+\rgeom_dotplot(binaxis=\u0026quot;y\u0026quot;, # spesifikasi posisi plot\rstackdir=\u0026quot;center\u0026quot;,\rposition=position_dodge(0.8),\rsize=0.1)\r## Warning: Ignoring unknown parameters: size\r\rFigure 24: Dot plot variabel lifeExp masing-masing benua (1952-2007)\r\rKita juga dapat menambahkan plot dari dari plot yang sudah ada seperti box plot atau violin plot. Berikut adalah contoh sintaks dan output yang dihasilkan pada Gambar 25:\ngapminder %\u0026gt;%\rfilter(year==1952 | year==2007) %\u0026gt;%\rggplot(aes(continent, lifeExp, fill=factor(year)))+\r# box plot dibawah\rgeom_boxplot(position=position_dodge(0.8))+\r# dot plot diatas\rgeom_dotplot(binaxis=\u0026quot;y\u0026quot;, # spesifikasi posisi plot\rstackdir=\u0026quot;center\u0026quot;,\rposition=position_dodge(0.8))\r\rFigure 25: Dot plot variabel lifeExp masing-masing benua (1952-2007) (2)\r\r\r5.9 ECDF Plot\rEmpirical Cumulative Density FUnction (ECDF) plot merupakan grafik yang digunakan untuk menggambarkan ditribusi suatu data. Dari grafik ini kita dapat mengetahui faraksi suatu data baik yang terendah maupun yang tertinggi. ECDF pada ggplot2 dapat dibuat dengan dua cara yaitu dengan geom_line() dan stat_ecdf(). Jika menggunakan fungsi geom_line() kita perlu membuat fraksi kumulatif dari variabel yang akan kita plotkan. Sedangkan dengan menggunakan stat_ecdf(), kita tidak perlu melakukannya karena fungsi tersebut akan secara otomatis memproses data kita. Berikut adalah sintaks dan output (Gambar 26) contoh ecdf:\nggplot(gapminder, aes(lifeExp))+\rstat_ecdf(geom=\u0026quot;line\u0026quot;)\r\rFigure 26: ECDF plot variabel lifeExp\r\r\r5.10 Parameter Grafik\rPada bagian ini penulis akan menjelaskan bagaimana cara mengatur parameter grafik seperti judul grafik, legend, warna, tema, dll. Pengaturan parameter grafik pada ggplot2 sebenarnya jauh lebih sederhana dibandingkan dengan fungsi dasar visualisasi R. Selain itu, kita dapat membuat tampilan grafik kita jauh lebih menarik dengan membuat tema kustom pada grafik kita.\n5.10.1 Merubah Judul Grafik, Keterangan Axis dan Legend\rUntuk merubah judul grafik dan keterangan axis kita dapat melakukannya melalui dua cara. Cara pertama adalah dengan memasukkan mengubahnya satu persatu menggunakan fungsi ggtitle() (judul grafik), xlab() (keterangan sumbu x), dan ylab() (keterangan pada sumbu y). Cara kedua adalah dengan menggunakan fungsi labs() dimana selain dapat mengubah judul grafik dan keterangan axis fungsi tersebut dapat juga digunakan untuk mengubah keterangan legend.\nPada sintaks berikut penulis akan memberikan contoh bagaimana mengubah judul grafik dan keterangan axis menggunakan dua cara tersebut. Output yang dihasilkan disajikan pada Gambar 27.\n# Cara 1\rggplot(gapminder, aes(continent, gdpPercap, fill=continent))+\r# membuat box plot\rgeom_boxplot()+\r# menambahkan judul\rggtitle(\u0026quot;GDP Per Capita Tiap Benua\u0026quot;)+\r# mengubah keterangan axis\rxlab(\u0026quot;Benua\u0026quot;)+\rylab(\u0026quot;GDP Per Kapita\u0026quot;)\r# cara 2\rggplot(gapminder, aes(continent, gdpPercap, fill=continent))+\r# membuat box plot\rgeom_boxplot()+\r# kustomisasi judul dan keterangan axis\rlabs(title=\u0026quot;GDP Per Capita Tiap Benua\u0026quot;,\rx=\u0026quot;Benua\u0026quot;, y=\u0026quot;GDP Per Kapita\u0026quot;)\r\rFigure 27: Mengubah judul grafik dan keterangan axis\r\rPada Gambar 27 kita belum mengubah keterangan legend. Berikut adalah sintaks untuk mengubah keterangan legend pada grafik tersebut beserta output yang disajikan pada Gambar 28.\n# cara 2\rggplot(gapminder, aes(continent, gdpPercap, # warna box berdasarkan benua\rfill=continent))+\r# membuat box plot\rgeom_boxplot()+\r# kustomisasi judul dan keterangan axis\rlabs(title=\u0026quot;GDP Per Capita Tiap Benua\u0026quot;,\rx=\u0026quot;Benua\u0026quot;, y=\u0026quot;GDP Per Kapita\u0026quot;,\r# mengubah keterangan legend\rfill=\u0026quot;Benua\u0026quot;)\r\rFigure 28: Mengubah keterangan legend pada grafik\r\rJudul, keterangan axis, dan keterangan legend dapat dikustomisasi menggunakan fungsi theme() dan element_text(). Berikut adalah format yang digunakan:\n# Judul\r\u0026lt;ggplot\u0026gt; + theme(plot.title = element_text(family, face, colour, size))\r# keterangan sumbu x\r\u0026lt;ggplot\u0026gt; + theme(axis.title.x = element_text(family, face, colour, size))\r# keterangan sumbu y\r\u0026lt;ggplot\u0026gt; + theme(axis.title.y = element_text(family, face, colour, size))\r# keterangan legend\r\u0026lt;ggplot\u0026gt; + theme(axis.title.y = element_text(family, face, colour, size))\r\rNote: \n\rfamily: font family.\rface: tampilan font. Nilai yang dapat digunakan antara lain: “plain”, “italic”, “bold” dan “bold.italic”.\rcolour: warna teks.\rsize: ukuran teks\r\r\rBerikut adalah contoh penerapan fungsi tersebut pada grafik Gambar 28. Output yang dihasilkan disajikan pada Gambar 29.\n# cara 2\rggplot(gapminder, aes(continent, gdpPercap, # warna box berdasarkan benua\rfill=continent))+\r# membuat box plot\rgeom_boxplot()+\r# kustomisasi judul dan keterangan axis\rlabs(title=\u0026quot;GDP Per Capita Tiap Benua\u0026quot;,\rx=\u0026quot;Benua\u0026quot;, y=\u0026quot;GDP Per Kapita\u0026quot;,\r# mengubah keterangan legend\rfill=\u0026quot;Benua\u0026quot;)+\rtheme(\rplot.title = element_text(color=\u0026quot;red\u0026quot;, size=14, face=\u0026quot;bold.italic\u0026quot;),\raxis.title.x = element_text(color=\u0026quot;blue\u0026quot;, size=14, face=\u0026quot;bold\u0026quot;),\raxis.title.y = element_text(color=\u0026quot;#993333\u0026quot;, size=14, face=\u0026quot;bold\u0026quot;),\rlegend.text = element_text(colour=\u0026quot;blue\u0026quot;, size=10, face=\u0026quot;bold\u0026quot;)\r)\r\rFigure 29: Kustomisasi judul grafik dan keterangan axis\r\r\r5.10.2 Merubah Tampilan dan Posisi Legend\rPosisi legend dapat diubah dengan menambahkan argumen legend.position pada fungsi theme(). Posisi legend dapat diubah dengan memasukkan nilai berupa karakter seperti “left”,“top”, “right”, dan “bottom”. Selain itu, posisi legend dapat dispesifikasi menggunakan vektor numerik c(x,Y). Nilai x dan y berkisar antara 0 sampai 1. Nilai c(0,0) menandakan posisi legend pada bagian kiri bawah dan c(0,1) menyatakan kiri atas.\nPenggunaan karakter dan vektor numerik akan menghasilkan output posisi legend yang berbeda. Jika menggunakan karakter posisi legend akan diubah diluar bidang plot. Sedangkan vektor numerik akan mengubah posisi legend menjadi ada pada bidang plot. Untuk lebih memahaminya berikut disajikan dua buah gambar. Gambar 30 menyajikan pengaturan legend menggunakan karakter, sedangkan Gambar 31 menyajikan pengaturan legend menggunakan vektor numerik.\n# cara 2\rggplot(gapminder, aes(continent, gdpPercap, # warna box berdasarkan benua\rfill=continent))+\r# membuat box plot\rgeom_boxplot()+\r# kustomisasi judul dan keterangan axis\rlabs(title=\u0026quot;GDP Per Capita Tiap Benua\u0026quot;,\rx=\u0026quot;Benua\u0026quot;, y=\u0026quot;GDP Per Kapita\u0026quot;,\r# mengubah keterangan legend\rfill=\u0026quot;Benua\u0026quot;)+\rtheme(legend.position=\u0026quot;top\u0026quot;)\r\rFigure 30: Kustomisasi posisi legend berdasarkan karakter\r\r# cara 2\rggplot(gapminder, aes(continent, gdpPercap, # warna box berdasarkan benua\rfill=continent))+\r# membuat box plot\rgeom_boxplot()+\r# kustomisasi judul dan keterangan axis\rlabs(title=\u0026quot;GDP Per Capita Tiap Benua\u0026quot;,\rx=\u0026quot;Benua\u0026quot;, y=\u0026quot;GDP Per Kapita\u0026quot;,\r# mengubah keterangan legend\rfill=\u0026quot;Benua\u0026quot;)+\rtheme(legend.position=c(0.9,0.75))\r\rFigure 31: Kustomisasi posisi legend berdasarkan vektor numerik\r\rPada fungsi theme() kita juga dapat merubah backgroud dari legend box menggunakan argumen legend.bacground dan element_rect. Selain itu kita juga dapat mengubah orientasi dari legend yang semula vertikal menjadi horizontal dengan menambahkan argumen legend.box. Berikut adalah contoh sintaks penerapannya. Output yang dihasilkan disajikan pada Gambar 32.\n# cara 2\rggplot(gapminder, aes(continent, gdpPercap, # warna box berdasarkan benua\rfill=continent,\r# warna outline berdasarkan benua\rcolor=continent))+\r# membuat box plot\rgeom_boxplot()+\r# kustomisasi judul dan keterangan axis\rlabs(title=\u0026quot;GDP Per Capita Tiap Benua\u0026quot;,\rx=\u0026quot;Benua\u0026quot;, y=\u0026quot;GDP Per Kapita\u0026quot;,\r# mengubah keterangan legend\rfill=\u0026quot;Benua (fill)\u0026quot;,\rcolor=\u0026quot;Benua (outline)\u0026quot;)+\rtheme(legend.position=\u0026quot;bottom\u0026quot;,\r# mengubah tampilan legend box legend.background = element_rect(fill=\u0026quot;lightblue\u0026quot;,\rsize=0.5, linetype=\u0026quot;solid\u0026quot;, colour =\u0026quot;darkblue\u0026quot;),\r# mengubah orientasi legend\rlegend.box= \u0026quot;horizontal\u0026quot;)\r\rFigure 32: Kustomisasi tampilan legend\r\rKita dapat juga menghilangkan legend baik seluruh legend maupun legend spesifik. Pada Gambar 33 dan Gambar 34 disajikan contoh cara menghilangkan seluruh legend maupun sebagian legend.\n# Menghilangkan seluruh legend\rggplot(gapminder, aes(continent, gdpPercap, # warna box berdasarkan benua\rfill=continent,\r# warna outline berdasarkan benua\rcolor=continent))+\r# membuat box plot\rgeom_boxplot()+\r# kustomisasi judul dan keterangan axis\rlabs(title=\u0026quot;GDP Per Capita Tiap Benua\u0026quot;,\rx=\u0026quot;Benua\u0026quot;, y=\u0026quot;GDP Per Kapita\u0026quot;,\r# mengubah keterangan legend\rfill=\u0026quot;Benua\u0026quot;)+\rtheme(legend.position=\u0026quot;none\u0026quot;)\r\rFigure 33: Menghilangkan seluruh legend\r\r# Menghilangkan seluruh legend\rggplot(gapminder, aes(continent, gdpPercap, # warna box berdasarkan benua\rfill=continent,\r# warna outline berdasarkan benua\rcolor=continent))+\r# membuat box plot\rgeom_boxplot()+\r# kustomisasi judul dan keterangan axis\rlabs(title=\u0026quot;GDP Per Capita Tiap Benua\u0026quot;,\rx=\u0026quot;Benua\u0026quot;, y=\u0026quot;GDP Per Kapita\u0026quot;,\r# mengubah keterangan legend\rfill=\u0026quot;Benua (fill)\u0026quot;,\rcolor=\u0026quot;Benua (outline)\u0026quot;)+\rtheme(legend.position=\u0026quot;bottom\u0026quot;,\r# mengubah tampilan legend box legend.background = element_rect(fill=\u0026quot;lightblue\u0026quot;,\rsize=0.5, linetype=\u0026quot;solid\u0026quot;, colour =\u0026quot;darkblue\u0026quot;))+\r# Menghilangkan legend Benua (outline)\rguides(color=FALSE)\r\rFigure 34: Menghilangkan sebagian legend legend\r\r\r5.10.3 Merubah Warana Pada Grafik Secara Otomatis dan Manual\rKita dapat merubah warna grafik baik secara otomatis dan manual. Secara otomatis warna dapat diubah dengan memasukkan nama variabel kedalam argumen fill dan color. Namun, jika kita inginkan kita dapat memasukkan kode warna untuk memperoleh warna yang seragam pada seluruh kelompok data.\nPada contoh sintaks berikut diberikan contoh bagaimana merubah warna pada seluruh grup data dengan satu warna yang seragam. Output yang dihasilkan disajikan pada Gambar 35:\nggplot(gapminder, aes(continent, lifeExp))+\r# spesifikasi warna tunggal\rgeom_boxplot(color=\u0026quot;darkred\u0026quot;,fill=\u0026quot;#A4A4A4\u0026quot;)\r\rFigure 35: Merubah warna grup berdasarkan satu warna\r\rSelain itu, kita dapat mengubah warna berdasarkan grup baik secara otomatis maupun manual. Berikut adalah contoh sintaks warna berdasarkan grup secara otomatis. Output yang dihasilkan disajikan pada Gambar 36.\nggplot(gapminder, aes(continent, gdpPercap, # warna berdasarkan grup\rfill=continent))+\rgeom_boxplot()\r\rFigure 36: Merubah warna grup secara otomatis\r\rKita dapat mengatur pecahayaan (l) dan intensitas warna (c) dari warna yang kita tampilkan menggunakan fungsi scale_fill_hue(). Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 37.\nggplot(gapminder, aes(continent, gdpPercap, # warna berdasarkan grup\rfill=continent))+\rgeom_boxplot()+\r# merubah l dan c\rscale_color_hue(l=40, c=35)\r\rFigure 37: Merubah pencahayaan dan intensitas warna\r\rJika kita tidak menginginkan warna yang secara otomatis ditampilkan oleh ggplot2, kita dapat mengubahnya secara manual menggunakan fungsi scale_fill_manual() (untuk box plot, bar plot, dll) dan scale_color_manual() (untuk line plot, dot plot dan scatterplot). Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 38.\nggplot(gapminder, aes(continent, gdpPercap, # warna berdasarkan grup\rfill=continent))+\rgeom_boxplot()+\r# merubah warna secara manual\rscale_fill_manual(values=c(\u0026quot;#999999\u0026quot;, \u0026quot;#E69F00\u0026quot;, \u0026quot;#56B4E9\u0026quot;,\r\u0026quot;#B47846\u0026quot;,\u0026quot;#B4464B\u0026quot;))\r\rFigure 38: Merubah warna secara manual\r\rJIka kita tidak hafal dengan kode hexadesimal warna tersebut kita dapat juga menggunakan palet warna. Contoh palet warna yang akan digunakan adalah dari library RColorBrewer. Berikut adalah contoh sintaks untuk menginstal dan memuat paket tersebut:\n# memasang paket\r# install.packages(\u0026quot;RColorBrewer\u0026quot;)\r# memuat paket\rlibrary(RColorBrewer)\rPada sintak berikut penulis akan menampilkan seluruh palet warna pada pekt tersebut. Output yang dihasilkan disajikan pada Gambar 39.\ndisplay.brewer.all()\r\rFigure 39: Palet warna RColorBrewer\r\rPada Gambar 39 terdapat 3 jenis warna antara lain:\nSequential palettes, digunakan untuk menunjukkan urutan dari rendah ke tinggi atau gradien. Nama palet yang ada antara lain: Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu YlOrBr,dan YlOrRd.\rDiverging palettes, digunakan untuk menunjukkan perubahan pada data yang memiliki nilai positif dan negatif. Palet yang tersedia antara lain: BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, dan Spectral.\rQualitative palettes, digunakan untuk merepresentasikan variabel nominal atau kategori karena tidak menunjukkan besaran atau perbedaan nilai antar grup. Palete yang tersedia antara lain: Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, dan Set3.\r\rPada contoh sintaks berikut disajikan contoh penerapan dan output yang dihasilkan pada Gambar 40.\nggplot(gapminder, aes(continent, gdpPercap, # warna berdasarkan grup\rfill=continent))+\rgeom_boxplot()+\r# merubah warna menggunakan palet\rscale_color_brewer(palette=\u0026quot;Dark2\u0026quot;)\r\rFigure 40: Merubah warna menggunakan palet\r\rJika kita tidak menginginkan warna-warna terang, kita dapat menggunakan fungsi scale_color_grey() (untuk line plot, dot plot, dan scatterplot) dan scale_fill_grey() (untuk bar plot, histogram, box plot, dll). Funsi tersebut akan memberikan warna palet gray pada plot. Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 41.\nggplot(gapminder, aes(continent, gdpPercap, # warna berdasarkan grup\rfill=continent))+\rgeom_boxplot()+\r# merubah warna menggunakan palet\rscale_fill_grey()\r\rFigure 41: Merubah warna menggunakan palet gray\r\r\r5.10.4 Kustomisasi Titik\rUntuk mengubah jenis titik pada scatterplot, outlier pada box plot, dan dot plot, kita dapat menambahkan argumen shape pada fungsi geometrinya. Nilai yang mungkin dimasukkan berupa nilai diskrit yang berkisar antara 0 sampai 25. Selain itu, ukuran dari titik dapat diinput dengan menambahkan argumen size. Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 42.\nggplot(gapminder, aes(gdpPercap, lifeExp))+\r# spesifikasi jenis, ukuran dan warna titik\rgeom_point(shape=4, size=2, color=\u0026quot;blue\u0026quot;)\r\rFigure 42: Kustomisasi jenis, ukuran dan warna titik\r\rUntuk data dengan multiple group, kita dapat mengubah jenis, ukuran dan warna secara otomatis dengan memasukkan nama variabel kedalam argumen shape, size dan color. Sedangkan secara manual kita dapat menambahkan fungsi scale_shape_manual() (jenis titik), scale_color_manual() (warna titik), dan scale_size_manual() (ukuran titik). Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 43 dan Gambar 44.\n# cara otomatis\rggplot(gapminder, aes(gdpPercap, lifeExp,\r# spesifikasi jenis, ukuran dan warna\rshape=continent, color=continent,\rsize=pop))+\rgeom_point()\r\rFigure 43: Kustomisasi jenis, ukuran dan warna titik untuk multiple group secara otomatis\r\r# cara manual\rggplot(gapminder, aes(gdpPercap, lifeExp,\r# spesifikasi jenis, ukuran dan warna\rshape=continent, color=continent,\rsize=pop))+\rgeom_point()+\rscale_shape_manual(values=c(1:5))+\rscale_color_manual(values=c(\u0026quot;#999999\u0026quot;, \u0026quot;#E69F00\u0026quot;, \u0026quot;#56B4E9\u0026quot;,\r\u0026quot;#B47846\u0026quot;,\u0026quot;#B4464B\u0026quot;))\r\rFigure 44: Kustomisasi jenis, ukuran dan warna titik untuk multiple group secara manual\r\r\r5.10.5 Kustomisasi Jenis Garis\rJenis, warna dan ukuran garis dapat diatur dengan menambahkan argumen linetype, size dan color. Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 45.\ngapminder%\u0026gt;%\rfilter(continent==\u0026quot;Asia\u0026quot;)%\u0026gt;%\rgroup_by(year)%\u0026gt;%\rsummarize(mean_pop=mean(pop))%\u0026gt;%\r# plot\rggplot(aes(year, mean_pop))+\rgeom_line(linetype=\u0026quot;dashed\u0026quot;, color=\u0026quot;blue\u0026quot;,\rsize=1)+\rgeom_point(shape=1, color=\u0026quot;red\u0026quot;)\r\rFigure 45: Kustomisasi jenis, ukuran dan warna garis\r\rUntuk data dengan multiple group, kita dapat mengubah jenis garis, warna dan ukuran secara manual maupun secara otomatis. Secara otomatis kita dapat menginputkan nama variabel kedalam argumen linetype, size dan color. Secara manual, kita dapat mengubah jenis, warna dan ukuran menggunakan fungsi scale_linetype_manual() (jenis garis), scale_color_manual() (warna garis), dan scale_size_manual() (ukuran garis). Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 46 dan Gambar 47.\n# cara otomatis\rgapminder%\u0026gt;%\rfilter(continent %in% c(\u0026quot;Asia\u0026quot;,\u0026quot;Africa\u0026quot;))%\u0026gt;%\rgroup_by(year, continent)%\u0026gt;%\rsummarize(mean_pop=mean(pop))%\u0026gt;%\r# plot\rggplot(aes(year, mean_pop,\rlinetype=continent,\rcolor=continent))+\rgeom_line()+\rgeom_point(shape=1, color=\u0026quot;red\u0026quot;)\r\rFigure 46: Kustomisasi jenis, ukuran dan warna garis untuk multiple group secara otomatis\r\r# cara manual\rgapminder%\u0026gt;%\rfilter(continent %in% c(\u0026quot;Asia\u0026quot;,\u0026quot;Africa\u0026quot;))%\u0026gt;%\rgroup_by(year, continent)%\u0026gt;%\rsummarize(mean_pop=mean(pop))%\u0026gt;%\r# plot\rggplot(aes(year, mean_pop,\rlinetype=continent,\rcolor=continent))+\rgeom_line()+\rgeom_point(shape=1, color=\u0026quot;red\u0026quot;)+\rscale_linetype_manual(values=c(\u0026quot;dotted\u0026quot;, \u0026quot;twodash\u0026quot;))+\rscale_color_manual(values=c(\u0026quot;red\u0026quot;,\u0026quot;blue\u0026quot;))\r\rFigure 47: Kustomisasi jenis, ukuran dan warna garis untuk multiple group secara manual\r\r\r5.10.6 Menambahkan Label Pada Titik Observasi dan Bidang Plot\rPada artikel ini penulis akan menjelaskan bagaimana kita dapat menambahkan teks pada plot. Fungsi-fungsi yang dapat digunakan antara lain:\n\rgeom_text(): menambahkan teks secara langsung pada plot.\rgeom_label(): menambahkan teks dengan kotak disekelilingnya.\rannotate(): menambahkan teks tertentu pada bagian tertentu bidang plot.\rannotation_custom(): menambahkan anotasi statik yang sama pada setiap panel.\r\rMisal kita akan membuat plot antara variabel pop vs gdpPercap seperti yang ditunjukkan pada Gambar 48 berikut:\nggplot(gapminder, aes(gdpPercap, pop))+\rgeom_point()\r\rFigure 48: Scatterplot variabel pop vs gdpPercap\r\rMisalkan kita ingin menandai negara yang memiliki gdpPercap \u0026gt; 50000. Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 49.\nggplot(gapminder, aes(gdpPercap, pop))+\rgeom_point(shape=1)+\rgeom_label(\r# subset data sesua kriteria\rdata=subset(gapminder,gdpPercap\u0026gt;50000),\r# label berdasarkan kriteria\raes(label=country),\r# ukuran teks\rsize = 3)\r\rFigure 49: Scatterplot variabel pop vs gdpPercap dengan label\r\rSelain teks yang menunjukkan observasi, kita dapat menambahkan anotasi pada grafik. Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 50.\nggplot(gapminder, aes(gdpPercap, pop))+\rgeom_point(shape=1)+\r# menambahkan label sesuai kriteria data\rgeom_label(\r# subset data sesua kriteria\rdata=subset(gapminder,gdpPercap\u0026gt;50000),\r# label berdasarkan kriteria\raes(label=country),\r# ukuran teks\rsize = 3)+\rannotate(geom=\u0026quot;text\u0026quot;, x=90000,\ry=2e+08, label=\u0026quot;outlier\u0026quot;,\rcolor=\u0026quot;red\u0026quot;)\r\rFigure 50: Scatterplot variabel pop vs gdpPercap dengan label dan notasi\r\rKita dapat pula menambahkan teks statik yang sama pada setiap panel. Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 51.\nlibrary(grid)\r# membuat teks\rd \u0026lt;- grob \u0026lt;- grobTree(textGrob(\u0026quot;Scatter plot\u0026quot;, x=0.1, y=0.95, hjust=0,\rgp=gpar(col=\u0026quot;red\u0026quot;, fontsize=13, fontface=\u0026quot;italic\u0026quot;)))\r# plot\rggplot(gapminder, aes(gdpPercap, pop))+\rgeom_point(shape=1)+\r# menambahkan anotasi\rannotation_custom(d)+\r# membagi plot menjadi beberapa panel\rfacet_wrap(~continent, scales=\u0026quot;free\u0026quot;)\r\rFigure 51: Scatterplot variabel pop vs gdpPercap dengan label dan notasi pada tiap panel\r\r\r5.10.7 Kustomisasi Tema Pada Plot\rKita dapat melakukan kustomisasi tema plot untuk membuat tampilan plot kita lebih menarik. Pada bagian ini penulis akan membahas tema yang dapat digunakan serta cara untuk melakukan edit terhadap tema yang telah ada sebelumnya.\nTema-tema yang telah terpasang secara defautl pada paket ggplot2 antara lain:\n\rtheme_gray: backround dengan warna abu-abu dengan garis grid putih.\rtheme_bw: background putih dan garis grid berwarna abu-abu.\rtheme_linedraw: garis hitam di sekeliling bidang plot.\rtheme_light: garis grid dan axis berwarna abu-abu terang.\rtheme_minimal: tidak memiliki frame disekeliling bidang plot.\rtheme_classic: tidak ada garis grid dan axis.\rtheme_void: tema kosong\rtheme_dark: background gelap.\r\rPada contoh berikut disajikan sebagian contoh penerapan tema pada plot. Output yang dihasilkan pada Gambar 52.\nggplot(gapminder, aes(gdpPercap, lifeExp))+\rgeom_point()+\rtheme_bw()\r\rFigure 52: Scatterplot dengan tema black and white\r\rKita juga dapat menggunakan tema kustom yang terdapat pada library ggthemes. Berikut adalah sintaks yang digunakan untuk menginstall dan memuat paket tersebut:\n# Memasang paket\rinstall.packages(\u0026quot;ggthemes\u0026quot;)\r# memuat paket\rlibrary(ggthemes)\r## Warning: package \u0026#39;ggthemes\u0026#39; was built under R version 3.5.3\rtema-tema yang tersedia pada paket tersebut antara lain:\n\rtheme_tufte: tema minimalis.\rtheme_economist: tema yang digunakan pada majalah Economist.\rtheme_stata: tema yang digunakan pada visualisasi progra stata.\rtheme_wsj: tema yang digunakan pada Wall Street Journal.\rtheme_cal: tema yang digunakan pada LibreOffice Calc dan Google Docs.\rtheme_hc: tema yang didasarkan pada Highcharts JS.\r\rPada contoh berikut disajikan sebagian contoh penerapan tema pada plot. Output yang dihasilkan pada Gambar 53.\nggplot(gapminder, aes(gdpPercap, lifeExp, color=continent))+\rgeom_point()+\rtheme_wsj()\r\rFigure 53: Scatterplot dengan tema Wall Street Journal\r\rKita dapat juga membuat tema kustom berdasarkan tema yang telah ada. Untuk melakukannya kita hanya perlu merubah sejumlah argument default yang ada pada fungsi tema dan menamai tema sesuai dengan yang kita inginkan menggunakan user define function. Berikut adalah contoh argumen yang dapat diubah pada theme_wsj.\ntheme_wsj\r## function (base_size = 12, color = \u0026quot;brown\u0026quot;, base_family = \u0026quot;sans\u0026quot;, ## title_family = \u0026quot;mono\u0026quot;) ## {\r## colorhex \u0026lt;- ggthemes::ggthemes_data$wsj$bg[color]\r## theme_foundation(base_size = base_size, base_family = base_family) + ## theme(line = element_line(linetype = 1, colour = \u0026quot;black\u0026quot;), ## rect = element_rect(fill = colorhex, linetype = 0, ## colour = NA), text = element_text(colour = \u0026quot;black\u0026quot;), ## title = element_text(family = title_family, size = rel(2)), ## axis.title = element_blank(), axis.text = element_text(face = \u0026quot;bold\u0026quot;, ## size = rel(1)), axis.text.x = element_text(colour = NULL), ## axis.text.y = element_text(colour = NULL), axis.ticks = element_line(colour = NULL), ## axis.ticks.y = element_blank(), axis.ticks.x = element_line(colour = NULL), ## axis.line = element_line(), axis.line.y = element_blank(), ## legend.background = element_rect(), legend.position = \u0026quot;top\u0026quot;, ## legend.direction = \u0026quot;horizontal\u0026quot;, legend.box = \u0026quot;vertical\u0026quot;, ## panel.grid = element_line(colour = NULL, linetype = 3), ## panel.grid.major = element_line(colour = \u0026quot;black\u0026quot;), ## panel.grid.major.x = element_blank(), panel.grid.minor = element_blank(), ## plot.title = element_text(hjust = 0, face = \u0026quot;bold\u0026quot;), ## plot.margin = unit(c(1, 1, 1, 1), \u0026quot;lines\u0026quot;), strip.background = element_rect())\r## }\r## \u0026lt;bytecode: 0x0000000019a56b20\u0026gt;\r## \u0026lt;environment: namespace:ggthemes\u0026gt;\rBerdasarkan output yang disajikan kita dapat merubah sejumlah argumen seperti base size, color, base_family, dll.\n\r5.10.8 Penskalaan dan Transformasi Axis\rPada bagian ini penulis akan menjelaskan bagaimana cara melakukan modifikasi terhadap sumbu x dan y seperti menetapkan limit nilai maksimum dan minimum axis serta melakukan transformasi pada tiap axis.\nUntuk mengatur rentang nilai axis, kita dapat melakukannya dengan fungsi sebagai berikut:\n\rxlim() dan ylim(): mengatur limit aksis sumbu x dan y.\rexpand_limits(): mengatur limit sumbu x dan y sekaligus dapat mengatur intercept kedua sumbu tersebut.\rscale_x_continous() dan scale_y_continous(): megatur limit axis termasuk axis tick dan label.\r\rPada contoh berikut akan disajikan cara mengatur limit axis dengan menggunakan xlim() dan ylim() serta menggunakan expand_limits(). Output yang dihasilkan disajikan pada Gambar 54.\ngapminder%\u0026gt;%\rfilter(continent==\u0026quot;Europe\u0026quot;)%\u0026gt;%\rggplot(aes(gdpPercap, lifeExp))+\rgeom_point()+\rtheme_wsj(base_size=7)+\rlabs(title=\u0026quot;GDP per Capita vs Life Expectancy\u0026quot;,\ry=\u0026quot;Life Expectancy\u0026quot;,\rx=\u0026quot;GDP per Capita (US Dollar)\u0026quot;)+\r# mengatur limit axis\rexpand_limits(x=c(0, 55000), y=c(0, 90))\r# atau\rgapminder%\u0026gt;%\rfilter(continent==\u0026quot;Europe\u0026quot;)%\u0026gt;%\rggplot(aes(gdpPercap, lifeExp))+\rgeom_point()+\rtheme_wsj(base_size=7)+\rlabs(title=\u0026quot;GDP per Capita vs Life Expectancy\u0026quot;,\ry=\u0026quot;Life Expectancy\u0026quot;,\rx=\u0026quot;GDP per Capita (US Dollar)\u0026quot;)+\r# mengatur limit axis\rxlim(0,55000)+\rylim(0,90)\r\rFigure 54: Scatterplot dengan axis limits\r\rKita juga dapat menggunakan fungsi scale_x_continuous() dan scale_y_continuous() untuk mengatur limit axis ,axis tick dan label. Format yang digunakan adalah sebagai berikut:\nscale_x_continuous(name, breaks, labels, limits, trans)\rscale_y_continuous(name, breaks, labels, limits, trans)\r\rNote: \n\rname: label axis sumbu x dan y.\rbreaks: untuk mengontrol jeda dalam panduan (axis tick, garis grid, …). Di antara nilai-nilai yang mungkin, adalah sebagai berikut:\n\rNULL: menyembunyikan seluruh breaks.\rwaiver(): komputasi break default.\rvektor numerik atau karakter untuk menspesifikasikan break yang akan ditampilkan.\n\rlabels: label axis. Nilai yang dapat dimasukkan antara lain;\rNULL: tanpa label.\rwaiver(): label default.\rvektor karakter yang digunakan untuk spesifikasi label break.\n\rlimits: vektor numerik untuk spesifikasi limit sumbu x dan y.\rtrans: transformasi axis. Nilai yang dapat digunakan adalah “log2”, “log10”, dll.\n\r\r\rPada contoh berikut disajikan contoh mengatur limit axis dan label axis menggunakan fungsi scale_x_continous() dan scale_y_continous(). Grafik yang dihasilkan akan tampak seperti Gambar 55.\n# atau\rgapminder%\u0026gt;%\rfilter(continent==\u0026quot;Asia\u0026quot;)%\u0026gt;%\rggplot(aes(gdpPercap, lifeExp))+\rgeom_point()+\rtheme_wsj(base_size=7)+\rggtitle(\u0026quot;GDP per Capita vs Life Expectancy\u0026quot;)+\r# spesifikasi limit dan label axis\rscale_x_continuous(name=\u0026quot;GDP per Capita\u0026quot;, limits=c(0, 125000))+\rscale_y_continuous(name=\u0026quot;Life Expectancy\u0026quot;,\rlimits=c(0,100))\r\rFigure 55: Scatterplot dengan axis limits (2)\r\rTranformasi axis dapat dilakukan dengan fungsi bawaan dari ggplot2. Fungsi transformasi bawaan berupa transformasi log dan sqrt. Berikut adalah fungsi bawaan untuk transformasi tersebut:\n\rscale_x_log10() dan scale_y_log10(): transformasi log basis 10.\rscale_x_sqrt() dan scale_y_sqrt(): transformasi akar kuadrat.\rscale_x_reverse() dan scale_x_reverse(): membalikkan koordinat.\rcoord_trans(x=“log10”, y=“log10”): memungkinkan transformasi untuk kedua axis sesuai fungsi yang diinputkan pada sumbu x dan sumbu y seperti “log2”, “log10”, “sqrt”, dll.\rscale_x_continuous(trans=“log2”) dan scale_y_continuous(trans=“log2”): nilai lain yang dapat diinputkan adalah “log10”.\r\rPada contoh berikut disajikan contoh transformasi sumbu x menggunakan fungsi scale_x_log10(). Grafik yang dihasilkan akan tampak seperti Gambar 56.\n# atau\rgapminder%\u0026gt;%\rfilter(continent==\u0026quot;Europe\u0026quot;)%\u0026gt;%\rggplot(aes(gdpPercap, lifeExp))+\rgeom_point()+\rtheme_wsj(base_size=7)+\rlabs(title=\u0026quot;log(GDP per Capita) vs Life Expectancy\u0026quot;,\ry=\u0026quot;Life Expectancy\u0026quot;,\rx=\u0026quot;GDP per Capita (US Dollar)\u0026quot;)+\r# transformasi sumbu x\rscale_x_log10()\r\rFigure 56: Scatterplot dengan transformasi axis\r\rTick mark pada axis juga dapat kita atur menggunakan fungsi scale_x_continous() dan scale_y_continous(). Untuk mengubah format dan label tick mark kita perlu menginstall dan memuat library scales yang berfungsi untuk mengakses fungsi pada argumen break. Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 57.\n# memasang paket\r# install.packages(\u0026quot;scales\u0026quot;)\r# memuat paket\rlibrary(scales)\r## Warning: package \u0026#39;scales\u0026#39; was built under R version 3.5.3\r# plot\rggplot(gapminder, aes(gdpPercap, lifeExp))+\rgeom_point()+\rtheme_bw()+\r# kustomisasi tick mark sumbu y\rscale_y_continuous(trans= log2_trans(),\rbreaks=trans_breaks(\u0026quot;log2\u0026quot;, function(x) 2^x),\rlabels= trans_format(\u0026quot;log2\u0026quot;, math_format(2^.x)))+\r# kustomisasi sumbu x\rscale_x_continuous(labels = dollar)\r\rFigure 57: Scatterplot dengan transformasi tick mark axis\r\r\r5.10.9 Kustomisasi Tick Mark Axis\rPada bagian ini pembaca akan mempelajari bagaimana melakukan kustomisasi tampilan tick mark. Selain itu kita juga akan belajar bagaimana melakukan pengaturan pada garis axis.\nWarna, ukuran font, dan tampilan font (font style) pada tick mark dapat diubah menggunakan fungsi theme() dan element_text(). Format yang digunakan adalah sebagai berikut:\n# x axis tick mark labels\r\u0026lt;plot\u0026gt; + theme(axis.text.x= element_text(family, face, colour, size, angle))\r# y axis tick mark labels\r\u0026lt;plot\u0026gt; + theme(axis.text.y = element_text(family, face, colour, size, angle))\r\rNote: \n\rfamily: font family, seperti: “sans”,“times new roman”, dll.\rface: font face, nilai yang mungkin adalah “plain”, “italic”, “bold” dan “bold.italic”.\rcolor: warna teks.\rsize: ukuran teks dalam satuan pts.\rangle: sudut kemiringan teks berkisar antara 0 sampai 360.\r\r\rBerikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 58.\nggplot(gapminder, aes(continent, gdpPercap,\rfill=continent))+\rgeom_boxplot()+\rtheme_economist()+\rscale_fill_economist()+\r# kustomisasi tick mark\rtheme(axis.text.x = element_text(face=\u0026quot;bold\u0026quot;, color=\u0026quot;#993333\u0026quot;,\rsize=10, angle=30),\raxis.text.y = element_text(face=\u0026quot;bold\u0026quot;, color=\u0026quot;#993333\u0026quot;,\rsize=10, angle=30))\r\rFigure 58: Mengubah tampilan dari tick mark\r\rUntuk menonaktifkan tick mark pada plot kita dapat menggunakan fungsi element_blank(). Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 59.\nggplot(gapminder, aes(continent, gdpPercap,\rfill=continent))+\rgeom_boxplot()+\rtheme_stata()+\rscale_fill_stata()+\r# menyembunyikan tick mark dan tick mark label\rtheme(axis.text.x=element_blank(),\raxis.text.y=element_blank(),\raxis.ticks=element_blank())\r\rFigure 59: Menyembunyikan tampilan dari tick mark\r\rKita dapat melakukan pengaturan terhadap garis axis menggunakan argumen axis.lines dan fungsi element_line. Berikut adalah format yang digunakan:\n\u0026lt;plot\u0026gt; + theme(axis.line = element_line(color,size, linetype,\rlineend, color))\r\rNote: \n\rcolor: warna garis.\rsize: ukuran garis.\rlinetype: jenis garis.\rlineend: akhir dari garis. Nilai yang dapat dimasukkan antara lain: “round”, “butt” atau “square”.\r\r\rBerikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 60.\nggplot(gapminder, aes(continent, gdpPercap,\rfill=continent))+\rgeom_boxplot()+\rtheme_wsj()+\rscale_fill_wsj()+\r# kustomisasi garis axis\rtheme(axis.line = element_line(colour = \u0026quot;darkblue\u0026quot;, size = 1, linetype = \u0026quot;solid\u0026quot;))\r\rFigure 60: Kustomisasi tampilan dari garis axis\r\rKita dapat mengatur tick pada axis baik yang memiliki skala diskrit maupun kontinyu. Fungsi yang digunakan adalah scale_x_continous() dan scale_y_continous() untuk tick dengan nilai kontinyu dan scale_x_discrete() dan scale_y_discrete().\nBerikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 61.\nggplot(gapminder, aes(continent, lifeExp,\rfill=continent))+\rgeom_boxplot()+\rtheme_gdocs()+\rscale_fill_gdocs()+\r# kustomisasi tick mark\rscale_y_continuous(\r# nilai dari 0 sampai 100 tiap 10 tick\rbreaks=seq(0,100,10))\r\rFigure 61: Kustomisasi tick mark\r\r\r5.10.10 Menambahkan Garis Lurus Pada Plot\rFungsi yang dapat digunakan untuk menambahkan garis lurus antara lain:\n\rgeom_hline(): menambahkan garis horizontal.\rgeom_abline(): menambahkan garis regresi.\rgeom_vline(): menambahkan garis vertikal.\rgeom_segment(): menambahkan garis segmen.\r\rFormat yang digunakan untuk fungsi geom_hline() dan geom_vline() adalah sebagai berikut:\ngeom_hline(yintercept, linetype, color, size)\rgeom_vline(xintercept, linetype, color, size)\rBerikut adalah contoh penerapan kedua fungsi tersebut yang disajikan pada Gambar 62 dan Gambar 63:\nggplot(gapminder, aes(lifeExp, fill=..count..))+\rgeom_histogram()+\rtheme_calc()+\r# menambahkan garis vertikal\rgeom_vline(xintercept=mean(gapminder$lifeExp), linetype=\u0026quot;twodash\u0026quot;,\rcolor=\u0026quot;red\u0026quot;,\rsize=1.5)\r\rFigure 62: Penerapan vline\r\rggplot(gapminder, aes(continent, lifeExp, fill=continent))+\rgeom_boxplot()+\rtheme_calc()+\rscale_fill_calc()+\r# menambahkan garis horizontal\rgeom_hline(yintercept=mean(gapminder$lifeExp), linetype=\u0026quot;twodash\u0026quot;,\rcolor=\u0026quot;red\u0026quot;,\rsize=1.5)\r\rFigure 63: Penerapan hline\r\rSelain menggunakan fungsi geom_smooth(), garis regresi dapat ditambahkan melalui fungsi `geom_abline(). Format yang digunakan adalah sebagai berikut:\ngeom_abline(intercept, slope, linetype, color, size)\rUntuk membuat garis regresi kita perlu membuat model regresi terlebih dahulu menggunakn fungsi lm(). Berikut adalah contoh model yang dibuat beserta koefisien regresinya.\n# membuat model regresi\rmod \u0026lt;- lm(lifeExp~gdpPercap, data=gapminder)\r# print model\rmod\r## ## Call:\r## lm(formula = lifeExp ~ gdpPercap, data = gapminder)\r## ## Coefficients:\r## (Intercept) gdpPercap ## 5.396e+01 7.649e-04\r# koefisien regresi model\rcoef \u0026lt;- coefficients(mod)\r# print koefisien\rcoef\r## (Intercept) gdpPercap ## 5.395556e+01 7.648826e-04\rBerikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 64 untuk membuat plot regresi linier.\nggplot(gapminder, aes(gdpPercap, lifeExp))+\rgeom_point(shape=1, color=\u0026quot;grey\u0026quot;)+\rtheme_stata()+\r# menambahkan garis regresi\rgeom_abline(intercept=5.395556e+01,\rslope=7.648826e-04,\rlinetype=\u0026quot;twodash\u0026quot;,\rcolor=\u0026quot;red\u0026quot;,\rsize=1)\r\rFigure 64: Penerapan abline\r\rKita dapat menambahkan garis segment untuk menunjukkan sebuah observasi. Format yang digunakan adalah sebagai berikut:\ngeom_segment(aes(x, y, xend, yend))\rBerikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 65 untuk membuat garis segmen.\nlibrary(grid)\rggplot(gapminder, aes(gdpPercap, lifeExp))+\rgeom_point(shape=1, color=\u0026quot;grey\u0026quot;)+\rtheme_stata()+\r# menambahkan tanda panah\rgeom_segment(x=70000, y=80,\rxend=60000, yend=70,\rarrow=arrow(length=unit(0.1, \u0026quot;inches\u0026quot;)),\rlinetype=\u0026quot;twodash\u0026quot;,\rcolor=\u0026quot;red\u0026quot;,\rsize=1)\r\rFigure 65: Penerapan garis segmen\r\r\r5.10.11 Melakukan Rotasi Pada Grafik\rRotasi grafik atau pembalikan axis dapat dilakukan menggunakan fungsi berikut:\n\rcoord_flip(): untuk membuat plot horizontal.Rotasi axis sehingga sumbu x dapat menjadi sumbu y dan sebaliknya.\rscale_x_reverse() dan scale_x_reverse(): pembalikan skala pada axis.\r\rMisalkan kita ingin membuat plot horizontal pada box plot sehingga mempermudah kita dalam melakukan perbandingan terhadap masing-masing grup. Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 66.\nggplot(gapminder, aes(continent, lifeExp, fill=continent))+\rgeom_boxplot()+\rtheme_economist()+\rscale_fill_economist()+\r# rotasi axis\rcoord_flip()\r\rFigure 66: Rotasi axis\r\rKita dapat juga melakukan pembalikan skala pada axis sehingga skala yang semula berawal dari min ke max menjadi sebaliknya. Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 67.\nggplot(gapminder, aes(lifeExp, fill=..count..))+\rgeom_histogram()+\rtheme_wsj()+\r# pembalikan sumbu y\rscale_y_reverse()\r\rFigure 67: Pembalikan sumbu y\r\r\r5.10.12 Facet\rFacet digunakan untuk membagi plot menjadi panel matriks. Setiap panel menunjukkan setiap kelompok data. Fungsi facet yang dapat digunakan antara lain:\n\rfacet_grid()\rfacet_wrap()\r\rBerikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 68 dan Gambar 69 untuk membuat facet pada satu variabel.\nggplot(gapminder, aes(lifeExp, fill=..count..))+\rgeom_histogram()+\rtheme_gdocs()+\rfacet_grid(.~continent)\r\rFigure 68: Facet horizontal satu variabel\r\rggplot(gapminder, aes(lifeExp, fill=..count..))+\rgeom_histogram()+\rtheme_gdocs()+\rfacet_grid(continent~.)\r\rFigure 69: Facet vertikal satu variabel\r\rKita dapat pula melakukan facet terhadap dua buah variabel.Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 70 untuk membuat facet pada dua variabel.\ngapminder%\u0026gt;%\rfilter(year==1952|year==2007,\rcontinent %in% c(\u0026quot;Asia\u0026quot;,\u0026quot;Americas\u0026quot;))%\u0026gt;%\rggplot(aes(continent, lifeExp, fill=factor(year)))+\rgeom_boxplot()+\rtheme_stata()+\rscale_fill_stata()+\rfacet_grid(continent~factor(year))\r\rFigure 70: Facet dua variabel\r\rKita dapat mengatur skala dari axis menggunakan argument sebagai berikut:\n\rfree: skala akan disesuaikan berdasarkan pada setiap axis.\rfree_x: skala pada sumbu x akan dibiarkan menyesuaikan secara bebas.\rfree_y: skala pada sumbu y akan dibiarkan menyesuaikan secara bebas.\rfixed (default): skala axis diseragamkan pada seluruh panel.\r\rBerikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Gambar 71 untuk membuat facet pada dua variabel dengan skala bebas pada sumbu y.\ngapminder%\u0026gt;%\rfilter(year==1952|year==2007,\rcontinent %in% c(\u0026quot;Asia\u0026quot;,\u0026quot;Americas\u0026quot;))%\u0026gt;%\rggplot(aes(continent, lifeExp, fill=factor(year)))+\rgeom_boxplot()+\rtheme_stata()+\rscale_fill_stata()+\rfacet_grid(continent~factor(year), scales=\u0026quot;free_y\u0026quot;)\r\rFigure 71: Facet dua variabel dengan skala bebas pada sumbu y\r\rReferensi\nWickham, H. Grolemund G. 2016. R For Data Science: Import, Tidy, Transform, Visualize, And Model Data. O’Reilly Media, Inc.\rPeng, R.D. 2015. Exploratory Data Analysis with R. Leanpub book.\rGGPLOT2 Documentation. https://ggplot2.tidyverse.org/\rSTHDA. ggplot2 - Essentials. \u0026lt;www.sthda.com/english/wiki/ggplot2-essentials\u0026gt;\r\r\r\r","date":1553446800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1553446800,"objectID":"f79d857de32c2b3d7300853f5d54db2b","permalink":"/tutorial/05_visualisasi-data-menggunakan-ggplot/","publishdate":"2019-03-25T00:00:00+07:00","relpermalink":"/tutorial/05_visualisasi-data-menggunakan-ggplot/","section":"tutorial","summary":"body{\rtext-align: justify}\r\r\rDaftar Isi\n\rScatterplot\rBox Plot dan Violin Plot\rBar Plot\rLine Plot\rPie Chart\rHistogram dan Density Plot\rQQ Plot\rDot Chart\rECDF Plot\rParameter Grafik\r\r\rLibrary ggplot2 merupakan implementasi dari The Grammar of Graphics yang ditulis oleh Leland Wilkinson. ggplot2 merupakan library yang dikembangkan oleh Hadley Wicham ketika ia sedang menempuh kuliah di Lowa State Universuty dan masih dikembangkan hingga sekarang.","tags":null,"title":"5. Visualisasi Data Menggunakan GGPLOT","type":"docs"},{"authors":null,"categories":null,"content":"\r\rbody{\rtext-align: justify}\r\r\rDaftar Isi:\r\rImport File\rEksport File\rTibble Data Format\rMerapikan Data\rTransformasi Data\r\r\r3.1 Import File\rPada sesi bagian ini penulis akan menjelaskan cara mengimport file pada R. File yang diimport ke dalam R terdiri atas file yang sering digunakan pada saat akan melakukan analisis data, antara lain: TXT, CSv, Excel, SPSS, SAS, dan STATA.\nPada bagian ini akan dijelaskan pula bagaimana melakukan import data menggunakan library readr serta kelebihan dari metode import data yang digunakan. Berikut adalah cara mengimport data berbagai format pada R.\n\rNote:  Pastikan kita telah mengatur lokasi working directory pada tempat dimana lokasi file yang akan kita baca berada untuk mempermudah dalam melakukan import file.\n\r3.1.1 Import File Menggunakan Fungsi Bawaan R\rFungsi bawaan R secara umum hanya dapat membaca data dengan format TXT dan CSV. Pada RStudio fungsi ini bertambah dengan adanya library tambahan yang telah terinstall di RStudio untuk membaca file dengan format EXCEL, SPSS, SAS dan STATA.\nSecara umum fungsi yang digunakan untuk membaca data dengan format tabel seperti TXT dan CSV adalah fungsiread.table(). Berikut adalah list fungsi dasar lainnya untuk membaca file dengan format TXT dan CSV pada R:\n\rread.csv(): untuk membaca file dengan format comma separated value(“.csv”).\rread.csv2(): varian yang digunakan jika pada file “.csv” yang akan dibaca mengandung koma (“,”) sebagai desimal dan semicolon (“;”) sebagai pemisah antar variabel atau kolom.\rread.delim(): untuk membaca file dengan format tab-separated value(“.txt”).\rread.delim2(): membaca file dengan format “.txt” dengan tanda koma (“,”) sebagai penujuk bilangan desimal.\r\rMasing-masing fungsi diatas dapat dituliskan kedalam R dengan format sebagai berikut:\n# Membaca tabular data pada R\rread.table(file, header = FALSE, sep = \u0026quot;\u0026quot;, dec = \u0026quot;.\u0026quot;)\r# Membaca\u0026quot;comma separated value\u0026quot; files (\u0026quot;.csv\u0026quot;)\rread.csv(file, header = TRUE, sep = \u0026quot;,\u0026quot;, dec = \u0026quot;.\u0026quot;, ...)\r# atau gunakan read.csv2 jika tanda desimal pada data adalah \u0026quot;,\u0026quot; dan pemisah kolom adalah \u0026quot;;\u0026quot;\rread.csv2(file, header = TRUE, sep = \u0026quot;;\u0026quot;, dec = \u0026quot;,\u0026quot;, ...)\r# MembacaTAB delimited files\rread.delim(file, header = TRUE, sep = \u0026quot;\\t\u0026quot;, dec = \u0026quot;.\u0026quot;, ...)\rread.delim2(file, header = TRUE, sep = \u0026quot;\\t\u0026quot;, dec = \u0026quot;,\u0026quot;, ...)\r\rNote: \n\rfile: nama file diakhiri dengan format file (misal: “nama_file.txt”) yang akan di import ke dalam file. Dapat pula diisi lokasi file tersebut berada, misal:(C:/Users/My PC/Documents/nama_file.txt atau .csv)\rsep: pemisah antar kolom. “” digunakan untuk tab-delimited file.\rheader: nilai logik. jika TRUE, maka read.table() akan menganggap bahwa file yang akan dibaca pada baris pertama file merupakan header data.\rdec: karakter yang digunakan sebagai penunjuk desimal pada data.\r\r\rUntuk info lebih lanjut terkait fungsi-fungsi tersebut dan contoh bagaimana menggunakannya, pembaca dapat mengakses fitur batuan dari fungsi tersebut menggunakan sintaks berikut:\n# mengakses menu bantuan\r?read.table\r?read.csv\r?read.csv2\r?read.delim\r?read.delim2\rMisalkan penulis memiliki data pada file bernama “mtcars.csv” dengan desimal berupa titik pada datanya. Penulsi ingin membaca file tersebut, maka penulis akan menuliskan sintaks berikut:\ndata \u0026lt;- read.csv(\u0026quot;mtcars.csv\u0026quot;)\rSecara default perintah tersebut akan membaca baris pertama data sebagai header serta data berupa karakter menjadi factor. Untuk mencegah agar data berupa karakter menjadi faktor, perintah tersebut dapat ditambahkan parameter stringAsFactor = FALSE.\nKita juga dapat memilih file yang akan kita baca secara interakti. Misal pada working directory terdapat beberapa file yang akan kita baca. Kita ingin melihat file dengan format tertentu yang hendak kita baca, namun kita malas mengecek file explorer pada windows. Untuk mengatasi masalah tersebut, kita dapat menggunakan fungsi file.choose() pada R. Fungsi tersebut akan menampilkan jendela windows explores sehingga kita dapat memilih file apa yang hendak dibaca. Berikut adalah contoh penerapannya:\ndata \u0026lt;- read.csv(file.choose())\r\rNote:  pastikan format file yang dibaca sama dengan fungsi import yang digunakan.\n\rKita juga dapat membaca file dari internet. Untuk melakukannya kit hanya perlu meng-copy url file tersebut. Berikut adalah contoh file yang dibaca dari internet:\n# Membaca file dari internet\rdata \u0026lt;- read.delim(\u0026quot;http://www.sthda.com/upload/boxplot_format.txt\u0026quot;)\r# mengecek 6 observasi awal\rhead(data)\r## Nom variable Group\r## 1 IND1 10 A\r## 2 IND2 7 A\r## 3 IND3 20 A\r## 4 IND4 14 A\r## 5 IND5 14 A\r## 6 IND6 12 A\r\r3.1.2 Membaca File CSV dan TXT Menggunakan Library readr\rPada bagian sebelumnya kita telah belajar bagaimana cara membaca file dengan format CSV dan TXT menggunakan paket dasar R. Pada bagian ini penulis akan menjelaskan bagaimana cara membaca file dengan format TXT dan CSV pada R menggunakan paket readr.\nreadr dikembangkan oleh Hadley Wickham. paket readr memberikan solusi cepat dan ramah untuk membaca delimited file ke dalam R.\nDibandingkan dengan paket dasar R, readr memiliki kelebihan sebagai berikut:\n\rMampu membaca file 10x lebih cepat dibandingkan pada paket bawaan R.\rMenampilkan progress bar yang bermanfaat jika proses pemuatan berlangsung agak lama.\rsemua fungsi bekerja dengan cara yang persis sama dengan paket bawaan R.\r\rUntuk dapat menggunakan readr, kita perlu menginstall paketnya terlebih dahulu. Untuk melakukannya jalankan sintaks berikut:\n# Menginstall paket\rinstall.packages(\u0026quot;readr\u0026quot;)\r# Memuat paket\rlibrary(readr)\rBerikut adalah format bebrapa fungsi yang dapat digunakan:\n# Fungsi umum (membaca TXT dan CSV) dapat juga membaca flat file dan tsv\rread_delim(file, delim, col_names = TRUE)\r# Membaca comma (\u0026quot;,\u0026quot;) separated values\rread_csv(file, col_names = TRUE)\r# Membaca semicolon (\u0026quot;;\u0026quot;) separated values\rread_csv2(file, col_names = TRUE)\r# Membaca tab separated values\rread_tsv(file, col_names = TRUE)\r\rNote: \n\rfile: path file, koneksi atau raw vector. File yang berakhiran .gz, .bz2, .xz, atau .zip akan secara otomatis tidak terkompresi. File yang dimulai dengan “http: //”, “https: //”, “ftp: //”, atau “ftps: //” akan diunduh secara otomatis. File gz jarak jauh juga dapat diunduh \u0026amp; didekompresi secara otomatis.\rdelim: karakter yang membatasi tiap nilai pada file.\rcol_names: nilai logik. Jika TRUE, maka baris pertama akan menjadi header.\r\r\rBerikut adalah contoh bagaimana cara membaca file menggunakan fungsi pada paket readr:\n# Membaca file lokal\rdata \u0026lt;- read_csv(\u0026quot;mtcars.csv\u0026quot;)\r# atau\rdata \u0026lt;- read_csv(file.choose())\r# Membaca dari internet\rdata \u0026lt;- read_tsv(\u0026quot;http://www.sthda.com/upload/boxplot_format.txt\u0026quot;)\rKita juga dapat menspesifikasi jenis data pada kolom yang akan dibaca. Keuntungan dari penentuan jenis kolom (tipe data) akan memastikan data yang telah dibaca tidak salah berdasarkan jenis data pada masing-masing kolom.\nBeberapa format jenis kolom yang tersedia pada readr adalah sebagi berikut:\n\rcol_integer(): untuk menentukan integer (alias = “i”).\rcol_double(): untuk menentukan kolom sebagai jenis data double (alias = “d”).\rcol_logical(): untuk menentukan variabel logis (alias = “l”).\rcol_character(): meninggalkan string apa adanya.Tidak mengonversinya menjadi faktor (alias = “c”).\rcol_factor(): untuk menentukan variabel faktor (atau pengelompokan) (alias = “f”)\rcol_skip(): untuk mengabaikan kolom (alias = “-” atau “_“)\rcol_date() (alias = “D”), col_datetime() (alias = “T”) dan col_time() (“t”) untuk menentukan tanggal, waktu tanggal, dan waktu.\r\rBerikut adalah contoh penerapannya:\ndata \u0026lt;- read_csv(\u0026quot;my_file.csv\u0026quot;, col_types = cols(\rx = \u0026quot;i\u0026quot;, # kolom integer\rtreatment = \u0026quot;c\u0026quot; # kolom karakter/string\r))\r\r3.1.3 Import File Excel Pada R\rKeunggulan penggunaan excel sebagai format penyimpan data adalah kita dapat menyimpan banyak data dan memisahkannya pada lembar (sheet) yang berbeda sebagai suatu data yang independen dibandingkan pembacaan pada file csv yang hanya berisikan satu tabel data saja tiap file.\nPada R kita dapat melakukan pembacaan file menggunakan berbagai macam cara seperti menggunakan paket bawaan R maupun menggunakan library yang perlu kita install. Berikut adalah beberapa cara membaca file excel pada R.\nMengkonversi terlebih dahulu satu sheet excel yang akan kita baca menjadi format “.csv” maupun “.txt” sehingga dapat dibaca seperti pada sub-bab 3.1.1.\n\rMenyalin data dari excel dan mengimport data pada R.\n\r\rCara ini sedikit mirip dengan cara sebelumnya, dimana kita perlu membuka file excel dan melakukan select dan copy (ctrl+c) tabel data yang hendak dibaca. Data tersebut selanjutnya akan tersimpan pada clipboard.\nData yang telah tersalin selanjutnya diimport ke R dengan mengetikkan sintaks berikut:\ndata \u0026lt;- read.table(file= \u0026quot;clipboard\u0026quot;,\rsep = \u0026quot;\\t\u0026quot;, header = TRUE)\rCara ini merupakan cara yang paling sering penulis gunakan. Kelemahan penggunaan cara ini adalah ketika kita melakukan proses select dan copy (ctrl+c) tabel yang jumlahnya sangat banyak dan terdapat teks-teks penjelasan terkait tabel data pada lembar kerja excel yang tidak ingin kita sertakan akan memakan waktu yang lebih lama pada proses select.\nMengimport data menggunakan library readxl.\r\rPaket readxl, yang dikembangkan oleh Hadley Wickham, dapat digunakan untuk dengan mudah mengimpor file Excel (xls | xlsx) ke R tanpa ada ketergantungan eksternal.\nUntuk dapat menggunakan library readxl kita harus menginstallnya terlebih dahulu menggunakan sintaks berikut:\n# Instal paket\rinstall.packages(\u0026quot;readxl\u0026quot;)\r# memuat paket\rlibrary(readxl)\rBerikut adalah contoh cara mengimport data dengan format xls atau xlsx pada R.\n# Tentukan sheet dengan nama sheet pada file\rdata \u0026lt;- read_excel(\u0026quot;my_file.xlsx\u0026quot;, sheet = \u0026quot;data\u0026quot;)\r# Tentukan sheet berdasarkan indeks sheet\rdata \u0026lt;- read_excel(\u0026quot;my_file.xlsx\u0026quot;, sheet = 2) # membaca sheet ke-2\rMengimport data menggunakan library xlsx\r\rPaket xlsx, solusi berbasis java, adalah salah satu paket R yang ampuh untuk membaca, menulis, dan memformat file Excel. Untuk dapat menggunakannya kita harus menginstall dan memuatnya terlebih dahulu. Berikut sintaks yang digunakan:\n# Menginstall paket\rinstall.packages(\u0026quot;xlsx\u0026quot;)\r# Memuat paket\rlibrary(xlsx)\rTerdapat dua buah fungsi yang disediakan pada paket tersebut yaitu read.xlsx() dan read.xlsx2(). Perbedaan keduanya adalah read.xlsx2() digunakan pada file data dengan ukuran yang besar serta proses pembacaan data yang lebih cepat dibandingkan dengan read.xlsx(). Fromat yang digunakan untuk kedua fungsi tersebut disajikan sebagai berikut:\nread.xlsx(file, sheetIndex, header=TRUE)\rread.xlsx2(file, sheetIndex, header=TRUE)\r\rNote: \n\rfile: nama atau lokasi file berada\rsheetIndex: Indeks dari sheet yang hendak dibaca\rheader: nilai logik. Jika bernilai TRUE, maka baris pertama dari sheet menjadi header.\r\r\rBerikut adalah contoh penggunaanya:\ndata \u0026lt;- read.xlsx(file.choose(), 1) # membaca sheet 1\r\rNote:  kita juga dapat membaca file dari internet seperti pada sub-bab 3.1.1.\n\r\r3.1.4 Membaca File Dari Format Aplikasi Statistik\rUntuk membaca file yang berasal dari format aplikasi statistik seperti SPSS, SAS, dan STATA kita perlu menginstal dan memuat paket-paket yang dibutuhkan sesuai dengan file yang akan kita install. Berikut adalah sintaks bagaimana cara mengimport file dari berbagai format aplikasi statistik.\n# membaca file SPSS\rinstall.packages(\u0026quot;Hmisc\u0026quot;) # menginstall paket\rlibrary(Hmisc) # memuat paket\r# simpan SPSS dataset pada transport format\rget file=\u0026#39;c:\\mydata.sav\u0026#39;.\rexport outfile=\u0026#39;c:\\mydata.por\u0026#39;. data \u0026lt;- spss.get(\u0026quot;c:\\mydata.por\u0026quot;, use.value.labels= TRUE) # use.value.labels digunakan untuk mengubah label menjadi factor\r# membaca file SAS\rinstall.packages(\u0026quot;Hmisc\u0026quot;) # menginstall paket\rlibrary(Hmisc) # memuat paket\r# simpan SAS dataset pada transport format\rlibname out xport \u0026#39;c:/mydata.xpt\u0026#39;;\rdata out.mydata;\rset sasuser.mydata;\rrun;\rdata \u0026lt;- sasxport.get(\u0026quot;c:/mydata.xpt\u0026quot;) # Variabel yang berupa karakter akan dikonversi menjadi factor\r# membaca file STATA\rinstall.packages(\u0026quot;foreign\u0026quot;) # menginstall paket\rlibrary(foreign) # memuat paket\rdata \u0026lt;- read.dta(\u0026quot;c:/mydata.dta\u0026quot;)\r\r\r3.2 Eksport File\rSetelah kita melakukan analisa dan telah memperoleh hasil yang kita inginkan dan memperoleh data frame berupa hasil prediksi suatu model atau data yang telah dibersihakan, kita ingin melakukan pelaporan dalam bentuk file dengan format seperti EXCEL, CSV atau TXT. Untuk melakukannya kita perlu melakukan eksport data yang telah dihasilkan.\nPada bagian ini penulis akan menjelaskan bagaimana cara mengeksport data dari R kedalam format TXT, CSV, maupun EXCEL. Sebenarnya R memungkinkan untuk melakukan eksport dalam format lain seperti RDA maupun RDS yang tidak dibahas dalam buku ini karena berada diluar lingkup buku ini.\n3.2.1 Eksport Data Menjadi Format TXT dan CSV\rTerdapat dua cara untuk melakukan ekport data dari R menjadi format TXT atau CSV, yaitu melalui paket dasar R maupun menggunakan library readr. Kedua cara tersebut memiliki sejumlah kemiripan dari segi fungsi, namun berbeda dari segi kecepatan eksport.\nFungsi dasar yang digunakan pada R untuk melakukan eksport file kedalam format TXT dan CSv adalah write.tabel(). Format umum yang digunakan adalah sebagai berikut:\nwrite.table(x, file, sep= \u0026quot; \u0026quot;, dec = \u0026quot;,\u0026quot;,\rrow.names = TRUE, col.names = TRUE)\r\rNote: \n\rx: matriks atau data frame yang akan ditulis.\rfile: karakter yang menentukan nama file yang dihasilkan.\rsep: string pemisah bidang atau kolom, mis., sep = “ t” (untuk nilai yang dipisahkan tab).\rdec: string yang akan digunakan sebagai pemisah desimal. Standarnya adalah “.”.\rrow.names: nilai logik yang menunjukkan apakah nama baris x harus ditulis bersama dengan x, atau vektor karakter nama baris yang akan ditulis.\rcol.names: baik nilai logik yang menunjukkan apakah nama kolom x harus ditulis bersama dengan x, atau vektor karakter nama kolom yang akan ditulis. Jika col.names = NA dan row.names = TRUE ditambahkan nama kolom kosong, yang merupakan konvensi yang digunakan untuk file CSV untuk dibaca oleh spreadsheet.\r\r\rSelain menggunakan fungsi tersebut, untuk eksport ke dalam format CSV juga dapa menggunakan fungsi write.csv() atau write.csv2(). Berikut adalah format yang digunakan:\nwrite.csv(data, file=\u0026quot;data.csv\u0026quot;)\rwrite.csv2(data, file=\u0026quot;data.csv\u0026quot;)\rSecara penampakan kedua fungsi tersebut pada dasarnya sama dengan fungsi write.table(), bedanya adalah kedua fungsi tersebut spesifik digunakan untuk eksport file kedalam format CSV.\n\rNote: \n\rwrite.csv() menggunakan “.” sebagai titik desimal serta “,” sebagai pemisah antar kolom data.\rwrite.csv2() menggunakan “,” sebagai titik desimal serta “;” sebagai pemisah antar kolom data.\r\r\rMisalkan kita ingin melakukan eksport data objek mtcars kedalam format CSV. Untuk melakukannya dapat dilakukan dengan sintaks berikut:\nwrite.csv(mtcars, file=\u0026quot;mtcars.csv\u0026quot;, row.names = FALSE)\r\rNote:  Hasil ekspoet ditampilkan pada working directory\n\rKita juga dapat menggunakan fungsi write_delim() dari library readr untuk melakukan eksport data kedalam format CSV atau TXT. Berdasarkan format file yang hendak dihasilkan kita juga dapat menggunakan fungsi write_csv() atau write_tsv(). Berikut adalah penjelasan terkait kedua fungsi tersebut:\n\rwrite_csv(): untuk mengeksport kedalam format CSV.\rwrite_tsv(): untuk mengeksport kedalam format TXT.\r\rFormat sederhana ketiga fungsi fungsi tersebut adalah sebagai berikut:\n# Fungsi umum\rwrite_delim(x, path, delim = \u0026quot; \u0026quot;)\r# Write comma (\u0026quot;,\u0026quot;) separated value files\rwrite_csv(file, path)\r# Write tab (\u0026quot;\\t\u0026quot;) separated value files\rwrite_tsv(file, path)\r\rNote: \n\rx: data frame yang akan ditulis\rpath: path ke file hasil (dapat berupa nama file disertai ekstensi file yang akan dibuat)\rdelim: Delimiter digunakan untuk memisahkan nilai. Harus karakter tunggal.\r\r\rBerikut adalah contoh penerapan dari fungsi tersebut:\n# memuat mtcars data\rdata(mtcars)\rlibrary(readr)\r# eksport mtcars menjadi tsv atau txt\rwrite_tsv(mtcars, path = \u0026quot;mtcars.txt\u0026quot;)\r# eksport mycars menjadi csv\rwrite_csv(mtcars, path = \u0026quot;mtcars.csv\u0026quot;)\r\r3.2.2 Eksport Data Menjadi Format Excel\rUntuk mengeksport data menjadi format EXCEL (“.xls” atau “.xlsx”) kita dapat menggunakan fungsi write.xlsx() dan write.xlsx2() dari library xlsx. Berikut adalah format sederhana yanga digunakan:\nwrite.xlsx(x, file, sheetName = \u0026quot;Sheet1\u0026quot;, col.names = TRUE, row.names = TRUE, append = FALSE)\rwrite.xlsx2(x, file, sheetName = \u0026quot;Sheet1\u0026quot;,\rcol.names = TRUE, row.names = TRUE, append = FALSE)\r\rNote: \n\rx: sebuah data frame untuk ditulis ke dalam worksheet.\rfile: path ke file output.\rsheetName: string karakter yang digunakan untuk nama sheet.\rcol.names, row.names: nilai logik yang menentukan apakah nama kolom / nama baris x akan ditulis ke file.\rappend: nilai logis yang menunjukkan apakah x harus ditambahkan ke file yang ada.\r\r\rBerikut adalah contoh penerapannya:\nlibrary(\u0026quot;xlsx\u0026quot;)\r# Menuliskan dataset pertama pada workbook\rwrite.xlsx(USArrests, file = \u0026quot;myworkbook.xlsx\u0026quot;,\rsheetName = \u0026quot;USA-ARRESTS\u0026quot;, append = FALSE)\r# Menambahkan dataset kedua pada workbook\rwrite.xlsx(mtcars, file = \u0026quot;myworkbook.xlsx\u0026quot;, sheetName=\u0026quot;MTCARS\u0026quot;, append=TRUE)\r# Menambahkan dataset kedua pada workbook\rwrite.xlsx(iris, file = \u0026quot;myworkbook.xlsx\u0026quot;,\rsheetName=\u0026quot;IRIS\u0026quot;, append=TRUE)\r\r\r3.3 Tibble Data Format\rTibble adalah data frame yang menyediakan metode print yang lebih bagus, berguna saat bekerja dengan kumpulan data besar. Pada bagian ini penulis akan menjelaskan penggunaan tibble sebagai alternatif kita dalam berinteraksi dengan data frame.\nUntuk membuat tibble kita perlu menginstall dan memuat library tibble yang dikembangkan oleh Hadley Wichham. Berikut adalah sintaks yang digunakan:\n# menginstall paket\rinstall.packages(\u0026quot;tibble\u0026quot;)\r# memuat paket\rlibrary(tibble)\r3.3.1 Membuat Tibble\rUntuk dapat membuat tibble kita dapat melakukan konversi data frame yang sudah ada menjadi tibble menggunakan fungsi as_tibble(). Berikut adalah contoh bagaimana membuat tibble mengunakan data iris:\n## Warning: package \u0026#39;tibble\u0026#39; was built under R version 3.5.3\r# memuat data mtcars\rdata(\u0026quot;iris\u0026quot;)\r# print\rhead(iris, 10)\r## Sepal.Length Sepal.Width Petal.Length Petal.Width Species\r## 1 5.1 3.5 1.4 0.2 setosa\r## 2 4.9 3.0 1.4 0.2 setosa\r## 3 4.7 3.2 1.3 0.2 setosa\r## 4 4.6 3.1 1.5 0.2 setosa\r## 5 5.0 3.6 1.4 0.2 setosa\r## 6 5.4 3.9 1.7 0.4 setosa\r## 7 4.6 3.4 1.4 0.3 setosa\r## 8 5.0 3.4 1.5 0.2 setosa\r## 9 4.4 2.9 1.4 0.2 setosa\r## 10 4.9 3.1 1.5 0.1 setosa\r# konversi mtcars menjadi tibble\riris_tbl \u0026lt;- as_tibble(iris)\r# print\riris_tbl\r## # A tibble: 150 x 5\r## Sepal.Length Sepal.Width Petal.Length Petal.Width Species\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows\r\rNote:  Kita dapat mengkonversi tibble menjadi data frame menggunakan fungsi as.data.frame()\n\rSecara default saya kita print tibble, maka akan dimunculkan 10 observasi pertama. Pada data frame biasa jika kita print data tersebut maka seluruh observasi akan ditampilkan.\nPenggunaan tibble ini cenderung menguntungkan saat kita bekerja dengan jumlah data yang besar dan ingin mengecek observasi yang ada. Hal ini berbeda dengan data frame biasa dimana untuk mengecek observasi awal kita perlu menggunakan fungsi head() agar seluruh data tidak ditampilkan. Sehingga penggunaan tibble cenderung membuat proses analisa menjadi lebih rapi.\nKita juga dapat membuat tibble dari kumpulan sejumlah vektor menggunakan fungsi tibble(). tibble() akan secara otomatis mendaur ulang input dengan panjang 1 (variabel y), dan memungkinkan kita untuk merujuk ke variabel yang baru saja kita buat, seperti yang ditunjukkan pada sintaks berikut:\ntibble(\rx = 1:20,\ry = 1,\rz = 2*x+5*y\r)\r## # A tibble: 20 x 3\r## x y z\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 1 1 7\r## 2 2 1 9\r## 3 3 1 11\r## 4 4 1 13\r## 5 5 1 15\r## 6 6 1 17\r## 7 7 1 19\r## 8 8 1 21\r## 9 9 1 23\r## 10 10 1 25\r## 11 11 1 27\r## 12 12 1 29\r## 13 13 1 31\r## 14 14 1 33\r## 15 15 1 35\r## 16 16 1 37\r## 17 17 1 39\r## 18 18 1 41\r## 19 19 1 43\r## 20 20 1 45\rJika pembaca telah mulai familiar dengan fungsi data.frame(), perlu diingat bahwa tibble() melakukan lebih sedikit: tidak pernah mengubah jenis input (mis., tidak pernah mengubah string menjadi faktor!), tidak pernah mengubah nama variabel, dan tidak pernah membuat nama baris seperti yang biasa terjadi saat kita menggunakan fungsi data.frame().\nCara lain yang dapat digunakan untuk membuat tibble adalah dengan menggunakan fungsi tribble() yang merupakan singkatan dari transposed tibble. tribble() dikustomisasi untuk entri data dalam kode: judul kolom didefinisikan oleh rumus (yaitu, mereka mulai dengan ~), dan entri dipisahkan oleh koma. Hal ini memungkinkan untuk menata sejumlah kecil data dalam bentuk yang mudah dibaca. Berikut adalah contoh penerapannya:\ntribble(\r~x, ~y, ~z,\r#--/--/----\r\u0026quot;a\u0026quot;, 2, 5,\r\u0026quot;b\u0026quot;, 5, 7\r)\r## # A tibble: 2 x 3\r## x y z\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 a 2 5\r## 2 b 5 7\rPenambahahan komen (#–/–/—-) dilakukan untuk memperjelas posisi dari header sehingga meminimalisir kesalahan dalam input data.\n\r3.3.2 Tibble vs Data Frame\rterdapat dua buah perbedaan utama antara tibble dan data frame , yaitu: printing dan subsetting.\nPrinting\r\rTibbles memiliki metode print halus yang hanya menampilkan 10 baris pertama observasi, dan semua kolom yang sesuai dengan lebar layar. Ini membuatnya lebih mudah untuk bekerja dengan data besar. Selain namanya, setiap kolom melaporkan jenis datanya, fitur bagus yang dipinjam dari fungsi str(). Berikut adalah contohnya:\ntribble(\r~x, ~y, ~z,\r#--/---/--------\r\u0026quot;a\u0026quot;, 2.1, FALSE,\r\u0026quot;b\u0026quot;, 5.5, TRUE\r)\r## # A tibble: 2 x 3\r## x y z ## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;lgl\u0026gt;\r## 1 a 2.1 FALSE\r## 2 b 5.5 TRUE\rTibbles dirancang agar kita tidak secara sengaja menampilkan data yang sangat banyak saat melakukan perintah print(). Tetapi terkadang kita membutuhkan lebih banyak output daripada tampilan default. Ada beberapa opsi yang dapat membantu.\nPertama, kita dapat secara eksplisit melakukan print data frame dan mengontrol jumlah baris (n) dan lebar tampilan. width = Inf akan menampilkan semua kolom. Berikut adalah contoh penerapannya\nprint(iris_tbl, n=15, width=Inf)\r## # A tibble: 150 x 5\r## Sepal.Length Sepal.Width Petal.Length Petal.Width Species\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## 11 5.4 3.7 1.5 0.2 setosa ## 12 4.8 3.4 1.6 0.2 setosa ## 13 4.8 3 1.4 0.1 setosa ## 14 4.3 3 1.1 0.1 setosa ## 15 5.8 4 1.2 0.2 setosa ## # ... with 135 more rows\rKita juga dapat mengontrol print default dengan melakukan pengaturan menggunakan fungsi options(). Berikut adalah contoh penerapannya:\n\roptions(tibble.print_max= n, tibble.print_min= m): jika terdapat lebih dari “m” baris, print hanya sejumlah “n” baris.\roptions(dplyr.print_min = Inf): untuk selalu menampilkan seluruh baris. Perlu diingat fungsi ini dapat digunakan saat kita telah memuat library dplyr.\roptions(tibble.width = Inf): menampilkan seluruh kolom tanpa mempedulikan lebar tampilan layar.\r\rCara terakhir untuk menampilkan seluruh observasi adalh dengan fungsi view(). Berikut adalah contoh penerapannya pada data iris_tbl:\nview(iris_tbl)\rSubsetting\r\rSejauh ini semua alat yang kita pelajari telah bekerja dengan data frame yang lengkap. Jika kita ingin mengeluarkan variabel tunggal, kita memerlukan beberapa alat baru, dollar sign ($) dan [[. [[dapat mengekstraksi berdasarkan nama atau posisi; $ hanya mengekstraksi berdasarkan nama. Berikut adalah contoh penerapannya:\n# print tibble\riris_tbl\r## # A tibble: 150 x 5\r## Sepal.Length Sepal.Width Petal.Length Petal.Width Species\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows\r# subset berdasarkan nama kolom\riris_tbl$Sepal.Length\r## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4\r## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5\r## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0\r## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8\r## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4\r## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8\r## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7\r## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7\r## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9\r#subset berdasarkan posisi\riris_tbl[[1]]\r## [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4\r## [18] 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5\r## [35] 4.9 5.0 5.5 4.9 4.4 5.1 5.0 4.5 4.4 5.0 5.1 4.8 5.1 4.6 5.3 5.0 7.0\r## [52] 6.4 6.9 5.5 6.5 5.7 6.3 4.9 6.6 5.2 5.0 5.9 6.0 6.1 5.6 6.7 5.6 5.8\r## [69] 6.2 5.6 5.9 6.1 6.3 6.1 6.4 6.6 6.8 6.7 6.0 5.7 5.5 5.5 5.8 6.0 5.4\r## [86] 6.0 6.7 6.3 5.6 5.5 5.5 6.1 5.8 5.0 5.6 5.7 5.7 6.2 5.1 5.7 6.3 5.8\r## [103] 7.1 6.3 6.5 7.6 4.9 7.3 6.7 7.2 6.5 6.4 6.8 5.7 5.8 6.4 6.5 7.7 7.7\r## [120] 6.0 6.9 5.6 7.7 6.3 6.7 7.2 6.2 6.1 6.4 7.2 7.4 7.9 6.4 6.3 6.1 7.7\r## [137] 6.3 6.4 6.0 6.9 6.7 6.9 5.8 6.8 6.7 6.7 6.3 6.5 6.2 5.9\rDibandingkan dengan data frame, tibble lebih ketat: tibble tidak pernah melakukan partial matching, dan mereka akan menghasilkan peringatan jika kolom yang kita coba akses tidak ada.\n\r\r3.4 Merapikan Data\rSebelum memulai analisa terhadap data yang kita miliki, umumnya kita akan merapikan data yang akan kita gunakan. Tujuannya adalah agar data yang akan digunakan sudah siap untuk dilakukan analisa dengan software tertentu seperti R, dimana pada dataset perlu jelas antara variabel dan nilai (value), serta untuk mempermudah dalah memperoleh informasi pada data. Berikut adalah beberapa contoh dataset yang dapat pembaca cermati terkait manakah data yang telah rapi (tidy data) dan mana yang belum (messy data):\n# Install paket dataset EDAWR\r# install.packages(\u0026quot;devtools\u0026quot;)\r# devtools::install_github(\u0026quot;rstudio/EDAWR\u0026quot;)\r# hilangkan tanda # jika pembaca belum menginstall\rlibrary(EDAWR)\r# memuat dataset\rstorms\r## storm wind pressure date\r## 1 Alberto 110 1007 2000-08-03\r## 2 Alex 45 1009 1998-07-27\r## 3 Allison 65 1005 1995-06-03\r## 4 Ana 40 1013 1997-06-30\r## 5 Arlene 50 1010 1999-06-11\r## 6 Arthur 45 1010 1996-06-17\rcases\r## country 2011 2012 2013\r## 1 FR 7000 6900 7000\r## 2 DE 5800 6000 6200\r## 3 US 15000 14000 13000\rpollution\r## city size amount\r## 1 New York large 23\r## 2 New York small 14\r## 3 London large 22\r## 4 London small 16\r## 5 Beijing large 121\r## 6 Beijing small 56\rSebelum kita melakukan analisa di dataset tersebut, kita harus tahu terlebih dahulu apa saja syarat suatu dataset dikatakan rapi (tidy). Berikut adalah syaratnya:\n\rSetiap variabel harus memiliki kolomnya sendiri\rSetiap observasi harus memiliki barisnya sendiri\rSetiap nilai berada pada sel tersendiri\r\rKetiga syarat tersebut saling berhubungan sehingga jika salah satu syarat tersebut tidak terpenuhi, maka dataset belum bisa dikatakan tidy. Ketiga syarat tersebut dapat divisualisasikan melalui Figure 1\n## Warning: package \u0026#39;knitr\u0026#39; was built under R version 3.5.3\r\rFigure 1: Visualisasi 3 rule tidy data\r\rPada dataset storms terdapat 4 buah kolom dan 6 buah baris. Masing-masing kolom menyatakan variabel pada masing-masing observasi seperti nama badai , kecepatan angin, tekanan dan waktu . Ketiga syarat kerapihan data sudah terpenuhi pada data tersebut sehingga kita bisa melakukan analisa terhadap data tersebut, misalnya kecepatan angin dan tekanan pada masing-masing badai. Selain itu kita juga dapat dengan mudah menginput variabel baru pada dataset tersebut, misal: rasio (kecepatan angin/tekanan).\nBerikut adalah contoh bagaimana kita dapat dengan mudah menarik nilai variabel pada masing-masing kolom dan membentuk variabel baru pada dataset tersebut:\n# subset variabel\rstorms$storm\r## [1] \u0026quot;Alberto\u0026quot; \u0026quot;Alex\u0026quot; \u0026quot;Allison\u0026quot; \u0026quot;Ana\u0026quot; \u0026quot;Arlene\u0026quot; \u0026quot;Arthur\u0026quot;\rstorms$wind\r## [1] 110 45 65 40 50 45\rstorms$pressure\r## [1] 1007 1009 1005 1013 1010 1010\rstorms$date\r## [1] \u0026quot;2000-08-03\u0026quot; \u0026quot;1998-07-27\u0026quot; \u0026quot;1995-06-03\u0026quot; \u0026quot;1997-06-30\u0026quot; \u0026quot;1999-06-11\u0026quot;\r## [6] \u0026quot;1996-06-17\u0026quot;\r# membuat variabel baru\rstorms_new \u0026lt;- storms\rstorms_new$ratio \u0026lt;- storms_new$wind/storms_new$pressure\rstorms_new\r## storm wind pressure date ratio\r## 1 Alberto 110 1007 2000-08-03 0.10923535\r## 2 Alex 45 1009 1998-07-27 0.04459861\r## 3 Allison 65 1005 1995-06-03 0.06467662\r## 4 Ana 40 1013 1997-06-30 0.03948667\r## 5 Arlene 50 1010 1999-06-11 0.04950495\r## 6 Arthur 45 1010 1996-06-17 0.04455446\rPada dataset cases terdapat 3 buah kolom dan 3 baris. Pada kolom pertama berupa kode Negara, sedangkan kolom sisanya merupakan tahun. Jika kita perhatikan dengan seksama dataset tersebut merupakan sebuah contingency table dimana tabel tersebut menyatakan frekuensi kejadian pada tahun tertentu dan negara tertentu. Dataset tersebut belum dapat dikatan tidy karena kolom 2011 sampai 2013 merupakan sebuah nilai dari observasi dan bukan sebuah variabel sehingga dataset tersebut masih tergolong dataset messy. Selain itu sangat sulit untuk dilakukan penarikan terhadap nilai pada setiap kolom serta pembentukan variabel baru sebagai pendukung analisa juga sulit dilakukan. Berikut adalah contoh melakukan penarikan nilai / subset pada masing variabel:\ncases$country\r## [1] \u0026quot;FR\u0026quot; \u0026quot;DE\u0026quot; \u0026quot;US\u0026quot;\rnames(cases[-1])\r## [1] \u0026quot;2011\u0026quot; \u0026quot;2012\u0026quot; \u0026quot;2013\u0026quot;\runlist(cases[1:3, 2:4])\r## 20111 20112 20113 20121 20122 20123 20131 20132 20133 ## 7000 5800 15000 6900 6000 14000 7000 6200 13000\rPada dataset pollutionterdapat 3 buah kolom dan 6 baris. Masing-masing kolom menyatakan lokasi berupa nama kota, keterangan ukuran partikel, serta nilai dari ukuran partikel. Beberapa dari kita mungkin menganggap dataset ini telah memenuhi syarat kerapihan data. Namun, coba kita cermati jika mita ingin membuat variabel baru terkait dengan berapa rentang ukuran partikel (range ukuran partikel) pada masing-masing kota. Hal tersebut tentu sangat sulit dilakukan pada dataset tersebut, namun dataset tersebut memungkinkan kita dengan mudah mengambil nilai dari masing-masing variabelnya seperti contoh berikut:\npollution$city\r## [1] \u0026quot;New York\u0026quot; \u0026quot;New York\u0026quot; \u0026quot;London\u0026quot; \u0026quot;London\u0026quot; \u0026quot;Beijing\u0026quot; \u0026quot;Beijing\u0026quot;\rpollution$size\r## [1] \u0026quot;large\u0026quot; \u0026quot;small\u0026quot; \u0026quot;large\u0026quot; \u0026quot;small\u0026quot; \u0026quot;large\u0026quot; \u0026quot;small\u0026quot;\rpollution$amount\r## [1] 23 14 22 16 121 56\rBerdasarkan contoh-contoh tersebut pada pembahasan kali ini penulis akan menjelaskan bagaiman cara melakukan perapihan data menggunakan library tidyr. Sebelum kita melakukannya berikut adalah sintaks untuk menginstall library tersebut:\n# memasang paket\rinstall.packages(\u0026quot;tidyr\u0026quot;)\r# memuat paket\rlibrary(tidyr)\r## Warning: package \u0026#39;tidyr\u0026#39; was built under R version 3.5.3\r3.4.1 Gather\rPada dataset cases kolom 2011 sampai 2013 perlu dijadikan satu variabel yaitu tahun. untuk melakukannya kita dapat menggunakan fungsi gather(). Secara sederhana fungsi tersebut dapat dituliskan dengan format sebagai berikut:\ngather(data, key, value, ...)\r\rNote: \n\rdata: data frame\rkey, value: nama kunci dan kolom nilai yang akan dibuat di output\r…: Spesifikasi kolom untuk dikumpulkan. Nilai yang diizinkan adalah:\r\rnama variabel\rjika kita ingin memilih semua variabel antara a dan e, gunakan a:e\rjika kita ingin mengecualikan nama kolom y gunakan -y\runtuk opsi lainnya, lihat: dplyr::select()\r\r\r\rBerikut adalah contoh penerapannya pada dataset cases:\n# Ubah dataset cases menjadi tibble simpan sebagai objek cases_new\rlibrary(tibble)\rcases_tbl \u0026lt;- as_tibble(cases)\r# print\rcases_tbl\r## # A tibble: 3 x 4\r## country `2011` `2012` `2013`\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 FR 7000 6900 7000\r## 2 DE 5800 6000 6200\r## 3 US 15000 14000 13000\r# gather\rcases_new \u0026lt;- gather(cases_tbl, # variabel kunci\rkey = \u0026quot;year\u0026quot;,\r# nilai variabel\rvalue = \u0026quot;frequency\u0026quot;,\r# kecualikan kolom country\r-country)\r# print\rcases_new\r## # A tibble: 9 x 3\r## country year frequency\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 FR 2011 7000\r## 2 DE 2011 5800\r## 3 US 2011 15000\r## 4 FR 2012 6900\r## 5 DE 2012 6000\r## 6 US 2012 14000\r## 7 FR 2013 7000\r## 8 DE 2013 6200\r## 9 US 2013 13000\rBerdasarkan hasil yang diperoleh terlihat bahwa variabel tahun memiliki jenis data karakter. Jenis data ini masih belum sesuai sehingga perlu dikonversi agar menjadi jenis data numerik (dbl = double). Untuk melakukannya jalankan sintaks berikut:\n# Ubah jenis variabel tahun menjadi numerik\rcases_new$year \u0026lt;- as.numeric(cases_new$year)\rcases_new\r## # A tibble: 9 x 3\r## country year frequency\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 FR 2011 7000\r## 2 DE 2011 5800\r## 3 US 2011 15000\r## 4 FR 2012 6900\r## 5 DE 2012 6000\r## 6 US 2012 14000\r## 7 FR 2013 7000\r## 8 DE 2013 6200\r## 9 US 2013 13000\rData yang diperoleh sekaran telah rapi (tidy), sehingga sudah siap untuk dilakukan analisa data.\n\r3.4.2 Spread\rFungsi spread() berkebalikan dengan gather(). Fungsi gather() menggabungkan beberapa kolom menjadi 2 buah kolom kolom kunci sedangkan spread() merubah dua kolom menjadi beberapa kolom. Format sederhanya adalah sebagai berikut:\n\rNote: \n\rdata: data frame\rkey: nama kolom yang akan dijadikan heading pada kolom baru\rvalue: nama kolom yang nilainya akan mengisi setiap sel\r\r\rPada contoh kasus pada data pollution, kita dapat memisahkan kolom 2 menjadi kolom baru yaitu kolom big size dan small size. Untuk melakukannya jalankan sintaks berikut:\n# merubah objek pollution menjadi tibble\rpollution_tbl \u0026lt;- as_tibble(pollution)\r# print\rpollution_tbl\r## # A tibble: 6 x 3\r## city size amount\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 New York large 23\r## 2 New York small 14\r## 3 London large 22\r## 4 London small 16\r## 5 Beijing large 121\r## 6 Beijing small 56\r# spread\rpollution_new \u0026lt;- spread(pollution_tbl,\rkey = size,\rvalue = amount)\r#print\rpollution_new\r## # A tibble: 3 x 3\r## city large small\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Beijing 121 56\r## 2 London 22 16\r## 3 New York 23 14\rTerlihat bahwa data pollution tampak memnuhi syarat kerapihan data (tidy). Kita sekarang dapat menginput variabel baru dan melakukan analisa terhadap data tersebut. Berikut adalah contoh penerapannya:\n# input variabel range (large-small)\rpollution_new$range \u0026lt;- pollution_new$large - pollution_new$small\r# print\rpollution_new\r## # A tibble: 3 x 4\r## city large small range\r## \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 Beijing 121 56 65\r## 2 London 22 16 6\r## 3 New York 23 14 9\rBerdasarkan hasil yang diperoleh diketahui bahwa nilai range ukuran partikel terbesar berada di Kota Beijing.\n\r3.4.3 Separate\rFungsi separate() merupakan fungsi yang digunakan untuk memisahkan sejumlah nilai pada sebuah kolom menjadi beberapa kolom berdasarkan karakter pemisah yang ada di dalam nilai suatu kolom. Fungsi ini berbeda dengan fungsi sebelumnya seperti gather() dan spread() yang menggabung atau memisahkan 2 atau beberapa kolom. Format sederhana fungsi separate() adalah sebagai berikut:\nseparate(data, col, into, sep = \u0026quot;[^[:alnum:]]+\u0026quot;, convert= TRUE)\r\rNote: \n\rdata: data frame.\rcol: Nama kolom yang tidak dikutip.\rinto: Vektor karakter menentukan nama variabel baru yang akan dibuat.\rsep: Pemisah antar kolom:\rJika karakter, diartikan sebagai ekspresi reguler. Jika numerik, diartikan sebagai posisi untuk dibelah. Nilai-nilai positif mulai dari 1 di ujung kiri string; nilai negatif mulai dari -1 di ujung kanan string.\rconvert: nilai logik. Jika bernilai TRUE maka kolom baru yang akan diperoleh akan dikonversi berdasarkan jenis data yang seharusnya.\r\r\rPada dataset storms kita ingin memisahkan kolom date menjadi beberapa kolom seperti year, month, dan day, Kita dapat menggunakan fungsi separate() untuk memisahkan nilai pada kolom tersebut berdasarkan karakter pemisah pada nilai kolom tersebut dalam hal ini adalah “-”. Berikut adalah cara melakukannya:\n# merubah storms menjadi tibble\rstorms_tbl \u0026lt;- as_tibble(storms)\r# print\rstorms_tbl\r## # A tibble: 6 x 4\r## storm wind pressure date ## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;date\u0026gt; ## 1 Alberto 110 1007 2000-08-03\r## 2 Alex 45 1009 1998-07-27\r## 3 Allison 65 1005 1995-06-03\r## 4 Ana 40 1013 1997-06-30\r## 5 Arlene 50 1010 1999-06-11\r## 6 Arthur 45 1010 1996-06-17\r# separate\rstorms_new \u0026lt;- separate(storms_tbl,\rcol = date,\rinto = c(\u0026quot;year\u0026quot;,\u0026quot;month\u0026quot;,\u0026quot;days\u0026quot;),\rsep = \u0026quot;-\u0026quot;,\rconvert = TRUE)\r# print\rstorms_new\r## # A tibble: 6 x 6\r## storm wind pressure year month days\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 Alberto 110 1007 2000 8 3\r## 2 Alex 45 1009 1998 7 27\r## 3 Allison 65 1005 1995 6 3\r## 4 Ana 40 1013 1997 6 30\r## 5 Arlene 50 1010 1999 6 11\r## 6 Arthur 45 1010 1996 6 17\rBerdasarkan hasil yang diperoleh terlihat bahwa data telah terpisah dengan benar yang ditunjukkan dari nilai yang terpisah dan jenis data yang dihasilkan.\n\r3.4.4 Unite\rFungsi unite() merupakan kebalikan dari fungsi separate(), dimana fungsi ini menggabungkan sejumlah kolom menjadi 1 kolom. Format sederhana untuk melakukanya disajikan sebagai berikut:\nunite(data, col, ..., sep = \u0026quot;_\u0026quot;)\r\rNote: \n\rdata: data frame.\rcol: nama kolom baru (tanpa tanda kutip) untuk ditambahkan.\rsep: pemisah yang akan digunakan pada antar nilai.\r\r\rPada dataset storms_new kita ingin menggabungkan kembali kolom year, month, dan days dengan karakter pemisah “/”. Berikut adalah cara melakukannya:\n# unite\rstorms_old \u0026lt;- unite(storms_new,\rcol = \u0026quot;date\u0026quot;,\ryear, month, days,\rsep = \u0026quot;-\u0026quot;)\r# print\rstorms_old\r## # A tibble: 6 x 4\r## storm wind pressure date ## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;chr\u0026gt; ## 1 Alberto 110 1007 2000-8-3 ## 2 Alex 45 1009 1998-7-27\r## 3 Allison 65 1005 1995-6-3 ## 4 Ana 40 1013 1997-6-30\r## 5 Arlene 50 1010 1999-6-11\r## 6 Arthur 45 1010 1996-6-17\r# ubah jenis kolom menjadi date\rstorms_old$date \u0026lt;- as.Date(storms_old$date)\r# print\rstorms_old\r## # A tibble: 6 x 4\r## storm wind pressure date ## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;date\u0026gt; ## 1 Alberto 110 1007 2000-08-03\r## 2 Alex 45 1009 1998-07-27\r## 3 Allison 65 1005 1995-06-03\r## 4 Ana 40 1013 1997-06-30\r## 5 Arlene 50 1010 1999-06-11\r## 6 Arthur 45 1010 1996-06-17\r\r\r3.5 Transformasi Data\rData frame merupakan struktur data utama dalam statistik dan dalam R. Struktur dasar data frame ialah ada satu observasi tiap baris dan setiap kolom mewakili variabel, ukuran, fitur, atau karakteristik pengamatan itu yang telah dijelaskan pada bagian sebelumya. R memiliki implementasi internal data frame yang kemungkinan besar akan kita gunakan paling sering. Namun, ada paket di CRAN yang mengimplementasikan data frame layaknya basis data relasional yang memungkinkan kita untuk beroperasi pada data frame yang sangat besar.\nMengingat pentingnya mengelola dat frame, penting bagi kita untuk memiliki alat yang baik untuk melakukannya. R memiliki beberapa paket seperti fungsi subset() dan penggunaan operator “[” dan “$” untuk mengekstrak himpunan bagian dari frame data. Namun, operasi lain, seperti pemfilteran, pengurutan, dan pengelompokan data, seringkali dapat menjadi operasi yang membosankan di R yang sintaksisnya tidak terlalu intuitif. Paket dplyr dirancang untuk mengurangi banyak masalah ini dan menyediakan serangkaian rutinitas yang dioptimalkan secara khusus untuk menangani data frame.\n3.5.1 Paket dplyr\rPaket dplyr dikembangkan oleh Hadley Wickham dari RStudio dan merupakan versi yang dioptimalkan dari paket plyr-nya. Paket dplyr tidak menyediakan fungsionalitas baru untuk R sendiri, dalam arti bahwa semua yang dilakukan dplyr sudah dapat dilakukan dengan fungsi basis R, tetapi sangat menyederhanakan fungsi yang ada di R.\nSalah satu kontribusi penting dari paket dplyr adalah ia menyediakan “grammar” (khususnya, kata kerja) untuk manipulasi data dan untuk beroperasi pada data frame. Melalui grammar ini, kita dapat berkomunikasi dengan masuk akal apa yang telah kita lakukan terhadap data frame dapat pula dipahami orang lain (dengan asumsi mereka juga tahu grammar-nya). Hal ini berguna karena memberikan abstraksi untuk manipulasi data yang sebelumnya tidak ada. Kontribusi lain yang bermanfaat adalah bahwa fungsi dplyr sangat cepat, karena banyak operasi utama dikodekan dalam C++.\nPada bagian ini pembaca akan belajar 6 fungsi utama yang ada pada paket dplyr. Fungsi tersebut antara lain:\nMengambil sejumlah observasi berdasarkan nilainya (filter()).\rMengurutkan kembali baris data frame berdasarkan nilai pada sebuah atau beberapa variabel (arrange()).\rMengambil atau subset terhadap sebuah atau beberapa variabel berdasarkan nama variabel/kolom (select()).\rMembuat variabel baru atau menambahkan kolom baru (mutate()).\rMembuat ringkasan terhadap data frame (summarize())\rMengelompokkan operasi berdasarkan grup data (group_by()).\r\rKeseluruhan fungsi tersebut format fungsi yang seragam, yaitu:\nArgumen pertama adalah data frame.\rArgumen selanjutnya adalah deskripsi yang akan dilakukan terhadap data frame (filter, pengurutan kembali, membuat ringkasan, dll) menggunakan nama variabel (tanpa tanda kutip).\rHasil operasi yang diperoleh adalah data frame baru.\r\rUntuk menginstall dan memuat paket dplyr jalankan sintaks berikut:\n# Memasang paket\rinstall.packages(\u0026quot;dplyr\u0026quot;)\r# memuat paket\rlibrary(dplyr)\r\r3.5.2 filter()\rFungsi filter() digunakan untuk mengekstrak himpunan bagian (subset) baris dari data frame. Fungsi ini mirip dengan fungsi subset() yang ada di R. Secara sederhana format fungsi filter() dapat dituliskan sebagai berikut:\nfilter(data, ....)\r\rNote: \n\rdata : data frame\r…. : Predikat logis didefinisikan dalam istilah variabel dalam data. Beberapa kondisi digabungkan dengan \u0026amp; (lihat Chapter 2 opeator relasi dan operator logika. Hanya baris tempat kondisi bernilai TRUE disimpan.\r\r\rMisalkan kita akan melakukan melakukan filter terhadap data frame pollution_tbl terhadap variabel size dengan kriteria large dan amount \u0026gt; 12. Berikut adalah sintaks yang digunakan:\nfilter(pollution_tbl, size==\u0026quot;large\u0026quot; \u0026amp; amount \u0026gt; 12)\r## # A tibble: 3 x 3\r## city size amount\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 New York large 23\r## 2 London large 22\r## 3 Beijing large 121\rJika menggunakan paket dasar R:\nsubset(pollution_tbl,size==\u0026quot;large\u0026quot; \u0026amp; amount \u0026gt; 12)\r## # A tibble: 3 x 3\r## city size amount\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 New York large 23\r## 2 London large 22\r## 3 Beijing large 121\rOperator “\u0026gt;” merupakan operator relasi (lihat chapter 2: operator relasi). Operator tersebut banyak digunakan untuk melakukan filter terhadap variabel/kolom yang mengandung nilai numerik.\nOperator “==” merupakan operator logika (lihat chapter 2: operator logika). Operator tersebut digunakan untuk melakukan filter terhadap sejumlah syarat atau kondisi yang kita tetapkan. Jika nilai yang dihasilkan TRUE, maka hanya observasi tersebut yang akan ditampilkan. Untuk lebih memahami penerapan masing-masing operator logika pada proses filter perhatikan Figure 2 berikut:\n\rFigure 2: Diagram operasi Boolean\r\r\rNote:  Bagian yang di arsir adalah observasi yang akan ditampilkan pada output.\n\rSalah satu bagian terpenting dan paling sering penulis gunakan pada fungsi ini memfilter missing value (melihat observasi yang mengandung missing value atau tidak melibatkan missing value). Berikut adalah contoh filter terhadap data pada pollution_tbl yang tidak mengandung missing value dan nilai amount\u0026gt;0.\nfilter(pollution_tbl,!(is.na(amount)|amount\u0026lt;=0))\r## # A tibble: 6 x 3\r## city size amount\r## \u0026lt;chr\u0026gt; \u0026lt;chr\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 New York large 23\r## 2 New York small 14\r## 3 London large 22\r## 4 London small 16\r## 5 Beijing large 121\r## 6 Beijing small 56\rBerdasarkan hasil yang diperoleh seluruh data tidak ada yang di drop sehingga dapat disimpulkan bahwa data tersebut tidak mengandung missing value dan nol.\n\r3.5.3 arrange()\rFungsi arrange() bekerja mirip dengan fungsi filter() kecuali bahwa alih-alih memilih baris, fungsi ini mengubah urutan observasinya (mengurutkan dari yang terbesar atau sebaliknya). Dibutuhkan data frame dan sekumpulan nama kolom (atau ekspresi yang lebih rumit) untuk dipesan. Jika kita memberikan lebih dari satu nama kolom pada fungsi, setiap kolom tambahan akan digunakan untuk menentukan urutan nilai yang sama berdasarkan nilai kolom sebelumnya.\nFungsi arrange() mirip dengan fungsi order() pada paket dasar R. Format sederhana fungsi ini adalah sebagai berikut:\narrange(data, ....)\r\rNote: \n\rdata : data frame\r…. : daftar nama variabel yang tidak dikutip yang dipisahkan tanda koma, atau ekspresi yang melibatkan nama variabel. Gunakan desc() untuk mengurutkan variabel dalam urutan menurun.\r\r\rMisalkan kita ingin melihat urutan mobil pada data mtcars berdasarkan penggunaan bahan bakar (mpg) dan bobot mobil (wt) tersebut. Berikut adalah sintaks yang digunakan:\ndata(\u0026quot;mtcars\u0026quot;)\r# Ubah mtcars menjadi tibble\rmtcars\u0026lt;- as_tibble(mtcars)\rarrange(mtcars, mpg, wt)\r## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4\r## 2 10.4 8 460 215 3 5.42 17.8 0 0 3 4\r## 3 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4\r## 4 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 5 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4\r## 6 15 8 301 335 3.54 3.57 14.6 0 1 5 8\r## 7 15.2 8 304 150 3.15 3.44 17.3 0 0 3 2\r## 8 15.2 8 276. 180 3.07 3.78 18 0 0 3 3\r## 9 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2\r## 10 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4\r## # ... with 22 more rows\rJika ingin urutan yang digunakan adalah dari yang terbesar ke terkecil untuk kedua variabel tersebut jalankan sintaks berikut:\narrange(mtcars, desc(mpg), desc(wt))\r## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1\r## 2 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1\r## 3 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2\r## 4 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2\r## 5 27.3 4 79 66 4.08 1.94 18.9 1 1 4 1\r## 6 26 4 120. 91 4.43 2.14 16.7 0 1 5 2\r## 7 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 8 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 9 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 10 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1\r## # ... with 22 more rows\rJika menggunakan fungsi order():\nattach(mtcars)\r# urutan dari kecil ke besar\rmtcars[order(mpg, wt), ]\r## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4\r## 2 10.4 8 460 215 3 5.42 17.8 0 0 3 4\r## 3 13.3 8 350 245 3.73 3.84 15.4 0 0 3 4\r## 4 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4\r## 5 14.7 8 440 230 3.23 5.34 17.4 0 0 3 4\r## 6 15 8 301 335 3.54 3.57 14.6 0 1 5 8\r## 7 15.2 8 304 150 3.15 3.44 17.3 0 0 3 2\r## 8 15.2 8 276. 180 3.07 3.78 18 0 0 3 3\r## 9 15.5 8 318 150 2.76 3.52 16.9 0 0 3 2\r## 10 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4\r## # ... with 22 more rows\r# urutan dari besar ke kecil\rmtcars[order(-mpg, -wt), ]\r## # A tibble: 32 x 11\r## mpg cyl disp hp drat wt qsec vs am gear carb\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1\r## 2 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1\r## 3 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2\r## 4 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2\r## 5 27.3 4 79 66 4.08 1.94 18.9 1 1 4 1\r## 6 26 4 120. 91 4.43 2.14 16.7 0 1 5 2\r## 7 24.4 4 147. 62 3.69 3.19 20 1 0 4 2\r## 8 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2\r## 9 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1\r## 10 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1\r## # ... with 22 more rows\r\rNote:  missing value akan selalu diurutkan pada observasi terakhir baik menggunakan urutan dari terbesar ke terkecil maupun sebaliknya.\n\r\r3.5.4 select()\rFungsi select() dapat digunakan untuk memilih kolom dari data frame yang ingin kita fokuskan. Seringkali kita memiliki data frame yang besar yang berisi semua data, tetapi setiap analisis yang diberikan hanya menggunakan subset variabel atau pengamatan. Fungsi select() memungkinkan kita untuk mendapatkan beberapa kolom yang mungkin kita butuhkan.\nFungsi select() memiliki kesamaan dengan subset menggunakan tanda “[” dan “$”. Perbedaanya adalah kita dapat melakukan hal lebih melalui fungsi ini seperti memilih berdasarkan kriteria tertentu menggunakan fungsi bantuan sebagai berikut:\nstarts_with(\u0026quot;abcd\u0026quot;), pilih kolom yang memiliki awalan “abcd”.\rend_with(\u0026quot;abcd\u0026quot;), pilih kolom yang memiliki akhiran “abcd”.\rcontains(\u0026quot;abcd\u0026quot;), pilih kolom yang mengandung nama “abcd”\rmatches(\u0026quot;(.)\\\\1\u0026quot;), pilih variabel yang mengandung regular expression. Fungsi ini memilih variabel yang mengandung perulangan karakter.\rnum_range(\u0026quot;x\u0026quot;, 1:3), cocokkan berdasarkan kolom dengan nama x1,x2,x3.\r\rBerdasarkan fungsi bantuan tersebut, fungsi select() lebih powerfull dibandingkan dengan cara subset biasa serta lebih mudah dalam melakukannya. Berikut adalah format dari fungsi select():\nselect(data, ....)\r\rNote: \n\rdata : data frame\r…. : Satu atau lebih ekspresi kutip yang dipisahkan oleh koma. kita dapat memperlakukan nama variabel seperti posisi, sehingga kita dapat menggunakan ekspresi seperti x: y untuk memilih rentang variabel.Nilai positif pilih variabel; nilai negatif drop variabel. Jika ekspresi pertama negatif, select() akan secara otomatis dimulai dengan semua variabel. Gunakan argumen bernama, mis. new_name = old_name, untuk mengganti nama variabel yang dipilih.\r\r\rBerikut adalah contoh penerapan selct() pada data frame flights.\n# memasang paket\r# install.packages(\u0026quot;nycflights13\u0026quot;)\r# memuat data frame\rlibrary(nycflights13)\r## Warning: package \u0026#39;nycflights13\u0026#39; was built under R version 3.5.3\r# data\rflights\r## # A tibble: 336,776 x 19\r## year month day dep_time sched_dep_time dep_delay arr_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1 517 515 2 830\r## 2 2013 1 1 533 529 4 850\r## 3 2013 1 1 542 540 2 923\r## 4 2013 1 1 544 545 -1 1004\r## 5 2013 1 1 554 600 -6 812\r## 6 2013 1 1 554 558 -4 740\r## 7 2013 1 1 555 600 -5 913\r## 8 2013 1 1 557 600 -3 709\r## 9 2013 1 1 557 600 -3 838\r## 10 2013 1 1 558 600 -2 753\r## # ... with 336,766 more rows, and 12 more variables: sched_arr_time \u0026lt;int\u0026gt;,\r## # arr_delay \u0026lt;dbl\u0026gt;, carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;,\r## # origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;, air_time \u0026lt;dbl\u0026gt;, distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;,\r## # minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r# pilih kolom berdasarkan nama kolom\rselect(flights, year, month, day)\r## # A tibble: 336,776 x 3\r## year month day\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1\r## 2 2013 1 1\r## 3 2013 1 1\r## 4 2013 1 1\r## 5 2013 1 1\r## 6 2013 1 1\r## 7 2013 1 1\r## 8 2013 1 1\r## 9 2013 1 1\r## 10 2013 1 1\r## # ... with 336,766 more rows\r# pilih seluruh kolom dari year sampai day\rselect(flights, year:day)\r## # A tibble: 336,776 x 3\r## year month day\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt;\r## 1 2013 1 1\r## 2 2013 1 1\r## 3 2013 1 1\r## 4 2013 1 1\r## 5 2013 1 1\r## 6 2013 1 1\r## 7 2013 1 1\r## 8 2013 1 1\r## 9 2013 1 1\r## 10 2013 1 1\r## # ... with 336,766 more rows\r# drop kolom dari year sampai day\rselect(flights, -(year:day))\r## # A tibble: 336,776 x 16\r## dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 515 2 830 819 11\r## 2 533 529 4 850 830 20\r## 3 542 540 2 923 850 33\r## 4 544 545 -1 1004 1022 -18\r## 5 554 600 -6 812 837 -25\r## 6 554 558 -4 740 728 12\r## 7 555 600 -5 913 854 19\r## 8 557 600 -3 709 723 -14\r## 9 557 600 -3 838 846 -8\r## 10 558 600 -2 753 745 8\r## # ... with 336,766 more rows, and 10 more variables: carrier \u0026lt;chr\u0026gt;,\r## # flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;, air_time \u0026lt;dbl\u0026gt;,\r## # distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;, time_hour \u0026lt;dttm\u0026gt;\r# pilih kolom dengan akhiran time\rselect(flights, ends_with(\u0026quot;time\u0026quot;))\r## # A tibble: 336,776 x 5\r## dep_time sched_dep_time arr_time sched_arr_time air_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 515 830 819 227\r## 2 533 529 850 830 227\r## 3 542 540 923 850 160\r## 4 544 545 1004 1022 183\r## 5 554 600 812 837 116\r## 6 554 558 740 728 150\r## 7 555 600 913 854 158\r## 8 557 600 709 723 53\r## 9 557 600 838 846 140\r## 10 558 600 753 745 138\r## # ... with 336,766 more rows\r# pilih kolom yang mengandung karakter \u0026quot;arr\u0026quot;\rselect(flights, contains(\u0026quot;arr\u0026quot;))\r## # A tibble: 336,776 x 4\r## arr_time sched_arr_time arr_delay carrier\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;chr\u0026gt; ## 1 830 819 11 UA ## 2 850 830 20 UA ## 3 923 850 33 AA ## 4 1004 1022 -18 B6 ## 5 812 837 -25 DL ## 6 740 728 12 UA ## 7 913 854 19 B6 ## 8 709 723 -14 EV ## 9 838 846 -8 B6 ## 10 753 745 8 AA ## # ... with 336,766 more rows\rKita juga dapat menggunakan fungsi tambahan everithing() yang berguna jika kita ingin memindahkan variabel yang menjadi fokus kita ke awal data frame tanpa melakukan drop variabel. Berikut adalah contoh sintaksnya:\n# pindahkan kolom yang mengandung time di awal\rselect(flights, contains(\u0026quot;time\u0026quot;), everything())\r## # A tibble: 336,776 x 19\r## dep_time sched_dep_time arr_time sched_arr_time air_time\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 515 830 819 227\r## 2 533 529 850 830 227\r## 3 542 540 923 850 160\r## 4 544 545 1004 1022 183\r## 5 554 600 812 837 116\r## 6 554 558 740 728 150\r## 7 555 600 913 854 158\r## 8 557 600 709 723 53\r## 9 557 600 838 846 140\r## 10 558 600 753 745 138\r## # ... with 336,766 more rows, and 14 more variables: time_hour \u0026lt;dttm\u0026gt;,\r## # year \u0026lt;int\u0026gt;, month \u0026lt;int\u0026gt;, day \u0026lt;int\u0026gt;, dep_delay \u0026lt;dbl\u0026gt;, arr_delay \u0026lt;dbl\u0026gt;,\r## # carrier \u0026lt;chr\u0026gt;, flight \u0026lt;int\u0026gt;, tailnum \u0026lt;chr\u0026gt;, origin \u0026lt;chr\u0026gt;, dest \u0026lt;chr\u0026gt;,\r## # distance \u0026lt;dbl\u0026gt;, hour \u0026lt;dbl\u0026gt;, minute \u0026lt;dbl\u0026gt;\r\r3.5.5 mutate()\rFungsi mutate() ada untuk menghitung transformasi variabel dalam data frame. Seringkali, kita ingin membuat variabel baru yang berasal dari variabel yang ada dan fungsi mutate() menyediakan antarmuka yang bersih untuk melakukan itu. Format yang digunakan adalah sebagai berikut:\nmutate(data, ....)\r\rNote: \n\rdata : data frame\r…. : Pasangan nama-nilai ekspresi, masing-masing dengan panjang 1 atau panjang yang sama dengan jumlah baris dalam grup (jika menggunakan group_by ()) atau di seluruh input (jika tidak menggunakan grup). Nama setiap argumen akan menjadi nama variabel baru, dan nilainya akan menjadi nilai yang sesuai. Gunakan nilai NULL dalam mutasi untuk menjatuhkan drop variabel lama, sehingga variabel baru menimpa variabel yang ada dengan nama yang sama.\r\r\r# subset data frame\rflights_sml \u0026lt;- select(flights,\ryear:day,\rends_with(\u0026quot;delay\u0026quot;),\rdistance,\rair_time\r)\r# mutate()\rmutate(flights_sml,\rgain = arr_delay - dep_delay,\rhours = air_time / 60,\rgain_per_hour = gain / hours\r)\r## # A tibble: 336,776 x 10\r## year month day dep_delay arr_delay distance air_time gain hours\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 2 11 1400 227 9 3.78 ## 2 2013 1 1 4 20 1416 227 16 3.78 ## 3 2013 1 1 2 33 1089 160 31 2.67 ## 4 2013 1 1 -1 -18 1576 183 -17 3.05 ## 5 2013 1 1 -6 -25 762 116 -19 1.93 ## 6 2013 1 1 -4 12 719 150 16 2.5 ## 7 2013 1 1 -5 19 1065 158 24 2.63 ## 8 2013 1 1 -3 -14 229 53 -11 0.883\r## 9 2013 1 1 -3 -8 944 140 -5 2.33 ## 10 2013 1 1 -2 8 733 138 10 2.3 ## # ... with 336,766 more rows, and 1 more variable: gain_per_hour \u0026lt;dbl\u0026gt;\rJika hanya ingin menyisakan variabel output fungsi mutate() pada data frame (variabel lain di drop), kita dapat menggunakan fungsi transmute(). Berikut adalah contoh sintaks yang digunakan:\ntransmute(flights,\rgain = arr_delay - dep_delay,\rhours = air_time / 60,\rgain_per_hour = gain / hours\r)\r## # A tibble: 336,776 x 3\r## gain hours gain_per_hour\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 9 3.78 2.38\r## 2 16 3.78 4.23\r## 3 31 2.67 11.6 ## 4 -17 3.05 -5.57\r## 5 -19 1.93 -9.83\r## 6 16 2.5 6.4 ## 7 24 2.63 9.11\r## 8 -11 0.883 -12.5 ## 9 -5 2.33 -2.14\r## 10 10 2.3 4.35\r## # ... with 336,766 more rows\rAdapaun fungsi-fungsi dan operator yang dapat digunakan pada mutate() untuk membuat variabel baru adalah sebagai berikut:\nOperator aritmatik (+,-,*,/,^, %/%, %%). operator aritmetik seperti %/% dan %% sangat berguna dalam memecah integer menjadi beberapa bagian seperti hasil bagi tanpa sisa (%/%) dan sisa hasil bagi (%%). Berikut adalah contoh penerapannya:\r\rtransmute(flights,\rdep_time,\rhour = dep_time %/% 100,\rminute = dep_time %% 100\r)\r## # A tibble: 336,776 x 3\r## dep_time hour minute\r## \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 517 5 17\r## 2 533 5 33\r## 3 542 5 42\r## 4 544 5 44\r## 5 554 5 54\r## 6 554 5 54\r## 7 555 5 55\r## 8 557 5 57\r## 9 557 5 57\r## 10 558 5 58\r## # ... with 336,766 more rows\rFungsi aritmetik (log(),sin(),cos(),dll)\rFungsi Offsets (lead()dan lag()). memungkinkan kita untuk merujuk pada nilai-nilai memimpin atau tertinggal. Berikut adalah contoh penerapannya:\r\r(x \u0026lt;- 1:10)\r## [1] 1 2 3 4 5 6 7 8 9 10\rlag(x)\r## [1] NA 1 2 3 4 5 6 7 8 9\rlead(x)\r## [1] 2 3 4 5 6 7 8 9 10 NA\rFungsi kumulatif (cumsum(),cumprod(),cummin(),cummax(), dan cummean()). Jika kita membutuhkan agregat bergulir (mis., Jumlah yang dihitung di atas jendela bergulir). Berikut adalah contoh penerapannya:\r\rx\r## [1] 1 2 3 4 5 6 7 8 9 10\rcumsum(x)\r## [1] 1 3 6 10 15 21 28 36 45 55\rcummean(x)\r## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5\rOperator logik (\u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;=, !=). Jika kita melakukan urutan operasi logis yang kompleks, seringkali ide yang baik untuk menyimpan nilai sementara dalam variabel baru sehingga kita dapat memeriksa bahwa setiap langkah berfungsi seperti yang diharapkan.\n\rRangking (min_rank(), row_number(), dense_rank(), percent_rank(), cume_dist()dan ntile()).\n\r\r\r3.5.6 summarize() dan group_by()\rKita dapat membuat ringkasan data menggunakan fungsi summarize(). Fungsi tersebut akan merubah data frame menjadi sebuah baris berisi ringkasan data yang kita inginkan. Berikut adalh contoh penerapannya:\nsummarize(flights, delay = mean(dep_delay, na.rm = TRUE))\r## # A tibble: 1 x 1\r## delay\r## \u0026lt;dbl\u0026gt;\r## 1 12.6\rFUngsi ini akan lebih berguna saat digunakan dengan fungsi group_by() sehingga dapat diperoleh ringkasan data pada setiap grup. berikut adalah contoh penerapannya:\nby_day \u0026lt;- group_by(flights, year, month, day)\rsummarize(by_day, delay = mean(dep_delay, na.rm = TRUE))\r## # A tibble: 365 x 4\r## # Groups: year, month [12]\r## year month day delay\r## \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 2013 1 1 11.5 ## 2 2013 1 2 13.9 ## 3 2013 1 3 11.0 ## 4 2013 1 4 8.95\r## 5 2013 1 5 5.73\r## 6 2013 1 6 7.15\r## 7 2013 1 7 5.42\r## 8 2013 1 8 2.55\r## 9 2013 1 9 2.28\r## 10 2013 1 10 2.84\r## # ... with 355 more rows\r\r3.5.7 Mengkombinasikan Beberapa Operasi Menggunakan Operator Pipe (%\u0026gt;%)\rOperator pipa (%\u0026gt;%) sangat berguna untuk merangkai bersama beberapa fungsi dplyr dalam suatu urutan operasi. Perhatikan contoh sebelumnya dimana setiap kali kita ingin menerapkan lebih dari satu fungsi, urutannya akan dimulai dalam urutan panggilan fungsi bersarang yang sulit dibaca. Secara ringkas dapat kita tulis sebagai berikut:\nthird(second(first(x)))\rJika dituliskan menggunakan operator pipa akan menghasilkan sintak berikut:\nx %\u0026gt;%\rfirst() %\u0026gt;%\rsecond() %\u0026gt;%\rthird()\rDengan menuliskannya melalui cara tersebut kita dapat membacanya lebih mudah.\nMisal kita ingin mengetahui hubungan antara variabel jarak (dist) terhadap rata-rata delay (arr_delay). Langkah-langkah untuk melakukannya dengan menggunakan operator pipa adalah sebagai berikut:\nKelompokkan penerbangan berdasarkan destinasinya (group_by()).\rHitung ringkasan data berdasarkan jarak, rata-rata delay, dan jumlah penerbangan.\rLakukan filter untuk membuang noisy point (jika diperlukan). Dalam hal ini jumlah penerbangan \u0026gt; 20 dan tujuan penerbangan Honolulu (“HNL”) adalah outlier atau noisy point.\r\rBerikut adalah sintaks untuk melakukannya:\n## # A tibble: 96 x 4\r## dest count dist delay\r## \u0026lt;chr\u0026gt; \u0026lt;int\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 ABQ 254 1826 4.38\r## 2 ACK 265 199 4.85\r## 3 ALB 439 143 14.4 ## 4 ATL 17215 757. 11.3 ## 5 AUS 2439 1514. 6.02\r## 6 AVL 275 584. 8.00\r## 7 BDL 443 116 7.05\r## 8 BGR 375 378 8.03\r## 9 BHM 297 866. 16.9 ## 10 BNA 6333 758. 11.8 ## # ... with 86 more rows\r## ## Attaching package: \u0026#39;ggplot2\u0026#39;\r## The following object is masked from \u0026#39;mtcars\u0026#39;:\r## ## mpg\r## `geom_smooth()` using method = \u0026#39;loess\u0026#39; and formula \u0026#39;y ~ x\u0026#39;\r\rFigure 3: Jarak vs rata-rata delay\r\rBerdasarkan Figure 3, rata-rata delay meningkat seiring dengan pertambahan jarak penerbangan.\nReferensi\nWickham, H. Grolemund G. 2016. R For Data Science: Import, Tidy, Transform, Visualize, And Model Data. O’Reilly Media, Inc.\rPeng, R.D. 2015. Exploratory Data Analysis with R. Leanpub book.\rDplyr Documentation. https://dplyr.tidyverse.org/\rQuick-R. Data Input. https://www.statmethods.net/input/index.html\rQuick-R. Data Management. https://www.statmethods.net/management/index.html\rSTHDA. Importing Data Into R . http://www.sthda.com/english/wiki/importing-data-into-r\rSTHDA. Exporting Data From R. http://www.sthda.com/english/wiki/exporting-data-from-r\r\r\r\r","date":1552064400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1552064400,"objectID":"c2a25e2085b59e5ca11c8574a4822636","permalink":"/tutorial/03_manajemen-data-r/","publishdate":"2019-03-09T00:00:00+07:00","relpermalink":"/tutorial/03_manajemen-data-r/","section":"tutorial","summary":"body{\rtext-align: justify}\r\r\rDaftar Isi:\r\rImport File\rEksport File\rTibble Data Format\rMerapikan Data\rTransformasi Data\r\r\r3.1 Import File\rPada sesi bagian ini penulis akan menjelaskan cara mengimport file pada R. File yang diimport ke dalam R terdiri atas file yang sering digunakan pada saat akan melakukan analisis data, antara lain: TXT, CSv, Excel, SPSS, SAS, dan STATA.\nPada bagian ini akan dijelaskan pula bagaimana melakukan import data menggunakan library readr serta kelebihan dari metode import data yang digunakan.","tags":null,"title":"3. Manajemen Data R","type":"docs"},{"authors":null,"categories":null,"content":"\r\rbody{\rtext-align: justify}\r\r\rDaftar Isi\r\rSejarah R\rFitur dan Karakteristik R\rKelebihan dan Kekurangan R\rRStudio\rMenginstall R dan RStudio\rWorking Directory\rFasilitas Help\r\r\r1.1 Sejarah R\rR Merupakan bahasa yang digunakan dalam komputasi statistik yang pertama kali dikembangkan oleh Ross Ihaka dan Robert Gentlement di University of Auckland New Zealand yang merupakan akronim dari nama depan kedua pembuatnya. Sebelum R dikenal ada S yang dikembangkan oleh John Chambers dan rekan-rekan dari Bell Laboratories yang memiliki fungsi yang sama untuk komputasi statistik. Hal yang membedakan antara keduanya adalah R merupakan sistem komputasi yang bersifat gratis.Logo R dapat dilihat pada Figure 1.\n## Warning: package \u0026#39;knitr\u0026#39; was built under R version 3.5.3\r\rFigure 1: Logo R.\r\rR dapat dibilang merupakan aplikasi sistem statistik yang kaya. Hal ini disebabkan banyak sekali paket yang dikembangkan oleh pengembang dan komunitas untuk keperluan analisa statistik seperti linear regression, clustering, statistical test, dll. Selain itu, R juga dapat ditambahkan paket-paket lain yang dapat meningkatkan fiturnya.\nSebagai sebuah bahasa pemrograman yang banyak digunakan untuk keperluan analisa data, R dapat dioperasikan pada berbagai sistem operasi pada komputer. Adapun sistem operasi yang didukung antara lain: UNIX, Linux, Windows, dan MacOS.\n\r1.2 Fitur dan Karakteristik R\rR memiliki karakteristik yang berbeda dengan bahasa pemrograman lain seperti C++,python, dll. R memiliki aturan/sintaks yang berbeda dengan bahasa pemrograman yang lain yang membuatnya memiliki ciri khas tersendiri dibanding bahasa pemrograman yang lain.\nBeberapa ciri dan fitur pada R antara lain:\nBahasa R bersifat case sensitif. maksudnya adalah dalam proses input R huruf besar dan kecil sangat diperhatikan. Sebagai contoh kita ingin melihat apakah objek A dan B pada sintaks berikut:\r\rA \u0026lt;- \u0026quot;Andi\u0026quot;\rB \u0026lt;- \u0026quot;andi\u0026quot;\r# cek kedua objek A dan B\rA == B\r## [1] FALSE\r# Kesimpulan : Kedua objek berbeda\rSegala sesuatu yang ada pada program R akan diangap sebagai objek. konsep objek ini sama dengan bahasa pemrograma berbasis objek yang lain seperti Java, C++, python, dll.Perbedaannya adalah bahasa R relatif lebih sederhana dibandingkan bahasa pemrograman berbasis obejk yang lain.\rinterpreted language atau script. Bahasa R memungkinkan pengguna untuk melakukan kerja pada R tanpa perlu kompilasi kode program menjadi bahasa mesin.\rMendukung proses loop, decision making, dan menyediakan berbagai jenis operstor (aritmatika, logika, dll).\rMendukung export dan import berbagai format file, seperti:TXT, CSV, XLS, dll.\rMudah ditingkatkan melalui penambahan fungsi atau paket. Penambahan paket dapat dilakukan secara online melalui CRAN atau melalui sumber seperti github.\rMenyedikan berbagai fungsi untuk keperluan visualisasi data. Visualisasi data pada R dapat menggunakan paket bawaan atau paket lain seperti ggplo2,ggvis, dll.\r\r\r1.3 Kelebihan dan Kekurangan R\rSelain karena R dapat digunakan secara gratis terdapat kelebihan lain yang ditawarkan, antara lain:\nProtability. Penggunaan software dapat digunakan kapanpun tanpa terikat oleh masa berakhirnya lisensi.\rMultiplatform. R bersifat Multiplatform Operating Systems, dimana software R lebih kompatibel dibanding software statistika lainnya. Hal in berdampak pada kemudahan dalam penyesuaian jika pengguna harus berpindah sistem operasi karena R baik pada sistem operasi seperti windows akan sama pengoperasiannya dengan yang ada di Linux (paket yang digunakan sama).\rGeneral dan Cutting-edge. Berbagai metode statistik baik metode klasik maupun baru telah diprogram kedalam R. Dengan demikian software ini dapat digunakan untuk analisis statistika dengan pendekatan klasik dan pendekatan modern.\rProgramable. Pengguna dapat memprogram metode baru atau mengembangakan modifikasi dari analisis statistika yang telah ada pada sistem R.\rBerbasis analisis matriks. Bahasa R sangat baik digunakan untuk programming dengan basis matriks.\rFasiltas grafik yang lengkap.\r\rAdapun kekurangan dari R antara lain:\nPoint and Click GUI. Interaksi utama dengan R bersifat CLI (Command Line Interface), walaupun saat ini telah dikembangkan paket yang memungkinkan kita berinteraksi dengan R menggunakan GUI (Graphical User Interface) sederhana menggunakan paket R-Commander yang memiliki fungsi yang terbatas. R- Commander sendiri merupakan GUI yang diciptakan dengan tujuan untuk keperluan pengajaran sehingga analisis statistik yang disediakan adalah yang klasik. Meskipun terbatas paket ini berguna jika kita membutuhkan analisis statistik sederhana dengan cara yang simpel.\rMissing statistical function. Meskipun analisis statistika dalam R sudah cukup lengkap, namun tidak semua metode statistika telah diimplementasikan ke dalam R. Namun karena R merupakan lingua franca untuk keperluan komputasi statistika modern staan ini, dapat dikatakan ketersediaan fungsi tambahan dalam bentuk paket hanya masalah waktu saja.\r\r\r1.4 RStudio\rAplikasi R pada dasarnya berbasis teks atau command line sehingga pengguna harus mengetikkan perintah-perintah tertentu dan harus hapal perintah-perintahnya. Setidaknya jika kita ingin melakukan kegiatan analisa data menggunakan R kita harus selalu siap dengan perintah-perintah yang hendak digunakan sehingga buku manual menjadi sesuatu yang wajib adasaat berkeja dengan R.\nKondisi ini sering kali membingunkan bagi pengguna pemula maupun pengguna mahir yang sudah terbiasa dengan aplikasi statistik lain seperti SAS, SPSS, Minitab, dll. Alasan itulah yang menyebabkan pengembang R membuat berbagai frontend untuk R yang berguna untuk memudahkan dalam pengoperasian R.\nRStudio merupakan salah satu bentuk frontend R yang cukup populer dan nyaman digunakan. Selain nyaman digunakan, RStudio memungkinkan kita melakukan penulisan laporan menggunakan Rmarkdown atau RNotebook serta membuat berbagai bentuk project seperti shyni, dll. Pada R studio juga memungkinkan kita mengatur working directory tanpa perlu mengetikkan sintaks pada Commander, yang diperlukan hanya memilihnya di menu RStudio. Selain itu, kita juga dapat meng-import file berisikan data tanpa perlu mengetikkan pada Commander dengan cara memilih pada menu Environment.\n\r1.5 Menginstall R dan RStudio\rPada tutorial ini hanya akan dijelaskan bagaimana menginstal R dan RStudio pada sistem operasi windows. Sebelum memulai menginstal sebaiknya pembaca mengunduh terlebih dahulu installer R dan RStudio.\nJalankan proses pemasangan dengan meng-klik installer aplikasi R dan RStudio.\rIkuti langkah proses pemasangan aplikasi yang ditampilkan dengan klik OK atau Next.\rApabila pemasangan telah dilakukan, jalankan aplikasi yang telah terpasang untuk menguji jika aplikasi telah berjalan dengan baik.\r\rJendela aplikasi yang telah terpasang ditampilkan pada Figure 2 dan Figure 3.\n\rFigure 2: Jendela R.\r\r\rFigure 3: Jendela RStudio.\r\r\rNote:  Sebaiknya install R terlebih dahulu sebelum RStudio\n\r\r1.6 Working Directory\rSetiap pengguna akan bekerja pada tempat khusus yang disebut sebagai working directory. working directory merupakan sebuah folder dimana R akan membaca dan menyimpan file kerja kita. Pada pengguna windows, working directory secara default pada saat pertama kali menginstall R terletak pada folder c:\\\\Document.\n1.6.1 Mengubah Lokasi Working Directory\rKita dapat mengubah lokasi working directory berdasarkan lokasi yang kita inginkan, misalnya letak data yang akan kita olah tidak ada pada folder default atau kita ingin pekerjaan kita terkait R dapat berlangsung pada satu folder khusus.\nBerikut adalah cara mengubah working directory pada R.\nBuatlah folder pada drive (kita bisa membuat folder pada selain drive c) dan namai dengan nama yang kalian inginkan. Pada tutorial ini penulis menggunakan nama folder R.\rJika pengguna menggunakan RStudio, pada menu RStudio pilih Session \u0026gt; Set Working Directory \u0026gt; Chooses Directory. Proses tersebut ditampilkan pada Figure 4\rPilih folder yang telah dibuat pada step 1 sebagai *working directory.\r\r\rNote:  Data atau file yang hendak dibaca selama proses kerja pada R harus selalu diletakkan pada working directory. Jika tidak maka data atau file tidak akan terbaca.\n\rUntuk mengecek apakah proses perubahan telah terjadi, kita dapat mengeceknya dengan menjalankan perintah berikut untuk melihat lokasi working directory kita yang baru.\ngetwd()\r\rFigure 4: Mengubah working directory.\r\rSelain itu kita dapat mengubah working directory menggunakan perintah berikut:\n# Ubah working directori pada folder R\rsetwd(\u0026quot;/Documents/R\u0026quot;)\r\rNote:  Pada proses pengisian lokasi folder pastikan pemisah pada lokasi folder menggunakan tanda “/” bukan “\u0026quot;\n\r\r1.6.2 Mengubah Lokasi Working Directory Default\rPada proses yang telah penulis jelaskan sebelumnya. Proses perubahan working directory hanya berlaku pada saat pekerjaan tersebut dilakukan. Setelah pekerjaan selesai dan kita menjalankan kembali R maka working directory akan kembali secara default pada working directory lama.\nUntuk membuat lokasi default working directory pindah, kita dapat melakukannya dengan memilih pada menu: Tools \u0026gt; Global options \u0026gt; pada “General” klik pada “Browse” dan pilih lokasi working directory yang diinginkan. Proses tersebut ditampilkan pada Figure 5\n\rFigure 5: Merubah working directory melalui Global options.\r\r\r\r1.7 Fasilitas Help\rAgar dapat menggunakan R dengan secara lebih baik, pengetahuan untuk mengakses fasilitas help in cukup penting untuk disampaikan. Adapun cara yang dapat digunakan adalah sebagai berikut.\n1.7.1 Mencari Help dari Suatu Perintah Tertentu\rUntuk memperoleh bantuan terkait suatu perintah tertentu kita dapat menggunakan fungsi help(). Secara umum format yang digunakan adalah sebagai berikut:\nhelp(nama_perintah)\ratau dapat juga menggunakan tanda tanya (?) pada awal nama_perintah seperti berikut:\n?nama_perintah\rMisalkan kita kebingungan terkait bagaimana cara menuliskan perintah untuk menghitung rata-rata suatu vektor. Kita dapat mengetikkan perintah berikut untuk mengakses fasilitas help.\nhelp(mean)\r#atau\r?mean\rPerintah tersebut akan memunculkan hasil berupa dokumentasi yang ditampilkan pada Figure 6.\n\rFigure 6: Jendela help dokumentasi fungsi mean().\r\rKeterangan pada jendela pada Figure 6 adalah sebagia berikut:\nPada bagian jendela kiri atas jendela help, diberikan keterangan nama dari perintah yang sedang ditampilkan.\rSelanjutnya, pada bagian atas dokumen, ditampilkan infomasi terkait nama perintah, dan nama library yang memuat perintah tersebut. Pada gambar diatas informasi terkait perintah dan nama library ditunjukkan pada teks mean {base} yang menunjukkan perintah mean() pada paket (library) base (paket bawaan R).\rSetiap jendela help dari suatu perintah tertentu selanjutnya akan memuat bagian-bagian berikut:\r\r\rTitle\rDescription : deskripsi singkat tentang perintah.\rUsage : menampilkan sintaks perintah untuk penggunaan perintah tersebut.\rArguments : keterangan mengenai argument/inputyang diperlukan pada perintah tersebut.\rDetails : keterangan lebih lengkap lengkap tentang perintah tersebut.\rValue : keterangan tentang output suatu perintah dapat diperoleh pada bagian ini.\rAuthor(s) : memberikan keterangan tentang Author dari perintah tersebut.\rReferences : seringkali referensi yang dapat digunakan untuk memperoleh keterangan lebih lanjut terhadap suatu perintah ditampilkan pada bagian ini.\rSee also: bagian ini berisikan daftar perintah/fungsi yang berhubungan erat dengan perintah tersebut.\rExample : berisikan contoh-contoh penggunaan perintah tersebut.\r\rKita juga dapat melihat contoh penggunaan dari perintah tersebut. Untuk melakukannya kita dapat menggunakan fungsi example(). Fungsi tersebut akan menampilkan contoh kode penerapan dari fungsi yang kita inginkan. Secara sederhana fungsi tersebut dapat dituliskan sebagai berikut:\nexample(nama_perintah)\rUntuk mengetahui contoh kode fungsi mean(), ketikkan sintaks berikut:\nexample(mean)\r## ## mean\u0026gt; x \u0026lt;- c(0:10, 50)\r## ## mean\u0026gt; xm \u0026lt;- mean(x)\r## ## mean\u0026gt; c(xm, mean(x, trim = 0.10))\r## [1] 8.75 5.50\rkita juga dapat mencoba kode yang dihasilkan pada console R. Berikut adalah contoh penerapannya:\n# Menghitung rata-rata bilangan 1 sampai 10 dan 50\r# membuat vektor\rx \u0026lt;- c(0:10, 50)\r# Print\rx\r## [1] 0 1 2 3 4 5 6 7 8 9 10 50\r# mean\rmean(x)\r## [1] 8.75\rPembaca dapat mencoba melakukanya sendiri dengan mengganti nilai yang telah ada serta mencoba contoh kode yang lain.\n\r1.7.2 General Help\rKita juga dapat membaca beberapa dokumen manual yang ada pada R. Untuk melakukannya jalankan perintah berikut:\nhelp.start()\rOutput yang dihasilkan berupa link pada sejumlah dokumen yang dapat kita klik. Tampilan halaman yang dihasilkan disajikan pada Figure 7.\n\rFigure 7: Jendela general help dokumentasi fungsi mean().\r\r\r1.7.3 Fasilitas Help Lainnya\rSelain yang telah penulis sebutkan sebelumnya. Kita juga dapat memanfaatkan fasilitas help lainnya melalui fungsi apropos() dan help.search().\napropos (): mengembalikan daftar objek, berisi pola yang pembaca cari, dengan pencocokan sebagian. Ini berguna ketika pembaca tidak ingat persis nama fungsi yang akan digunakan. Berikut adalah contoh ketika penulis ingin mengetahui fungsi yang digunakan untuk menghitung median.\napropos(\u0026quot;med\u0026quot;)\r## [1] \u0026quot;elNamed\u0026quot; \u0026quot;elNamed\u0026lt;-\u0026quot; \u0026quot;median\u0026quot; \u0026quot;median.default\u0026quot;\r## [5] \u0026quot;medpolish\u0026quot; \u0026quot;runmed\u0026quot;\rList yang dihasilkan berupa fungsi-fungsi yang memiliki elemen kata “med”. Berdasarkan pencaria tersebut penulis dapat mencoba menggunakan fungsi “median” untuk menghitung median.\nhelp.search () (sebagai alternatif ??): mencari dokumentasi yang cocok dengan karakter yang diberikan dengan cara yang berbeda. Ini mengembalikan daftar fungsi yang mengandung istilah yang pembaca cari dengan deskripsi singkat dari fungsi.\nBerikut adalah contoh penerapan dari fungsi tersebut:\nhelp.search(\u0026quot;mean\u0026quot;)\r# atau\r??mean\r*Output yang dihasilkan akan tampak seperti pada Figure 8.\n\rFigure 8: Jendela help search dokumentasi fungsi mean().\r\rReferensi\nPrimartha, R. 2018. Belajar Machine Learning Teori dan Praktik. Penerbit Informatika : Bandung\rRosadi,D. 2016. Analisis Statistika dengan R. Gadjah Mada University Press: Yogyakarta\rSTHDA. Running RStudio and Setting Up Your Working Directory - Easy R Programming .http://www.sthda.com/english/wiki/running-rstudio-and-setting-up-your-working-directory-easy-r-programming#set-your-working-directory\rSTDHA. Getting Help With Functions In R Programming. http://www.sthda.com/english/wiki/getting-help-with-functions-in-r-programming .\rVenables, W.N. Smith D.M. and R Core Team. 2018. An Introduction to R. R Manuals.\r\r\r\r","date":1552064400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1552064400,"objectID":"6f47ca1c793632cbfe1f0e525b3f1460","permalink":"/tutorial/01_mengenal-bahasa-r/","publishdate":"2019-03-09T00:00:00+07:00","relpermalink":"/tutorial/01_mengenal-bahasa-r/","section":"tutorial","summary":"body{\rtext-align: justify}\r\r\rDaftar Isi\r\rSejarah R\rFitur dan Karakteristik R\rKelebihan dan Kekurangan R\rRStudio\rMenginstall R dan RStudio\rWorking Directory\rFasilitas Help\r\r\r1.1 Sejarah R\rR Merupakan bahasa yang digunakan dalam komputasi statistik yang pertama kali dikembangkan oleh Ross Ihaka dan Robert Gentlement di University of Auckland New Zealand yang merupakan akronim dari nama depan kedua pembuatnya. Sebelum R dikenal ada S yang dikembangkan oleh John Chambers dan rekan-rekan dari Bell Laboratories yang memiliki fungsi yang sama untuk komputasi statistik.","tags":null,"title":"1. Mengenal Bahasa R","type":"docs"},{"authors":null,"categories":null,"content":"\r\rbody{\rtext-align: justify}\r\r\rDaftar Isi\r\rOperator Aritmatika\rFungsi Aritmetik\rOperator Relasi\rOperator Logika\rMemasukkan Nilai Kedalam Variabel\rTipe Data\rVektor\rMatriks\rFaktor\rData Frames\rList\rLoop\rDecision Making\rFungsi\r\r\r2.1 Operator Aritmatika\rProses perhitungan akan ditangani oleh fungsi khusus. R akan memahami urutannya secara benar. Kecuali kita secara eksplisit menetapkan yang lain. Sebagai contoh jalankan sintaks berikut:\n2+4*2\r## [1] 10\rBandingkan dengan sintaks berikut:\n(2+4)*2\r## [1] 12\r\rR dapat digunakan sebagai kalkulator\n\rBerdasarkan kedua hasil tersebut dapat disimpulkan bahwa ketika kita tidak menetapkan urutan perhitungan menggunakan tanda kurung, R akan secara otomatis akan menghitung terlebih dahulu perkalian atau pembangian.\nOperator aritmatika yang disediakan R adalah sebagai berikut:\nTable 1 Operator Aritmatika R\n\r\r\r\rSimbol\rKeterangan\r\r\r\r+\rAddition, untuk operasi penjumlahan\r\r-\rSubstraction, untuk operasi pengurangan\r\r*\rMultiplication, untuk operasi pembagian\r\r/\rDivision, untuk operasi pembagian\r\r^\rEksponentiation, untuk operasi pemangkatan\r\r%%\rModulus, Untuk mencari sisa pembagian\r\r%/%\rInteger, Untuk mencari bilangan bulat hasil pembagian saja dan tanpa sisa pembagian\r\r\r\rUntuk lebih memahaminya berikut contoh sintaks penerapan operator tersebut.\n# Addition\r5+3\r## [1] 8\r# Substraction\r5-3\r## [1] 2\r# Multiplication\r5*3\r## [1] 15\r# Division\r5/3\r## [1] 1.666667\r# Eksponetiation\r5^3\r## [1] 125\r# Modulus\r5%%3\r## [1] 2\r# Integer\r5%/%3\r## [1] 1\r\rNote:  Pada R tanda # berfungsi menambahkan keterangan untuk menjelaskan sebuah sintaks pada R.\n\r\r2.2 Fungsi Aritmetik\rSelain fungsi operator aritmetik, pada R juga telah tersedia fungsi aritmetik yang lain seperti logaritmik, ekponensial, trigonometri, dll.\nLogaritma dan eksponensial\r\rUntuk contoh fungsi logaritmik dan eksponensial jalankan sintaks berikut:\nlog2(8) # logaritma basis 2 untuk 8\r## [1] 3\rlog10(8) # logaritma basis 10 untuk 8\r## [1] 0.90309\rexp(8) # eksponensial 8\r## [1] 2980.958\rFungsi trigonometri\r\rfungsi trigonometri yang ditampilkan seperti sin,cos, tan, dll.\ncos(x) # cos x\rsin(x) # Sin x\rtan(x) # Tan x\racos(x) # arc-cos x\rasin(x) # arc-sin x\ratan(x) #arc-tan x\r\rNote:  x dalam fungsi trigonometri memiliki satuan radian\n\rBerikut adalah salah satu contoh penggunaannya:\ncos(pi)\r## [1] -1\rFungsi matematik lainnya\r\rFungsi lainnya yang dapat digunakan adalah fungsi absolut, akar kuadrat, dll. Berikut adalah contoh sintaks penggunaan fungsi absolut dan akar kuadrat.\nabs(-2) # nilai absolut -2\r## [1] 2\rsqrt(4) # akar kuadrat 4\r## [1] 2\r\r2.3 Operator Relasi\rOperator relasi digunakan untuk membandingkan satu objek dengan objek lainnya. Operator yang disediakan R disajikan pada Table 2.\nTable 2 Operator Relasi R\n\r\rSimbol\rKeterangan\r\r\r\r“\u0026gt;”\rLebih besar dari\r\r“\u0026lt;”\rLebih Kecil dari\r\r“==”\rSama dengan\r\r“\u0026gt;=”\rLebih besar sama dengan\r\r“\u0026lt;=”\rLebih kecil sama dengan\r\r“!=”\rTidak sama dengan\r\r\r\rBerikut adalah penerapan operator pada tabel tersebut:\nx \u0026lt;- 34\ry \u0026lt;- 35\r# Operator \u0026gt;\rx \u0026gt; y\r## [1] FALSE\r# Operator \u0026lt;\rx \u0026lt; y\r## [1] TRUE\r# operator ==\rx == y\r## [1] FALSE\r# Operator \u0026gt;=\rx \u0026gt;= y\r## [1] FALSE\r# Operator \u0026lt;=\rx \u0026lt;= y\r## [1] TRUE\r# Operator !=\rx != y\r## [1] TRUE\r\r2.4 Operator Logika\rOperator logika hanya berlaku pada vektor dengan tipe logical, numeric, atau complex. Semua angka bernilai 1 akan dianggap bernilai logika TRUE. Operator logika yang disediakan R dapat dilihat pada Table 3.\nTable 3 Operator logika R\n\r\rSimbol\rKeterangan\r\r\r\r\u0026amp;\u0026amp;\rOperator logika AND\r\r\r\r\r!\rOpeartor logika NOT\r\r\u0026amp;\rOperator logika AND element wise\r\r\rOperator logika OR element wise\r\r\r\rPenerapannya terdapat pada sintaks berikut:\nv \u0026lt;- c(TRUE,TRUE, FALSE)\rt \u0026lt;- c(FALSE,FALSE,FALSE)\r# Operator \u0026amp;\u0026amp;\rprint(v\u0026amp;\u0026amp;t)\r## [1] FALSE\r# Operator ||\rprint(v||t)\r## [1] TRUE\r# Operator !\rprint(!v)\r## [1] FALSE FALSE TRUE\r# operator \u0026amp;\rprint(v\u0026amp;t)\r## [1] FALSE FALSE FALSE\r# Operator |\rprint(v|t)\r## [1] TRUE TRUE FALSE\r\rNote: \noperator \u0026amp; dan | akan mengecek logika tiap elemen pada vektor secara berpesangan (sesuai urutan dari kiri ke kanan).\nOperator %% dan || hanya mengecek dari kiri ke kanan pada observasi pertama. Misal saat menggunakan \u0026amp;\u0026amp; jika observasi pertama TRUE maka observasi pertama pada vektor lainnya akan dicek, namun jika observasi pertama FALSE maka proses akan segera dihentikan dan menghasilkan FALSE.\n\r\r2.5 Memasukkan Nilai Kedalam Variabel\rVariabel pada R dapat digunakan untuk menyimpan nilai. Sebagai contoh jalankan sintaks berikut:\n# Harga sebuah lemon adalah 500 rupiah\rlemon \u0026lt;- 500\r# Atau\r500 -\u0026gt; lemon\r# dapat juga menggunakan tanda \u0026quot;=\u0026quot;\rlemon = 500\r\rNote: \nR memungkinkan penggunaan \u0026lt;-,-\u0026gt;, atau = sebagai perintah pengisi nilai variabel\n\rR bersifat case-sensitive. Maksudnya adalah variabel Lemon tidak sama dengan lemon (Besar kecil huruf berpengaruh)\n\r\r\rUntuk mengetahui nilai dari objek lemon kita dapat menggunakan fungsi print() atau mengetikkan nama objeknya secara langsung.\n# Menggunakan fungsi print()\rprint(lemon)\r## [1] 500\r# Atau\rlemon\r## [1] 500\rR akan menyimpan variabel lemon sebagai objek pada memori. Sehingga kita dapat melakukan operasi terhadap objek tersebut seperti mengalikannya atau menjumlahkannya dengan bilangan lain. Sebagai contoh jalankan sintaks berikut:\n# Operasi perkalian terhadap objek lemon\r5*lemon\r## [1] 2500\rKita dapat juga mengubah nilai dari objek lemon dengan cara menginput nilai baru terhadap objek yang sama. R secara otomatis akan menggatikan nilai sebelumnya. Untuk lebih memahaminya jalankan sintaks berikut:\nlemon \u0026lt;- 1000\r# Print lemon\rprint(lemon)\r## [1] 1000\rUntuk lebih memahaminya berikut adalah sintaks untuk menghitung volume suatu objek.\n# Dimensi objek\rpanjang \u0026lt;- 10\rlebar \u0026lt;- 5\rtinggi \u0026lt;- 5\r# Menghitung volume\rvolume \u0026lt;- panjang*lebar*tinggi\r# Print objek volume\rprint(volume)\r## [1] 250\rUntuk mengetahui objek apa saja yang telah kita buat sepanjang artikel ini kita dapang menggunakan fungsi ls().\nls()\r## [1] \u0026quot;lebar\u0026quot; \u0026quot;lemon\u0026quot; \u0026quot;panjang\u0026quot; \u0026quot;t\u0026quot; \u0026quot;tinggi\u0026quot; \u0026quot;v\u0026quot; \u0026quot;volume\u0026quot; ## [8] \u0026quot;x\u0026quot; \u0026quot;y\u0026quot;\r\rKumpulan objek yang telah tersimpan dalam memori disebut sebagai workspace\n\rUntuk menghapus objek pada memori kita dapat menggunakan fungsi rm(). Pada sintaks berikut penulis hendak menghapus objek lemon dan volume.\n# Menghapus objek lemon dan volume\rrm(lemon, volume)\r# Tampilkan kembali objek yang tersisa\rls()\r## [1] \u0026quot;lebar\u0026quot; \u0026quot;panjang\u0026quot; \u0026quot;t\u0026quot; \u0026quot;tinggi\u0026quot; \u0026quot;v\u0026quot; \u0026quot;x\u0026quot; \u0026quot;y\u0026quot;\r\rNote:  Setiap variabel atau objek yang dibuat akan menempati sejumlah memori pada komputer sehingga jika kita bekerja dengan jumlah data yang banyak pastikan kita menghapus seluruh objek pada memori sebelum memulai kerja.\n\r\r2.6 Tipe Data\rData pada R dapat dikelompokan berdasarkan beberapa tipe. Tipe data pada R disajikan pada Table 4.\nTable 4 Tipe Data R\n\r\rTipe Data\rContoh\rKeterangan\r\r\r\rLogical\rTRUE, FALSE\rNilai Boolean\r\rNumeric\r12.3, 5, 999\rSegala jenis angka\r\rInteger\r23L, 97L, 3L\rBilangan integer (bilangan bulat)\r\rComplex\r2i, 3i, 9i\rBilangan kompleks\r\rCharacter\r‘a’, “b”, “123”\rKarakter dan string\r\rRaw\rIdentik dengan “hello”\rSegala jenis data yang disimpan sebagai raw bytes\r\r\r\rSintaks berikut adalah contoh dari tipe data pada R. Untuk mengetahui tipa data suatu objek kita dapat menggunakan perintah class()\n# Logical\rapel \u0026lt;- TRUE\rclass(apel)\r## [1] \u0026quot;logical\u0026quot;\r# Numeric\rx \u0026lt;- 2.3\rclass(x)\r## [1] \u0026quot;numeric\u0026quot;\r# Integer\ry \u0026lt;- 2L\rclass(y)\r## [1] \u0026quot;integer\u0026quot;\r# Compleks\rz \u0026lt;- 5+2i\rclass(z)\r## [1] \u0026quot;complex\u0026quot;\r# string\rw \u0026lt;- \u0026quot;saya\u0026quot;\rclass(w)\r## [1] \u0026quot;character\u0026quot;\r# Raw\rxy \u0026lt;- charToRaw(\u0026quot;hello world\u0026quot;)\rclass(xy)\r## [1] \u0026quot;raw\u0026quot;\rKeenam jenis data tersebut disebut sebagai tipe data atomik. Hal ini disebabkan karena hanya dapat menangani satu tipe data saja. Misalnya hanya numeric atau hanya integer.\nSelain menggunakan fungsi class(), kita dapat pula menggunakan fungsi is_numeric(), is.character(), is.logical(), dan sebagainya berdasarkan jenis data apa yang ingin kita cek. Berbeda dengan fungsi class(), ouput yang dihasilkan pada fungsi seperti is_numeric() adalah nilai Boolean sehingga fungsi ini hanya digunakan untuk mengecek apakah jenis data pada objek sama seperti yang kita pikirkan. Sebagai contoh disajikan pada sintaks berikut:\ndata \u0026lt;- 25\r# Cek apakah objek berisi data numerik\ris.numeric(data)\r## [1] TRUE\r# Cek apakah objek adalah karakter\ris.character(data)\r## [1] FALSE\rKita juga dapat mengubah jenis data menjadi jenis lainnya seperti integer menjadi numerik atau sebaliknya. Fungsi yang digunakan adalah as.numeric() jika ingin mengubah suatu jenis data menjadi numerik. Fungsi lainnya juga dapat digunakan sesuai dengan kita ingin mengubah jenis data objek menjadi jenis data lainnya.\n# Integer\rapel \u0026lt;- 2L\r# Ubah menjadi numerik\ras.numeric(apel)\r## [1] 2\r# Cek\ris.numeric(apel)\r## [1] TRUE\r# Logical\rnangka \u0026lt;- TRUE\r# Ubah logical menjadi numeric\ras.numeric(nangka)\r## [1] 1\r# Karakter\rminum \u0026lt;- \u0026quot;minum\u0026quot;\r# ubah karakter menjadi numerik\ras.numeric(minum)\r## Warning: NAs introduced by coercion\r## [1] NA\r\rNote:  Konversi karakter menjadi numerik akan menghasilkan output NA (not available). R tidak mengetahui bagaimana cara merubah karakter menjadi bentuk numerik.\n\rBerdasarkan Tabel 2, vektor karakter dapat dibuat menggunakan tanda kurung baik double quote (“”) maupun single quote (’’).Jika pada teks yang kita tuliskan mengandung quote maka kita harus menghentikannya menggunakan tanda ( ). Sbegai contoh kita ingin menuliskan `My friend’s name is “Adi”, pada sintaks akan dituliskan:\n\u0026#39;My friend\\`s name is \u0026quot;Adi\u0026quot;\u0026#39;\r## [1] \u0026quot;My friend`s name is \\\u0026quot;Adi\\\u0026quot;\u0026quot;\r# Atau\r\u0026quot;My friend\u0026#39;s name \\\u0026quot;Adi\\\u0026quot;\u0026quot;\r## [1] \u0026quot;My friend\u0026#39;s name \\\u0026quot;Adi\\\u0026quot;\u0026quot;\r\r2.7 Vektor\rVektor merupakan kombinasi berbagai nilai (numerik, karakter, logical, dan sebagainya berdasarkan jenis input data) pada objek yang sma. Pada contoh kasus berikut, pembaca akan memiliki sesuai jenis data input yaituvektor numerik, vector karakter, vektor logical, dll.\n2.7.1 Membuat vektor\rVektor dibuat dengan menggunakan fungsi c()(concatenate) seperti yang disajikan pada sintaks berikut:\n# membuat vektor numerik\rx \u0026lt;- c(3,3.5,4,7)\rx # print vektor\r## [1] 3.0 3.5 4.0 7.0\r# membuat vektor karakter\ry \u0026lt;- c(\u0026quot;Apel\u0026quot;, \u0026quot;Jeruk\u0026quot;, \u0026quot;Rambutan\u0026quot;, \u0026quot;Salak\u0026quot;)\ry # print vektor\r## [1] \u0026quot;Apel\u0026quot; \u0026quot;Jeruk\u0026quot; \u0026quot;Rambutan\u0026quot; \u0026quot;Salak\u0026quot;\r# membuat vektor logical\rt \u0026lt;- c(\u0026quot;TRUE\u0026quot;, \u0026quot;FALSE\u0026quot;, \u0026quot;TRUE\u0026quot;)\rt # print vektor\r## [1] \u0026quot;TRUE\u0026quot; \u0026quot;FALSE\u0026quot; \u0026quot;TRUE\u0026quot;\rselain menginput nilai pada vektor, kita juga dapat memberi nama nilai setiap vektor menggunakan fungsi names().\n# Membuat vektor jumlah buah yang dibeli\rJumlah \u0026lt;- c(5,5,6,7)\rnames(Jumlah) \u0026lt;- c(\u0026quot;Apel\u0026quot;, \u0026quot;Jeruk\u0026quot;, \u0026quot;Rambutan\u0026quot;, \u0026quot;Salak\u0026quot;)\r# Atau\rJumlah \u0026lt;- c(Apel=5, Jeruk=5, Rambutan=6, Salak=7)\r# Print\rJumlah\r## Apel Jeruk Rambutan Salak ## 5 5 6 7\r\rNote:  Vektor hanya dapat memuat satu buah jenis data. Vektor hanya dapat mengandung jenis data numerik saja, karakter saja, dll.\n\rUntuk menentukan panjang sebuah vektor kita dapat menggunakan fungsi lenght().\nlength(Jumlah)\r## [1] 4\r\r2.7.2 Missing Values\rSeringkali nilai pada vektor kita tidak lengkap atau terdapat nilai yang hilang (missing value) pada vektor. Missing value pada R dilambangkan oleh NA(not available). Berikut adalah contoh vektor dengan missing value.\nJumlah \u0026lt;- c(Apel=5, Jeruk=NA, Rambutan=6, Salak=7)\rUntuk mengecek apakah dalam objek terdapat missing value dapat menggunakan fungsi is.na(). ouput dari fungsi tersebut adalah nilai Boolean. Jika terdapat Missing value, maka output yang dihasilkan akan memberikan nilai TRUE.\nis.na(Jumlah)\r## Apel Jeruk Rambutan Salak ## FALSE TRUE FALSE FALSE\r\rNote: \nSelain NA terdapat NaN (not a number) sebagai missing value8. Nilai tersebut muncul ketika fungsi matematika yang digunakan pada proses perhitungan tidak bekerja sebagaimana mestinya. Contoh: 0/0 = NaN\nis.na() juga akan menghasilkan nilai TRUE pada NaN. Untuk membedakannya dengan NA dapat digunakan fungsi is.nan().\n\r\r2.7.3 Subset Pada Vektor\rSubseting vector terdiri atas tiga jenis, yaitu: positive indexing, Negative Indexing, dan .\n\rPositive indexing: memilih elemen vektor berdasarkan posisinya (indeks) dalam kurung siku.\r\r# Subset vektor pada urutan kedua\rJumlah[2]\r## Jeruk ## NA\r# Subset vektor pada urutan 2 dan 4\rJumlah[c(2, 4)]\r## Jeruk Salak ## NA 7\rSelain melalui urutan (indeks), kita juga dapat melakukan subset berdasarkan nama elemen vektornya.\nJumlah[\u0026quot;Jeruk\u0026quot;]\r## Jeruk ## NA\r\rNote:  Indeks pada R dimulai dari 1. Sehingga kolom atau elemen pertama vektor dimulai dari [1]\n\r\rNegative indexing: mengecualikan (exclude) elemen vektor.\r\r# mengecualikan elemen vektor 2 dan 4\rJumlah[-c(2,4)]\r## Apel Rambutan ## 5 6\r# mengecualikan elemen vektor 1 sampai 3\rJumlah[-c(1:3)]\r## Salak ## 7\r\rSubset berdasarkan vektor logical: Hanya, elemen-elemen yang nilai yang bersesuaian dalam vektor pemilihan bernilai TRUE, akan disimpan dalam subset.\r\r\rNote:  panjang vektor yang digunakan untuk subset harus sama.\n\rJumlah \u0026lt;- c(Apel=5, Jeruk=NA, Rambutan=6, Salak=7)\r# selecting vector\rmerah \u0026lt;- c(TRUE, FALSE, TRUE, FALSE)\r# Subset\rJumlah[merah==TRUE]\r## Apel Rambutan ## 5 6\r# Subset untuk elemen vektor bukan missing value\rJumlah[!is.na(Jumlah)]\r## Apel Rambutan Salak ## 5 6 7\r\r2.7.4 Perhitungan Menggunakan Vektor\rJika Anda melakukan operasi dengan vektor, operasi akan diterapkan ke setiap elemen vektor. Contoh disediakan pada sintaks di bawah ini:\npendapatan \u0026lt;- c(2000, 1800, 2500, 3000)\rnames(pendapatan) \u0026lt;- c(\u0026quot;Andi\u0026quot;, \u0026quot;Joni\u0026quot;, \u0026quot;Lina\u0026quot;, \u0026quot;Rani\u0026quot;)\rpendapatan\r## Andi Joni Lina Rani ## 2000 1800 2500 3000\r# Kalikan pendapatan dengan 3\rpendapatan*3\r## Andi Joni Lina Rani ## 6000 5400 7500 9000\rSeperti yang dapat dilihat, R mengalikan setiap elemen dengan bilangan pengali.\nKita juga dapat mengalikan vektor dengan vektor lainnya.Contohnya disajikan pada sintaks berikut:\n# membuat vektor dengan panjang sama dengan dengan vektor pendapatan\rcoefs \u0026lt;- c(2, 1.5, 1, 3)\r# Mengalikan pendapatan dengan vektor coefs\rpendapatan*coefs\r## Andi Joni Lina Rani ## 4000 2700 2500 9000\rBerdasarkan sintaks tersebut dapat terlihat bahwa operasi matematik terhadap masing-masing vektor dapat berlangsung jika panjang vektornya sama.\nBerikut adalah fungsi lain yang dapat digunakan pada operasi matematika vektor.\nmax(x) # memperoleh nilai maksimum x\rmin(x) # memperoleh nilai minimum x\rrange(x) # memperoleh range vektor x\rlength(x) # memperoleh jumlah elemen vektor x\rsum(x) # memperoleh total penjumlahan elemen vektor x\rprod(x) # memeperoleh produk elemen vektor x\rmean(x) # memperoleh nilai rata-rata seluruh elemen vektor x\rsd(x) # standar deviasi vektor x\rvar(x) # varian vektor x\rsort(x) # mengurutkan elemen vektor x dari yang terbesar\rContoh penggunaan fungsi tersebut disajikan beberapa pada sintaks berikut:\n# Menghitung range pendapatan\rrange(pendapatan)\r## [1] 1800 3000\r# menghitung rata-rata dan standar deviasi pendapatan\rmean(pendapatan)\r## [1] 2325\rsd(pendapatan)\r## [1] 537.7422\r\r\r2.8 Matriks\rMatriks seperti Excel sheet yang berisi banyak baris dan kolom (kumpulan bebrapa vektor). Matriks digunakan untuk menggabungkan vektor dengan tipe yang sama, yang bisa berupa numerik, karakter, atau logis. Matriks digunakan untuk menyimpan tabel data dalam R. Baris-baris matriks pada umumnya adalah individu / pengamatan dan kolom adalah variabel.\n2.8.1 Membuat matriks\rUntuk membuat matriks kita dapat menggunakan fungsi cbind() atau rbind(). Berikut adalah contoh sintaks untuk membuat matriks.\n# membuat vektor numerik\rcol1 \u0026lt;- c(5, 6, 7, 8, 9)\rcol2 \u0026lt;- c(2, 4, 5, 9, 8)\rcol3 \u0026lt;- c(7, 3, 4, 8, 7)\r# menggabungkan vektor berdasarkan kolom\rmy_data \u0026lt;- cbind(col1, col2, col3)\rmy_data\r## col1 col2 col3\r## [1,] 5 2 7\r## [2,] 6 4 3\r## [3,] 7 5 4\r## [4,] 8 9 8\r## [5,] 9 8 7\r# Mengubah atau menambahkan nama baris\rrownames(my_data) \u0026lt;- c(\u0026quot;row1\u0026quot;, \u0026quot;row2\u0026quot;, \u0026quot;row3\u0026quot;, \u0026quot;row4\u0026quot;, \u0026quot;row5\u0026quot;)\rmy_data\r## col1 col2 col3\r## row1 5 2 7\r## row2 6 4 3\r## row3 7 5 4\r## row4 8 9 8\r## row5 9 8 7\r\rNote: \n\rcbind(): menggabungkan objek R berdasarkan kolom\rrbind(): menggabungkan objek R berdasarkan baris\rrownames(): mengambil atau menetapkan nama-nama baris dari objek seperti-matriks\rcolnames(): mengambil atau menetapkan nama-nama kolom dari objek seperti-matriks\r\r\rKita dapat melakukan tranpose (merotasi matriks sehingga kolom menjadi baris dan sebaliknya) menggunakan fungsi t(). Berikut adalah contoh penerapannya:\nt(my_data)\r## row1 row2 row3 row4 row5\r## col1 5 6 7 8 9\r## col2 2 4 5 9 8\r## col3 7 3 4 8 7\rSelain melalui pembentukan sejumlah objek vektor, kita juga dapat membuat matriks menggunakan fungsi matrix(). Secara sederhana fungsi tersebut dapat dituliskan sebagai berikut:\nmatrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE,\rdimnames = NULL)\r\rNote: \n\rdata: vektor data opsional\rnrow, ncol: jumlah baris dan kolom yang diinginkan, masing-masing.\rbyrow: nilai logis. Jika FALSE (default) matriks diisi oleh kolom, jika tidak, matriks diisi oleh baris.\rdimnames: Daftar dua vektor yang memberikan nama baris dan kolom masing-masing.\r\r\rDalam kode R di bawah ini, data input memiliki panjang 6. Kita ingin membuat matriks dengan dua kolom. Kita tidak perlu menentukan jumlah baris (di sini nrow = 3). R akan menyimpulkan ini secara otomatis. Matriks diisi kolom demi kolom saat argumen byrow = FALSE. Jika kita ingin mengisi matriks dengan baris, gunakan byrow = TRUE. Berikut adalah contoh pembuatan matriks menggunakan fungsi matrix().\ndata \u0026lt;- matrix(\rdata = c(1,2,3, 11,12,13), nrow = 2, byrow = TRUE,\rdimnames = list(c(\u0026quot;row1\u0026quot;, \u0026quot;row2\u0026quot;), c(\u0026quot;C.1\u0026quot;, \u0026quot;C.2\u0026quot;, \u0026quot;C.3\u0026quot;))\r)\rdata\r## C.1 C.2 C.3\r## row1 1 2 3\r## row2 11 12 13\rUntuk mengetahui dimensi dari suatu matriks, kita dapat menggunakan fungsi ncol() untuk mengetahui jumlah kolom matriks dan nrow() untuk mengetahui jumlah baris pada matriks. Berikut adalah contoh penerapannya:\n# mengetahui jumlah kolom\rncol(my_data)\r## [1] 3\r# mengetahui jumlah baris\rnrow(my_data)\r## [1] 5\rJika ingin memperoleh ringkasan terkait dimensi matriks kita juga dapat mengunakan fungsi dim() untuk mengetahui jumlah baris dan kolom matriks. Berikut adalah contoh penerapannya:\ndim(my_data) # jumlah baris dan kolom\r## [1] 5 3\r\r2.8.2 Subset Pada Matriks\rSama dengan vektor, subset juga dapat dilakukan pada matriks. Bedanya subset dilakukan berdasarkan baris dan kolom pada matriks.\n\rMemilih baris/kolom berdasarkan pengindeksan positif\r\rbaris atau kolom dapat diseleksi menggunakan format data[row, col]. Cara selesi ini sama dengan vektor, bedanya kita harus menetukan baris dan kolom dari data yang akan kita pilih. Berikut adalah contoh penerapannya:\n# Pilih baris ke-2\rmy_data[2,]\r## col1 col2 col3 ## 6 4 3\r# Pilih baris 2 sampai 4\rmy_data[2:4,]\r## col1 col2 col3\r## row2 6 4 3\r## row3 7 5 4\r## row4 8 9 8\r# Pilih baris 2 dan 4\rmy_data[c(2,4),]\r## col1 col2 col3\r## row2 6 4 3\r## row4 8 9 8\r# Pilih baris 2 dan kolom 3\rmy_data[2, 3]\r## [1] 3\r\rPilih berdasarkan nama baris/kolom\r\rBerikut adalah contoh subset berdasarkan nama baris atau kolom.\n# Pilih baris 1 dan kolom 3\rmy_data[\u0026quot;row1\u0026quot;,\u0026quot;col3\u0026quot;]\r## [1] 7\r# Pilih baris 1 sampai 4 dan kolom 3\rbaris \u0026lt;- c(\u0026quot;row1\u0026quot;,\u0026quot;row2\u0026quot;,\u0026quot;row3\u0026quot;)\rmy_data[baris, \u0026quot;col3\u0026quot;]\r## row1 row2 row3 ## 7 3 4\r\rKecualikan baris/kolom dengan pengindeksan negatif\r\rSama seperti vektor pengecualian data dapat dilakukan di matriks menggunakan pengindeksan negatif. Berikut cara melakukannya:\n# Kecualikan baris 2 dan 3 serta kolom 3\rmy_data[-c(2,3), -3]\r## col1 col2\r## row1 5 2\r## row4 8 9\r## row5 9 8\r\rPilihan dengan logik\r\rDalam kode R di bawah ini, misalkan kita ingin hanya menyimpan baris di mana col3\u0026gt; = 4:\ncol3 \u0026lt;- my_data[, \u0026quot;col3\u0026quot;]\rmy_data[col3 \u0026gt;= 4, ]\r## col1 col2 col3\r## row1 5 2 7\r## row3 7 5 4\r## row4 8 9 8\r## row5 9 8 7\r\r2.8.3 Perhitungan Menggunakan Matriks\r_ Kita juga dapat melakukan operasi matematika pada matriks. Pada operasi matematika pada matriks proses yang terjadi bisa lebih kompleks dibanding pada vektor, dimana kita dapat melakukan operasi untuk memperoleh gambaran data pada tiap kolom atau baris.\nBerikut adalah contoh operasi matematika sederhana pada matriks:\n# mengalikan masing-masing elemen matriks dengan 2\rmy_data*2\r## col1 col2 col3\r## row1 10 4 14\r## row2 12 8 6\r## row3 14 10 8\r## row4 16 18 16\r## row5 18 16 14\r# memperoleh nilai log basis 2 pada masing-masing elemen matriks\rlog2(my_data)\r## col1 col2 col3\r## row1 2.321928 1.000000 2.807355\r## row2 2.584963 2.000000 1.584963\r## row3 2.807355 2.321928 2.000000\r## row4 3.000000 3.169925 3.000000\r## row5 3.169925 3.000000 2.807355\rSeperti yang telah penulis jelaskan sebelumnya, kita juga dapat melakukan operasi matematika untuk memperoleh hasil penjumlahan elemen pada tiap baris atau kolom dengan menggunakan fungsi rowSums() untuk baris dan colSums() untuk kolom.\n# Total pada tiap kolom\rcolSums(my_data)\r## col1 col2 col3 ## 35 28 29\r# Total pada tiap baris\rrowSums(my_data)\r## row1 row2 row3 row4 row5 ## 14 13 16 25 24\rJika kita tertarik untuk mencari nilai rata-rata tiap baris arau kolom kita juga dapat menggunakan fungsi rowMeans() atau colMeans(). Berikut adalah contoh penerapannya:\n# Rata-rata tiap baris\rrowMeans(my_data)\r## row1 row2 row3 row4 row5 ## 4.666667 4.333333 5.333333 8.333333 8.000000\r# Rata-rata tiap kolom\rcolMeans(my_data)\r## col1 col2 col3 ## 7.0 5.6 5.8\rKita juga dapat melakukan perhitungan statistika lainnya menggunakan fungsi apply(). Berikut adalah format sederhananya:\napply(x, MARGIN, FUN)\r\rNote: \n\rx : data matriks\rMARGIN : Nilai yang dapat digunakan adalah 1 (untuk operasi pada baris) dan 2 (untuk operasi pada kolom)\rFUN : fungsi yang diterapkan pada baris atau kolom\r\r\runtuk mengetahui fungsi (FUN) apa saja yang dapat diterapkan pada fungsi apply() jalankan sintaks bantuan berikut:\nhelp(apply)\rBerikut adalah contoh penerapannya:\n# Rata-rata pada tiap baris\rapply(my_data, 1, mean)\r## row1 row2 row3 row4 row5 ## 4.666667 4.333333 5.333333 8.333333 8.000000\r# Median pada tiap kolom\rapply(my_data, 2, median)\r## col1 col2 col3 ## 7 5 7\r\r\r2.9 Faktor\rDalam bahasa R , faktor merupakan verktor dengan level. Level disimpan sebagai R Character. Jika kita menggunakan SPSS maka factor ini akan sama dengan jenis data numerik atau ordinal.\nFaktor merepresentasikan kategori atau grup pada data. Untuk membuat faktor pada R, kita dapat menggunakan fungsi factor().\n2.9.1 Membuat Variabel Faktor\rBerikut adalah contoh sintaks pembuatan variabel faktor.\n# membuat variabel faktor\rfaktor \u0026lt;- factor(c(1,2,1,2))\rfaktor\r## [1] 1 2 1 2\r## Levels: 1 2\rPada sintaks tersebut objek faktor terdiri atas dua buah kategori atau pada R disebut sebagai factor levels. Kita dapat mengecek factor levels menggunakan fungsi levels().\nlevels(faktor)\r## [1] \u0026quot;1\u0026quot; \u0026quot;2\u0026quot;\rKita juga dapat memberikan label atau mengubah level pada faktor. Berikut adalah contoh bagaimana kita melakukannya:\n# Ubah level\rlevels(faktor) \u0026lt;- c(\u0026quot;baik\u0026quot;,\u0026quot;tidak_baik\u0026quot;)\rfaktor\r## [1] baik tidak_baik baik tidak_baik\r## Levels: baik tidak_baik\r# Ubah urutan level\rfaktor \u0026lt;- factor(faktor,\rlevels = c(\u0026quot;tidak_baik\u0026quot;,\u0026quot;baik\u0026quot;))\rfaktor\r## [1] baik tidak_baik baik tidak_baik\r## Levels: tidak_baik baik\r\rNote: \n\rFungsi is.factor() dapat digunakan untuk mengecek apakah sebuah variabel adalah faktor. Hasil yang dimunculkan dapat berupa TRUE (jika faktor) atau FALSE (jika bukan)\rFungsi as.factor() dapat digunakan untuk merubah sebuah variabel menjadi faktor.\r\r\r# Cek jika objek faktor adalah faktor\ris.factor(faktor)\r## [1] TRUE\r# Cek jika objek Jumlah adalah faktor\ris.factor(Jumlah)\r## [1] FALSE\r# Ubah objek Jumlah menjadi faktor\ras.factor(Jumlah)\r## Apel Jeruk Rambutan Salak ## 5 \u0026lt;NA\u0026gt; 6 7 ## Levels: 5 6 7\r\r2.9.2 Perhitungan Menggunakan Faktor\rJika kita ingin mengetahui jumlah masing-masing observasi pada masing-masing faktor, kita dapat menggunakan fungsi summary(). Berikut adalah contoh penerapannya:\nsummary(faktor)\r## tidak_baik baik ## 2 2\rPada contoh perhitungan menggunakan vektor kita telah membuat objek pendapatan. Pada objek tersebut kita ingin menghitung nilai rata-rata pendapatan berdasarkan objek faktor. Untuk melakukannya kita dapat menggunakan fungsi tapply().\npendapatan\r## Andi Joni Lina Rani ## 2000 1800 2500 3000\rfaktor\r## [1] baik tidak_baik baik tidak_baik\r## Levels: tidak_baik baik\r# Rata-rata pendapatan dan simpan sebagai objek dengan nama:\r# mean_pendapatan\rmean_pendapatan \u0026lt;- tapply(pendapatan, faktor, mean)\rmean_pendapatan\r## tidak_baik baik ## 2400 2250\r# Hitung ukuran/panjang masing-masing grup\rtapply(pendapatan, faktor, length)\r## tidak_baik baik ## 2 2\rUntuk mengetahui jumlah masing-masing observasi masing-masing factor levels kita juga dapat menggunakan fungsi table(). Fungsi tersebut akan membuat frekuensi tabel pada masing-masing factor levels atau yang dikenal sebagai contingency table.\ntable(faktor)\r## faktor\r## tidak_baik baik ## 2 2\r# Cross-tabulation antara\r# faktor dan pendapatan\rtable(pendapatan, faktor)\r## faktor\r## pendapatan tidak_baik baik\r## 1800 1 0\r## 2000 0 1\r## 2500 0 1\r## 3000 1 0\r\r\r2.10 Data Frames\rData frame merupakan kumpulan vektor dengan panjang sama atau dapat pula dikatan sebagai matriks yang memiliki kolom dengan jenis data yang berbeda-beda (numerik, karakter, logical). Pada data frame terdapat baris dan kolom. Baris disebut sebagai observasi, sedangkan kolom disebut sebagai variabel. Sehingga dapat dikatakan bahwa setiap observasi akan memiliki satu atau beberapa variabel.\n2.10.1 Membuat Data Frame\rData frame dapat dibuat menggunakan fungsi data.frame(). Berikut adalah contoh cara membuat data frame:\n# Membuat data frame\rnama \u0026lt;- c(\u0026quot;Andi\u0026quot;,\u0026quot;Rizal\u0026quot;,\u0026quot;Ani\u0026quot;,\u0026quot;Ina\u0026quot;)\rpendapatan \u0026lt;- c(1000, 2000, 3500, 500)\rtinggi \u0026lt;- c(160, 155, 170, 146)\rusia \u0026lt;- c(35, 40, 25, 27)\rmenikah \u0026lt;- c(TRUE, FALSE, TRUE, TRUE)\rdata_teman \u0026lt;- data.frame(nama = nama,\rgaji = pendapatan,\rtinggi = tinggi,\rmenikah = menikah)\rdata_teman\r## nama gaji tinggi menikah\r## 1 Andi 1000 160 TRUE\r## 2 Rizal 2000 155 FALSE\r## 3 Ani 3500 170 TRUE\r## 4 Ina 500 146 TRUE\rUntuk mengecek apakah objek data_teman merupakan data frame, kita dapat menggunakan fungsi is.data.frame(). Jika hasilnya TRUE, maka objek tersebut adalah data frame. Berikut adalah contoh penerapannya:\nis.data.frame(data_teman)\r## [1] TRUE\r\rNote:  untuk konversi objek menjadi data frame, kita dapat menjalankan fungsi as.data.frame().\n\r\r2.10.2 Subset Pada Data Frame\rSubset pada data frame sebenarnya tidak berbeda dengan subset pada matriks. Bedanya adalah kita juga bisa melakukan subset langsung terhadap nama variabel menggunakan dollar sign. Untuk lebih memahaminya berikut adalah jenis subset pada data frame.\n\rPengindeksan positif menggunakan nama dan lokasi.\r\r# Subset menggunakan dollar sign\rdata_teman$nama\r## [1] Andi Rizal Ani Ina ## Levels: Andi Ani Ina Rizal\r# atau data_teman[, \u0026quot;nama\u0026quot;]\r## [1] Andi Rizal Ani Ina ## Levels: Andi Ani Ina Rizal\r# subset baris 1 sampai 3 serta kolom 1 dan 3\rdata_teman[1:3, c(1,3)]\r## nama tinggi\r## 1 Andi 160\r## 2 Rizal 155\r## 3 Ani 170\r\rPengindeksan negatif\r\r# Kecualikan kolom nama\rdata_teman[,-1]\r## gaji tinggi menikah\r## 1 1000 160 TRUE\r## 2 2000 155 FALSE\r## 3 3500 170 TRUE\r## 4 500 146 TRUE\r\rPengideksan berdasarkan karakteristik\r\rKita ingin memilih data dengan kriteria teman yang telah menikah\ndata_teman[data_teman$menikah==TRUE, ]\r## nama gaji tinggi menikah\r## 1 Andi 1000 160 TRUE\r## 3 Ani 3500 170 TRUE\r## 4 Ina 500 146 TRUE\r# Tampilkan hanya kolom nama dan gaji untuk yang telah menikah\rdata_teman[data_teman$menikah==TRUE, 1:2]\r## nama gaji\r## 1 Andi 1000\r## 3 Ani 3500\r## 4 Ina 500\rkita juga dapat menggunakan fungsi subset() agar lebih mudah. Berikut adalah contoh penerapannya:\n# subset terhadap teman yang berusia \u0026gt;=30 tahun\rsubset(data_teman, usia\u0026gt;=30)\r## nama gaji tinggi menikah\r## 1 Andi 1000 160 TRUE\r## 2 Rizal 2000 155 FALSE\rOpsi lain adalah menggunakan fungsi attach() dan detach(). Fungsi attach() mengambil data frame dan membuat kolomnya dapat diakses hanya dengan memberikan nama mereka.\n# attach data frame\rattach(data_teman)\r## The following objects are masked _by_ .GlobalEnv:\r## ## menikah, nama, tinggi\r# ==== memulai data manipulation ====\rdata_teman[usia\u0026gt;=30]\r## nama gaji\r## 1 Andi 1000\r## 2 Rizal 2000\r## 3 Ani 3500\r## 4 Ina 500\r# ==== mengakhiri data manipulation ====\r# detach data frame\rdetach(data_teman)\r\r2.10.3 Memperluas Data Frame\rKita dapat juga memperluas data frame dengan cara menambahkan variabel atau kolombaru pada data frame. Pada contoh kali ini penulis akan menambahkan kolom pendidikan terakhir pada objek data_teman. Berikut adalah sintaks yang digunakan.\n# membuat vektor pendidikan\rpendidikan \u0026lt;- c(\u0026quot;S1\u0026quot;,\u0026quot;S2\u0026quot;,\u0026quot;D3\u0026quot;,\u0026quot;D1\u0026quot;)\r# menambahkan variabel pendidikan pada data frame\rdata_teman$pendidikan \u0026lt;- pendidikan\r# atau\rcbind(data_teman, pendidikan=pendidikan)\r\r2.10.4 Perhitungan Pada Data Frame\rPerhitungan pada variabel numerik data frame pada dasarnya sama dengan perhitungan pada matriks. kita dapat menggunakan fungsi rowSums(), colSums(), rowMeans() dan apply(). Proses perhitungan dan manipulasi pada data frame akan dibahas pada sesi yang lain secara lebih detail.\n\r\r2.11 List\rList adalah kumpulan objek yang diurutkan, yang dapat berupa vektor, matriks, data frame, dll. Dengan kata lain, daftar dapat berisi semua jenis objek R.\n2.11.1 Membuat List\rList dapat dibuat menggunakan fungsi list(). Berikut disajikan contoh sebuah list sebuah keluarga:\n# Membuat list keluarga\rkeluarga \u0026lt;- list(\rayah = \u0026quot;Budi\u0026quot;,\rusia_ayah = 48,\ribu = \u0026quot;Ani\u0026quot;,\rusia_ibu = \u0026quot;47\u0026quot;,\ranak = c(\u0026quot;Andi\u0026quot;, \u0026quot;Adi\u0026quot;),\rusia_anak = c(15,10)\r)\r# Print\rkeluarga\r## $ayah\r## [1] \u0026quot;Budi\u0026quot;\r## ## $usia_ayah\r## [1] 48\r## ## $ibu\r## [1] \u0026quot;Ani\u0026quot;\r## ## $usia_ibu\r## [1] \u0026quot;47\u0026quot;\r## ## $anak\r## [1] \u0026quot;Andi\u0026quot; \u0026quot;Adi\u0026quot; ## ## $usia_anak\r## [1] 15 10\r# Nama elemen dalam list\rnames(keluarga)\r## [1] \u0026quot;ayah\u0026quot; \u0026quot;usia_ayah\u0026quot; \u0026quot;ibu\u0026quot; \u0026quot;usia_ibu\u0026quot; \u0026quot;anak\u0026quot; \u0026quot;usia_anak\u0026quot;\r# Jumlah elemen pada list\rlength(keluarga)\r## [1] 6\r\r2.11.2 Subset List\rKita dapat memilih sebuah elemen pada list dengan menggunakan nama elemen atau indeks dari elemen tersebut. Berikut adalah contoh penerapannya:\n# Subset berdasarkan nama\r# mengambil elemen usia_ayah\rkeluarga$usia_ayah\r## [1] 48\r# Atau\rkeluarga[[\u0026quot;usia_ayah\u0026quot;]]\r## [1] 48\r# Subset berdasarkan indeks\rkeluarga[[2]]\r## [1] 48\r# subset elemen pertama pada keluarga[[5]]\rkeluarga[[5]][1]\r## [1] \u0026quot;Andi\u0026quot;\r\r2.11.3 Memperluas List\rKita juga dapat menambahkan elemen pada list yang telah kita buat. Pada contoh list sebelumnya penulis akan menambahkan elemen keluarga yang lain seperti berikut:\n# Menambahkan kakek dan nenek pada list\rkeluarga$kakek \u0026lt;- \u0026quot;Suprapto\u0026quot;\rkeluarga$nenek \u0026lt;- \u0026quot;Sri\u0026quot;\r# Print\rkeluarga\r## $ayah\r## [1] \u0026quot;Budi\u0026quot;\r## ## $usia_ayah\r## [1] 48\r## ## $ibu\r## [1] \u0026quot;Ani\u0026quot;\r## ## $usia_ibu\r## [1] \u0026quot;47\u0026quot;\r## ## $anak\r## [1] \u0026quot;Andi\u0026quot; \u0026quot;Adi\u0026quot; ## ## $usia_anak\r## [1] 15 10\r## ## $kakek\r## [1] \u0026quot;Suprapto\u0026quot;\r## ## $nenek\r## [1] \u0026quot;Sri\u0026quot;\rKita juga dapat menggabungkan beberapa list menjadi satu. Berikut adalah format sederhana bagaimana cara menggabungkan beberapa list menjadi satu:\nlist_baru \u0026lt;- c(list_a, list_b, list_c, ...)\r\r\r2.12 Loop\rLoop merupakan kode program yang berulang-ulang. Loop berguna saat kita ingin melakukan sebuah perintah yang perlu dijalankan berulang-ulang seperti melakukan perhitungan maupaun melakukan visualisasi terhadap banyak variabel secara serentak. Hal ini tentu saja membantu kita karena kita tidak perlu menulis sejumlah sintaks yang berulang-ulang. Kita hanya perlu mengatur statement berdasarkan hasil yang kita harapkan.\nPada R bentuk loop dapat bermacam-macam (“for loop”,“while loop”, dll). R menyederhanakan bentuk loop ini dengan menyediakan sejumlah fungsi seperti apply(),tapply(), dll. Sehingga loop jarang sekali muncul dalam kode R. Sehingga R sering disebut sebagai loopless loop.\nMeski loop jarang muncul bukan berarti kita tidak akan melakukannya. Terkadang saat kita melakukan komputasi statistik atau matematik dan belum terdapat paket yang mendukung proses tersebut, sering kali kita akan membuat sintaks sendiri berdasarkan algoritma metode tersebut. Pada algoritma tersebut sering pula terdapat loop yang diperlukan selama proses perhitungan. Secara sederhana diagram umum loop ditampilkan pada Figure 1\n## Warning: package \u0026#39;knitr\u0026#39; was built under R version 3.5.3\r\rFigure 1: Diagram umum loop (sumber: Primartha, 2018).\r\r2.12.1 For Loop\rMengulangi sebuah statement atau sekelompok statement sebanyak nilai yang ditentukan di awal. Jadi operasi akan terus dilakukan sampai dengan jumlah yang telah ditetapkan di awal atau dengan kata lain tes kondisi (Jika jumlah pengulangan telah cukup) hanya akan dilakukan di akhir. Secara sederhana bentuk dari for loop dapat dituliskan sebagai berikut:\nfor (value in vector){\rstatements\r}\rBerikut adalah contoh sintaks penerapan for loop:\n# Membuat vektor numerik\rvektor \u0026lt;- c(1:5)\r# loop for(i in vektor){\rprint(i)\r}\r## [1] 1\r## [1] 2\r## [1] 3\r## [1] 4\r## [1] 5\rLoop akan dimulai dari blok statement for sampai dengan print(i). Berdasarkan loop pada contoh tersebut, loop hanya dilakukan sebanyak 5 kali sesuai dengan jumlah vektor yang ada.\n\r2.12.2 While Loop\rWhile loop merupakan loop yang digunakan ketika kita telah menetapkan stop condition sebelumnya. Blok statement/kode yang sama akan terus dijalankan sampai stop condition ini tercapai. Stop condition akan di cek sebelum melakukan proses loop. Berikut adalah pola dari while loop dapat dituliskan sebagai berikut:\nwhile (test_expression){\rstatement\r}\rBerikut adalah contoh penerapan dari while loop:\ncoba \u0026lt;- c(\u0026quot;Contoh\u0026quot;)\rcounter \u0026lt;- 1\r# loop\rwhile (counter\u0026lt;5){\r# print vektor\rprint(coba)\r# tambahkan nilai counter sehingga proses terus berlangsung sampai counter = 5 counter \u0026lt;- counter + 1\r}\r## [1] \u0026quot;Contoh\u0026quot;\r## [1] \u0026quot;Contoh\u0026quot;\r## [1] \u0026quot;Contoh\u0026quot;\r## [1] \u0026quot;Contoh\u0026quot;\rLoop akan dimulai dari blok statement while sampai dengan counter \u0026lt;- 1. Loop hanya akan dilakukan sepanjang nilai counter \u0026lt; 5.\n\r2.12.3 Repeat Loop\rRepeat loop akan menjalankan statement/kode yang sama berulang-ulang hingga stop condition tercapai. Berikut adalah pola dari repeat loop.\nrepeat {\rcommands\rif(condition){\rbreak\r}\r}\rBerikut adalah contoh penerapan dari repeat loop:\ncoba \u0026lt;- c(\u0026quot;contoh\u0026quot;)\rcounter \u0026lt;- 1\rrepeat {\rprint(coba)\rcounter \u0026lt;- counter + 1\rif(counter \u0026lt; 5){\rbreak\r}\r}\r## [1] \u0026quot;contoh\u0026quot;\rLoop akan dimulai dari blok statement while sampai dengan break. Loop hanya akan dilakukan sepanjang nilai counter \u0026lt; 5. Hasil yang diperoleh berbeda dengan while loop, dimana kita memperoleh 4 buah kata “contoh”. Hal ini disebabkan karena repeat loop melakukan pengecekan stop condition tidak di awal loop seperti while loop sehingga berapapun nilainya, selama nilainya sesuai dengan stop condition maka loop akan dihentikan. Hal ini berbeda dengan while loop dimana proses dilakukan berulang-ulang sampai jumlahnya mendekati stop condition.\n\r2.12.4 Break\rBreak sebenarnya bukan bagian dari loop, namun sering digunakan dalam loop. Break dapat digunakan pada loop manakala dirasa perlu, yaitu saat kondisi yang disyaratkan pada break tercapai.\nBerikut adalah contoh penerapan break pada beberapa jenis loop.\n# for loop\ra = c(2,4,6,8,10,12,14)\rfor(i in a){\rif(i\u0026gt;8){\rbreak\r}\rprint(i)\r}\r## [1] 2\r## [1] 4\r## [1] 6\r## [1] 8\r# while loop\ra = 2\rb = 4\rwhile(a\u0026lt;7){\rprint(a)\ra = a +1\rif(b+a\u0026gt;10){\rbreak\r}\r}\r## [1] 2\r## [1] 3\r## [1] 4\r## [1] 5\r## [1] 6\r# repeat loop\ra = 1\rrepeat{\rprint(a)\ra = a+1\rif(a\u0026gt;6){\rbreak\r}\r}\r## [1] 1\r## [1] 2\r## [1] 3\r## [1] 4\r## [1] 5\r## [1] 6\r\r\r2.13 Decision Making\rDecicion Making atau sering disebut sebagai if then else statement merupakan bentuk percabagan yang digunakan manakala kita ingin agar program dapat melakukan pengujian terhadap syarat kondisi tertentu. Pada Table 5 disajikan daftar percabangan yang digunakan pada R.\nTable 5 Daftar percabangan pada R\n\r\r\r\rStatement\rKeterangan\r\r\r\rif statement\rif statement hanya terdiri atas sebuah ekspresi Boolean, dan diikuti satu atau lebih statement\r\rif…else statement\rif else statement terdiri atas beberapa buah ekspresi Boolean. Ekspressi Boolean berikutnya akan dijalankan jika ekspresi *Boolan sebelumnya bernilai FALSE\r\rswitch statement\rswitch statement digunakan untuk mengevaluasi sebuah variabel beberapa pilihan\r\r\r\r2.13.1 if statement\rPola if statement disajikan pada Figure 2\n\rFigure 2: Diagram if statement (sumber: Primartha, 2018).\r\rBerikut adalah contoh penerapan if statement:\nx \u0026lt;- c(1:5)\rif(is.vector(x)){\rprint(\u0026quot;x adalah sebuah vector\u0026quot;)\r}\r## [1] \u0026quot;x adalah sebuah vector\u0026quot;\r\r2.13.2 if else statement\rPola dari if else statement disajikan pada Figure 3\n\rFigure 3: Diagram if else statement (sumber: Primartha, 2018).\r\rBerikut adalah contoh penerapan if else statement:\nx \u0026lt;- c(\u0026quot;Andi\u0026quot;,\u0026quot;Iwan\u0026quot;, \u0026quot;Adi\u0026quot;)\rif(\u0026quot;Rina\u0026quot; %in% x){\rprint(\u0026quot;Rina ditemukan\u0026quot;)\r} else if(\u0026quot;Adi\u0026quot; %in% x){\rprint(\u0026quot;Adi ditemukan\u0026quot;)\r} else{\rprint(\u0026quot;tidak ada yang ditemukan\u0026quot;)\r}\r## [1] \u0026quot;Adi ditemukan\u0026quot;\r\r2.13.3 switch statement\rPola dari switch statement disajikan pada Figure 4\n\rFigure 4: Diagram switch statement (sumber: Primartha, 2018).\r\rBerikut adalah contoh penerapan switch statement:\ny = 3\rx = switch(\ry,\r\u0026quot;Selamat Pagi\u0026quot;,\r\u0026quot;Selamat Siang\u0026quot;,\r\u0026quot;Selamat Sore\u0026quot;,\r\u0026quot;Selamat Malam\u0026quot;\r)\rprint(x)\r## [1] \u0026quot;Selamat Sore\u0026quot;\r\r\r2.14 Fungsi\rFungsi merupakan sekumpulan instruksi atau statement yang dapat melakukan tugas khusus. Sebagai contoh fungsi perkalian untuk menyelesaikan operasi perkalian, fungsi pemangkatan hanya untuk operasi pemangkatan, dll.\nPada R terdapat 2 jenis fungsi, yaitu: build in fuction dan user define function. build in fnction merupakan fungsi bawaan R saat pertama kita menginstall R. Contohnya adalah mean(), sum(), ls(), rm(), dll. Sedangkan user define fuction merupakan fungsi-fungsi yang dibuat sendiri oleh pengguna.\nFungsi-fungsi buatan pengguna haruslah dideklarasikan (dibuat) terlebih dahulu sebelum dapat dijalankan. Pola pembentukan fungsi adalah sebagai berikut:\nfunction_name \u0026lt;- function(argument_1, argument_2, ...){\rfunction body\r}\r\rNote: \n\rfunction_name : Nama dari fungsi R. R akan menyimpan fungsi tersebut sebagai objek\rargument_1, argument_2,… : Argument bersifat opsional (tidak wajib). Argument dapat digunakan untuk memberi inputan kepada fungsi\rfunction body : Merupakan inti dari fungsi. Fuction body dapat terdiri atas 0 statement (kosong) hingga banyak statement.\rreturn : Fungsi ada yang memiliki output atau return value ada juga yang tidak. Jika fungsi memiliki return value maka return value dapat diproses lebih lanjut\r\r\rBerikut adalah contoh penerapan user define function:\n# Fungsi tanpa argument\rbilang \u0026lt;- function(){\rprint(\u0026quot;Hello World!!\u0026quot;)\r}\r# Print\rbilang()\r## [1] \u0026quot;Hello World!!\u0026quot;\r# Fungsi dengan argumen\rtambah \u0026lt;- function(a,b){\rprint(a+b)\r}\r# Print\rtambah(5,3)\r## [1] 8\r# Fungsi dengan return value\rkali \u0026lt;- function(a,b){\rreturn(a*b)\r}\r# Print\rkali(4,3)\r## [1] 12\rReferensi\nPrimartha, R. 2018. Belajar Machine Learning Teori dan Praktik. Penerbit Informatika : Bandung.\rRosadi,D. 2016. Analisis Statistika dengan R. Gadjah Mada University Press: Yogyakarta.\rSTHDA. Easy R Programming Basics. http://www.sthda.com/english/wiki/easy-r-programming-basics\rVenables, W.N. Smith D.M. and R Core Team. 2018. An Introduction to R. R Manuals.\rThe R Core Team. 2018. R: A Language and Environment for Statistical Computing. R Manuals.\r\r\r","date":1552064400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1552064400,"objectID":"04b73e5721338a9dc2554955dc4acf7e","permalink":"/tutorial/02_sintaks-bahasa-r/","publishdate":"2019-03-09T00:00:00+07:00","relpermalink":"/tutorial/02_sintaks-bahasa-r/","section":"tutorial","summary":"body{\rtext-align: justify}\r\r\rDaftar Isi\r\rOperator Aritmatika\rFungsi Aritmetik\rOperator Relasi\rOperator Logika\rMemasukkan Nilai Kedalam Variabel\rTipe Data\rVektor\rMatriks\rFaktor\rData Frames\rList\rLoop\rDecision Making\rFungsi\r\r\r2.1 Operator Aritmatika\rProses perhitungan akan ditangani oleh fungsi khusus. R akan memahami urutannya secara benar. Kecuali kita secara eksplisit menetapkan yang lain. Sebagai contoh jalankan sintaks berikut:\n2+4*2\r## [1] 10\rBandingkan dengan sintaks berikut:","tags":null,"title":"2. Sintaks Bahasa R","type":"docs"},{"authors":null,"categories":null,"content":"\r\rbody{\rtext-align: justify}\r\r\rDaftar Isi\n\rVisualisasi Data Menggunakan Fungsi plot\rMatriks Scatterplot\rBox plot\rBar Plot\rLine Plot\rPie Chart\rHistogram dan Density Plot\rQQ Plot\rDot Chart\rKustomisasi Parameter Grafik\r\r\r4.1 Visualisasi Data Menggunakan Fungsi plot()\rFungsi plot() merupakan fungsi umum yang digunakan untuk membuat plot pada R. Format dasarnya adalah sebagai berikut:\nplot(x, y, type=\u0026quot;p\u0026quot;)\r\rNote: \n\rx dan y: titik koordinat plot Berupa variabel dengan panjang atau jumlah observasi yang sama.\rtype: jenis grafik yang hendak dibuat. Nilai yang dapat dimasukkan antara lain:\rtype=“p” : membuat plot titik atau scatterplot. Nilai ini merupakan default pada fungsi plot().\rtype=“l” : membuat plot garis.\rtype=“b” : membuat plot titik yang terhubung dengan garis.\rtype=“o” : membuat plot titik yang ditimpa oleh garis.\rtype=“h” : membuat plot garis vertikal dari titik ke garis y=0.\rtype=“s” : membuat fungsi tangga.\rtype=“n” : tidak membuat grafik plot sama sekali, kecuali plot dari axis. Dapat digunakan untuk mengatur tampilan suatu plot utama yang diikuti oleh sekelompok plot tambahan.\r\r\rUntuk lebih memahaminya berikut penulis akan sajikan contoh untuk masing-masing grafik tersebut. Berikut adalah contoh sintaks dan hasil plot yang disajikan pada Figure 1:\n# membuat vektor data x \u0026lt;- c(1:10); y \u0026lt;- x^2\r# membagi jendela grafik menajdi 4 baris dan 2 kolom\rpar(mfrow=c(3,3))\r# loop\rtype \u0026lt;- c(\u0026quot;p\u0026quot;,\u0026quot;l\u0026quot;,\u0026quot;b\u0026quot;,\u0026quot;o\u0026quot;,\u0026quot;h\u0026quot;,\u0026quot;s\u0026quot;,\u0026quot;n\u0026quot;)\rfor (i in type){\rplot(x,y, type= i,\rmain= paste(\u0026quot;type=\u0026quot;, i))\r}\r\rFigure 1: Plot berbagai jenis setting type\r\rPada contoh selanjutnya akan dilakukan plot terhadap dataset trees. Untuk memuatnya jalankan sintaks berikut:\nlibrary(tibble)\r## Warning: package \u0026#39;tibble\u0026#39; was built under R version 3.5.3\r# memuat dataset\rtrees \u0026lt;- as_tibble(trees)\r# print trees\r## # A tibble: 31 x 3\r## Girth Height Volume\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 8.3 70 10.3\r## 2 8.6 65 10.3\r## 3 8.8 63 10.2\r## 4 10.5 72 16.4\r## 5 10.7 81 18.8\r## 6 10.8 83 19.7\r## 7 11 66 15.6\r## 8 11 75 18.2\r## 9 11.1 80 22.6\r## 10 11.2 75 19.9\r## # ... with 21 more rows\rPada dataset tersebut kita ingin membuat scatterplot untuk melihat korelasi antara variabel Height dan Volume. Untuk melakukannya jalankan sintaks berikut:\nplot(trees$Height, trees$Volume)\r# atau with(trees, plot(Height, Volume))\r\rFigure 2: Scatterplot Height vs Volume\r\rKita juga dapat menggunakan formula untuk membuat scatterplot pada Figure 2. Berikut adalah contoh sintaks yang digunakan:\nx \u0026lt;- trees$Height\ry \u0026lt;- trees$Volume\rplot(y~x)\rFungsi plot() juga dapat digunakan untuk membentuk matriks scatterplot. Untuk membuatnya kita hanya perlu memasukkan seluruh dataset kedalam fungsi plot(). Berikut adalah sintaks dan output yang dihasilkan berupa Figure 3:\nplot(trees)\r\rFigure 3: Matriks scatterplot dataset trees\r\rSelain itu jika kita memasukkan objek lm() yang merupakan fungsi untuk melakukan operasi regresi linier pada fungsi plot(), output yang dihasilkan berupa plot diagnostik yang berguna untuk menguji asumsi model regresi linier. Berikut adalah contoh sintaks dan output yang dihasilkan pada Figure 4:\n# membagi jendela grafik menjadi 2 baris dan 2 kolom\rpar(mfrow=c(2,2))\r# plot\rplot(lm(Volume~Height, data=trees))\r\rFigure 4: Plot diagnostik regresi linier\r\rSelain objek-objek tersebut, fungsi plot() akan banyak digunakan dalam analisis statistika kita pada chapter lainnya.\n\r4.2 Matriks Scatterplot\rPada bagian sebelumnya kita telah belajar bagaimana membuat matriks scatterplot mengggunakan fungsi plot(). Pada bagian ini kita akan belajar cara membuat matriks scatterplot menggunakan fungsi pairs(). Secara umum format fungsi dituliskan sebagai berikut:\npairs(data, lower.panel=NULL)\r\rNote: \n\rdata: data frame\rlower.panel: menampilkan atau tidak menampilkan panel bawah\r\r\rUntuk lebih memahami penggunaan fungsi tersebut, berikut akan disajikan contoh penggunaannya pada dataset iris. Sebelum melakukannya jalankan sintaks berikut untuk memuat dataset:\n# memuat dataset irir\riris \u0026lt;- as_tibble(iris)\r# print\riris\r## # A tibble: 150 x 5\r## Sepal.Length Sepal.Width Petal.Length Petal.Width Species\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows\rUntuk membuat matriks scatterplot kita hanya perlu memasukkan objek iris kedalam fungsi pairs(). Berikut adalah sintaks yang digunakan dan output yang dihasilkan pada Figure 5:\npairs(iris)\r\rFigure 5: Matriks scatterplot iris\r\rKita dapat melakukan drop terhadap panel bawah grafik tersebut. Untuk melakukannya kita perlu memasukkan argumen lower.panel=NULL. Output yang dihasilkan akan tampak seperti pada Figure 6.\npairs(iris, lower.panel=NULL)\r\rFigure 6: Matriks scatterplot iris tanpa panel bawah\r\rKita dapat merubah warna titik berdasarkan factor Species. Langkah pertama yang perlu dilakukan adalah melakukan drop variabel Species pada dataset dan memasukkan objek baru tanpa variabel tersebut kedalam fungsi pairs(). Warna berdasarkan grup diberikan dengan menambahkan argumen col= pada fungsi pairs(). Berikut adalah contoh penerapannya dan output yang dihasilkan pada Figure 7:\n# drop variabel Species\r# simpan dataset baru pada objek iris2\riris2 \u0026lt;- iris[ ,1:4]\r# print\riris2\r## # A tibble: 150 x 4\r## Sepal.Length Sepal.Width Petal.Length Petal.Width\r## \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 5.1 3.5 1.4 0.2\r## 2 4.9 3 1.4 0.2\r## 3 4.7 3.2 1.3 0.2\r## 4 4.6 3.1 1.5 0.2\r## 5 5 3.6 1.4 0.2\r## 6 5.4 3.9 1.7 0.4\r## 7 4.6 3.4 1.4 0.3\r## 8 5 3.4 1.5 0.2\r## 9 4.4 2.9 1.4 0.2\r## 10 4.9 3.1 1.5 0.1\r## # ... with 140 more rows\r# spesifikasi vaktor warna titik berdasarkan spesies\rmy_col \u0026lt;- c(\u0026quot;#00AFBB\u0026quot;, \u0026quot;#E7B800\u0026quot;, \u0026quot;#FC4E07\u0026quot;)\r# plot\rpairs(iris2, lower.panel=NULL,\r# spesifikasi warna\rcol= my_col[iris$Species])\r\rFigure 7: Matriks scatterplot iris tanpa panel bawah\r\rKita juga dapat mengganti panel bawah menjadi nilai korelasi antar variabel. Untuk melakukannya kita perlu mendefinisikan sebuah fungsi untuk panel bawah dan panel atas (jika ingin warna titik berdasarkan factor). Setelah fungsi panel bawah dan atas didefinisikan, langkah selanjutnya adalah melakukan memasukkan nilainya kedalam fungsi pairs(). Berikut adalah sintaks yang digunakan serta output yang dihasilkan pada Figure 8:\n# membuat fungsi untuk menghitung\r# nilai korelasi yang ditempatkan pada panel bawah\rpanel.cor \u0026lt;- function(x, y){\r# definisi parameter grafik usr \u0026lt;- par(\u0026quot;usr\u0026quot;); on.exit(par(usr))\rpar(usr = c(0, 1, 0, 1))\r# menghitung koefisien korelas\rr \u0026lt;- round(cor(x, y), digits=2)\r# menambahkan text berdasarkan koefisien korelasi\rtxt \u0026lt;- paste0(\u0026quot;R = \u0026quot;, r)\r# mengatur besar text sesuai besarnya nilai korelasi\rcex.cor \u0026lt;- 0.8/strwidth(txt)\rtext(0.5, 0.5, txt, cex = cex.cor * abs(r))\r}\r# kustomisasi panel atas agar\r# warna titik berdasarkan factor\rmy_col \u0026lt;- c(\u0026quot;#00AFBB\u0026quot;, \u0026quot;#E7B800\u0026quot;, \u0026quot;#FC4E07\u0026quot;)\rupper.panel\u0026lt;-function(x, y){\rpoints(x,y, col = my_col[iris$Species])\r}\rpairs(iris2,\rlower.panel= panel.cor,\rupper.panel= upper.panel)\r\rFigure 8: Matriks scatterplot iris dengan koefisien korelasi\r\rJika kita tidak ingin nilai korelasi ditampilkan di panel bawah, kita dapat merubahnya sehingga dapat tampil pada panel atas bersamaan dengan scatterplot. Untuk melakukannya kita perlu mendefinisikan fungsi pada panel atas dan memasukkannya pada argumen upper.panel=. Berikut adalah sintaks yang digunakan beserta output yang dihasilkan pada Figure 9:\n# kustomisasi panel atas\rupper.panel\u0026lt;-function(x, y){\rpoints(x,y, col=c(\u0026quot;#00AFBB\u0026quot;, \u0026quot;#E7B800\u0026quot;, \u0026quot;#FC4E07\u0026quot;)[iris$Species])\rr \u0026lt;- round(cor(x, y), digits=2)\rtxt \u0026lt;- paste0(\u0026quot;R = \u0026quot;, r)\rusr \u0026lt;- par(\u0026quot;usr\u0026quot;); on.exit(par(usr))\rpar(usr = c(0, 1, 0, 1))\rtext(0.5, 0.9, txt)\r}\r# plot\rpairs(iris2, lower.panel = NULL, upper.panel = upper.panel)\r\rFigure 9: Matriks scatterplot iris dengan koefisien korelasi di panel atas\r\r\r4.3 Box plot\rBox plot pada R dapat dibuat menggunakan fungsi boxplot(). Berikut adalah sintaks untuk membuat boxplot variabel Sepal.Lenght pada dataset iris dan output yang dihasilkan pada Figure 10:\nboxplot(iris$Sepal.Length)\r\rFigure 10: Boxplot variabel Sepal.Length\r\rBoxplot juga dapat dibuat berdasarkan variabel factor. Hal ini berguna untuk melihat perbedaan ditribusi data pada masing-masing grup. Pada sintaks berikut dibuat boxplot berdasarkan variabel Species. Output yang dihasilkan disajikan pada Figure 11:\nboxplot(iris$Sepal.Length~iris$Species)\r\rFigure 11: Boxplot berdasarkan variabel species\r\rKita juga dapat mengubah warna outline dan box pada boxplot. Berikut adalah contoh sintaks yang digunakan untuk melakukannya dan output yang dihasilkan disajikan pada Figure 12:\nboxplot(iris$Sepal.Length~iris$Species,\r# ubah warna outline menjadi steelblue\rborder = \u0026quot;steelblue\u0026quot;,\r# ubah warna box berdasarkan grup\rcol= c(\u0026quot;#999999\u0026quot;, \u0026quot;#E69F00\u0026quot;, \u0026quot;#56B4E9\u0026quot;))\r\rFigure 12: Boxplot dengan warna berdasarkan spesies\r\rKita juga dapat membuat boxplot pada multiple group. Data yang digunakan untuk contoh tersebut adalah dataset ToothGrowth. Berikut adalah sintaks untuk memuat dataset tersebut:\n# memuat dataset sebagai tibble\rToothGrowth \u0026lt;- as_tibble(ToothGrowth)\r# print\rToothGrowth\r## # A tibble: 60 x 3\r## len supp dose\r## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;dbl\u0026gt;\r## 1 4.2 VC 0.5\r## 2 11.5 VC 0.5\r## 3 7.3 VC 0.5\r## 4 5.8 VC 0.5\r## 5 6.4 VC 0.5\r## 6 10 VC 0.5\r## 7 11.2 VC 0.5\r## 8 11.2 VC 0.5\r## 9 5.2 VC 0.5\r## 10 7 VC 0.5\r## # ... with 50 more rows\r# ubah variable dose menjadi factor\rToothGrowth$dose \u0026lt;- as.factor(ToothGrowth$dose)\r# print\rToothGrowth\r## # A tibble: 60 x 3\r## len supp dose ## \u0026lt;dbl\u0026gt; \u0026lt;fct\u0026gt; \u0026lt;fct\u0026gt;\r## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.3 VC 0.5 ## 4 5.8 VC 0.5 ## 5 6.4 VC 0.5 ## 6 10 VC 0.5 ## 7 11.2 VC 0.5 ## 8 11.2 VC 0.5 ## 9 5.2 VC 0.5 ## 10 7 VC 0.5 ## # ... with 50 more rows\rContoh sintaks dan output boxplot multiple group disajikan pada Figure 13:\nboxplot(len ~ supp*dose, data = ToothGrowth,\rcol = c(\u0026quot;white\u0026quot;, \u0026quot;steelblue\u0026quot;))\r\rFigure 13: Boxplot multiple group\r\r\r4.4 Bar Plot\rBarplot pada R dapat dibuat menggunakan fungsi barplot(). Untuk lebih memahaminya berikut disajikan contoh barplot menggunakan dataset VADeaths. Untuk memuatnya jalankan sintaks berikut:\nVADeaths\r## Rural Male Rural Female Urban Male Urban Female\r## 50-54 11.7 8.7 15.4 8.4\r## 55-59 18.1 11.7 24.3 13.6\r## 60-64 26.9 20.3 37.0 19.3\r## 65-69 41.0 30.9 54.6 35.1\r## 70-74 66.0 54.3 71.1 50.0\rContoh bar plot untuk variabel Rural Male disajikan pada Figure 14:\npar(mfrow=c(1,2))\rbarplot(VADeaths[, \u0026quot;Rural Male\u0026quot;], main=\u0026quot;a\u0026quot;)\rbarplot(VADeaths[, \u0026quot;Rural Male\u0026quot;], main=\u0026quot;b\u0026quot;, horiz=TRUE)\r\rFigure 14: a. bar plot vertikal, b. bar plot horizontal\r\rpar(mfrow=c(1,1))\rKita dapat mengubah warna pada masing-masing bar, baik outline bar maupun box pada bar. Selain itu kita juga dapat mengubah nama grup yang telah dihasilkan sebelumnya. Berikut sintaks untuk melakukannya dan output yang dihasilkan pada Figure 15:\nbarplot(VADeaths[, \u0026quot;Rural Male\u0026quot;],\r# ubah warna ouline menjadi steelblue\rborder=\u0026quot;steelblue\u0026quot;,\r# ubah wana box\rcol= c(\u0026quot;grey\u0026quot;, \u0026quot;yellow\u0026quot;, \u0026quot;steelblue\u0026quot;, \u0026quot;green\u0026quot;, \u0026quot;orange\u0026quot;),\r# ubah nama grup dari A sampai E\rnames.arg = LETTERS[1:5],\r# ubah orientasi menajadi horizontal\rhoriz=TRUE)\r\rFigure 15: Kustomisasi bar plot\r\rUntuk bar plot dengan multiple group, tersedia dua pengaturan posisi yaitu stacked bar plot(menunjukkan proporsi penyusun pada masing-masing grup) dan grouped bar plot(melihat perbedaan individual pada masing-masing grup). Pada Figure 16 dan Figure 17, disajikan kedua jenis bar plot tersebut.\n# staked\rbarplot(VADeaths,\rcol = c(\u0026quot;lightblue\u0026quot;, \u0026quot;mistyrose\u0026quot;, \u0026quot;lightcyan\u0026quot;, \u0026quot;lavender\u0026quot;, \u0026quot;cornsilk\u0026quot;),\rlegend = rownames(VADeaths))\r\rFigure 16: Stacked bar plot\r\r# grouped\rbarplot(VADeaths,\rcol = c(\u0026quot;lightblue\u0026quot;, \u0026quot;mistyrose\u0026quot;, \u0026quot;lightcyan\u0026quot;, \u0026quot;lavender\u0026quot;, \u0026quot;cornsilk\u0026quot;),\rlegend = rownames(VADeaths), beside = TRUE)\r\rFigure 17: Grouped bar plot\r\r\r4.5 Line Plot\rLine plot pada R dapat dibentuk menggunakan fungsi plot(). Selain itu fungsi lines() dapat pula digunakan untuk menambahkan line plot pada grafik. Berikut adalah sintaks untuk membuat line plot dan outputnya pada Figure 18:\n# Membuat vektor data\rx \u0026lt;- c(1:20)\ry \u0026lt;- 2*x\rz \u0026lt;- x^2\r# Membuat line plot x vs y\rplot(y~x, type=\u0026quot;b\u0026quot;,\rlty=1,\rcol=\u0026quot;blue\u0026quot;)\r# Menambahkan line plot x vs z\rlines(z~x, type=\u0026quot;o\u0026quot;,\rlty=2,\rcol=\u0026quot;red\u0026quot;)\r# Menambahkan legend\rlegend(\u0026quot;topleft\u0026quot;, legend=c(\u0026quot;Line 1\u0026quot;, \u0026quot;Line 2\u0026quot;),\rcol=c(\u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;), lty = 1:2, cex=0.8)\r\rFigure 18: Line plot\r\r\r4.6 Pie Chart\rPie chart digunakan untuk membuat visualisasi proporsi pada sebuah data. Pie chart pada R dibuat menggunakan fungsi pie(). Berikut adalah sintaks untuk membuat pie chart dan output yang dihasilkan pada Figure 19:\npar(mar = c(0, 1, 0, 1))\rpie(\rc(280, 60, 20),\rc(\u0026#39;Sky\u0026#39;, \u0026#39;Sunny side of pyramid\u0026#39;, \u0026#39;Shady side of pyramid\u0026#39;),\rcol = c(\u0026#39;#0292D8\u0026#39;, \u0026#39;#F7EA39\u0026#39;, \u0026#39;#C4B632\u0026#39;),\rinit.angle = -50, border = NA\r)\r\rFigure 19: Pie chart\r\r\r4.7 Histogram dan Density Plot\rFungsi hist() dapat digunakan untuk membuat histogram pada R. Secara sederhana fungsi tersebut didefinisikan sebagai berikut:\nhist(x, breaks=\u0026quot;Sturges\u0026quot;)\r\rNote: \n\rx: vektor numerik\rbreaks: breakpoints antar sel histogram.\r\r\rPada dataset trees akan dibuat histogram variabel Height. Untuk melakukannya jalankan sintaks berikut:\nhist(trees$Height)\rOutput yang dihasilkan disajikan pada Figure 20:\n\rFigure 20: Histogram\r\rDensity plot pada R dapat dibuat menggunakan fungsi density(). Berbeda dengan fungsi hist(), fungsi ini tidak langsung menghasilkan grafik densitas. Fungsi density() hanya menghitung kernel densitas pada data. Densitas yang telah dihitung selanjutnya diplotkan menggunakan fungsi plot(). Berikut adalah sintaks dan output yang dihasilkan pada Figure 21:\n# menghitung kernel density\rdens \u0026lt;- density(trees$Height)\r# plot densitas dengan outline merah\rplot(dens,col=\u0026quot;red\u0026quot;)\r\rFigure 21: Density plot\r\rKita juga dapat menambahkan grafik densitas pada histogram sehingga mempermudah pembacaan pada histogram. Untuk melakukannya kita perlu mengubah kernel histigram dari frekuensi menjadi density dengan menambahkan argumen freq=FALSE pada fungsi hist(). Selanjutnya tambahkan fungsi polygon() untuk memplotkan grafik densitas. Berikut adalah sintak dan output yang dihasilkan pada Figure 22:\n# menghitung kernel density\rdens \u0026lt;- density(trees$Height)\r# histogram\rhist(trees$Height, freq=FALSE, col=\u0026quot;steelblue\u0026quot;)\r# tambahkan density plot\rpolygon(dens, border=\u0026quot;red\u0026quot;)\r\rFigure 22: Density plot dan histogram\r\r\r4.8 QQ Plot\rQQ plot digunakan untuk mengecek distribusi suatu data apakah berdistribusi normal atau tidak. Pada R QQ plot dibuat menggunakan 2 fungsi yaitu: qqnorm() dan qqline(). Fungsi qqnorm() digunakan untuk memproduksi normal QQ plot suatu variabel. Sedangkan fungsi qqline() digunakan untuk membuat garis referensi distiribusi normal. Suatu distribusi dikatan normal jika titik observasi yang dihasilkan mengikuti garis referensi tersebut.\nBerikut adalah cara membuat QQ plot menggunakan variabel Volume pada dataset trees. Output yang dihasilkan disajikan pada Figure 23.\nqqnorm(trees$Volume)\rqqline(trees$Volume, col=\u0026quot;red\u0026quot;)\r\rFigure 23: QQ plot\r\r\r4.9 Dot Chart\rFungsi dotchart() pada R digunakan untuk membuat dot chart. Format yang digunakan adalah sebagai berikut:\ndotchart(x, labels = NULL, groups = NULL, gcolor = par(\u0026quot;fg\u0026quot;), color = par(\u0026quot;fg\u0026quot;))\r\rNote: \n\rx: vektor atau matriks numerik.\rlabels: vektor label untuk tiap titik.\rgroups: grouping variabel yang mengindikasikan bagaimana x dikelompokkan.\rgcolor: warna yang digunakan pada label grup dan nilai observasi.\rcolor: warna yang digunakan untuk titik dan label.\r\r\rPada contoh berikut disajikan cara membuat dot chart pada dataset mtcars untuk melihat mobil yang paling hemat bahan bakar berdasarkan variabel mpg dan jumlah silinder (cyl). Berikut sintaks yang digunakan dan output yang dihasilkan pada Figure 24:\n# mengurutkan dataset mtcars berdasarkan variabel mpg\rmtcars \u0026lt;- mtcars[order(mtcars$mpg), ]\r# mengubah variabel cyl menjadi factor\rgrps \u0026lt;- as.factor(mtcars$cyl)\r# membuat vektor warna berdasarkan jumlah grup\rmy_cols \u0026lt;- c(\u0026quot;#999999\u0026quot;, \u0026quot;#E69F00\u0026quot;, \u0026quot;#56B4E9\u0026quot;)\r# plot\rdotchart(mtcars$mpg, labels = row.names(mtcars),\rgroups = grps, gcolor = my_cols,\rcolor = my_cols[grps],\rcex = 0.6, pch = 19, xlab = \u0026quot;mpg\u0026quot;)\r\rFigure 24: Dot chart\r\r\r4.10 Kustomisasi Parameter Grafik\rPada bagian ini penulis akan menjelaskan cara untuk kustomisasi parameter grafik seperti:\nmenambahkan judul, legend, teks, axis, dan garis.\rmengubah skala axis, simbol plot, jenis garis, dan warna.\r\r4.10.1 Menambahkan Judul\rPada grafik di R, kita dapat menambahkan judul dengan dua cara, yaitu: pada plot melalui parameter dan melalui fungsi plot(). Kedua cara tersebut tidak berbeda satu sama lain pada parameter input.\nUntuk menambahkan judul pada plot secara langsung, kita dapat menggunakan argumen tambahan sebagai berikut:\nmain: teks untuk judul.\rxlab: teks untuk keterangan axis X.\rylab: teks untuk keterangan axis y.\rsub: teks untuk sub-judul.\r\rBerikut contoh sintaks penerapan masing-masing argumen tersebut beserta dengan output yang dihasilkan pada Figure 25:\n# menambahkan judul\rbarplot(c(2,5), main=\u0026quot;Main title\u0026quot;,\rxlab=\u0026quot;X axis title\u0026quot;,\rylab=\u0026quot;Y axis title\u0026quot;,\rsub=\u0026quot;Sub-title\u0026quot;)\r\rFigure 25: Menambahkan Judul\r\rkita juga dapat melakukan kustomisasi pada warna, font style, dan ukuran font judul. Untuk melakukan kustomisasi pada warna pada judul, kita dapat menambahkan argumen sebagai berikut:\ncol.main: warna untuk judul.\rcol.lab: warna untuk keterangan axis.\rcol.sub: warna untuk sub-judul\r\rUntuk kustomisasi font judul, kita dapat menambahkan argumen berikut:\nfont.main: font style untuk judul.\rfont.lab: font style untuk keterangan axis.\rfont.sub: font style untuk sub-judul.\r\r\rNote: \nNilai yang dapat dimasukkan antara lain:\n\r1: untuk teks normal.\r2: untuk teks cetak tebal.\r3: untuk teks cetak miring.\r4: untuk teks cetak tebal dan miring.\r5: untuk font simbol.\r\r\rSedangkan untuk ukuran font, kita dapat menambahkan variabel berikut:\ncex.main: ukuran teks judul.\rcex.lab: ukuran teks keterangan axis.\rcex.sub: ukuran teks sub-judul.\r\rBerikut sintaks penerapan seluruh argumen tersebut beserta output yang dihasilkan pada Figure 26:\n# menambahkan judul\rbarplot(c(2,5), # menambahkan judul\rmain=\u0026quot;Main title\u0026quot;,\rxlab=\u0026quot;X axis title\u0026quot;,\rylab=\u0026quot;Y axis title\u0026quot;,\rsub=\u0026quot;Sub-title\u0026quot;,\r# kustomisasi warna font\rcol.main=\u0026quot;red\u0026quot;, col.lab=\u0026quot;blue\u0026quot;, col.sub=\u0026quot;black\u0026quot;,\r# kustomisasi font style\rfont.main=4, font.lab=4, font.sub=4,\r# kustomisasi ukuran font\rcex.main=2, cex.lab=1.7, cex.sub=1.2)\r\rFigure 26: Menambahkan Judul (2)\r\rKita telah belajar bagaimana menambahkan judul langsung pada fungsi plot. Selain cara tersebut, telah penulis jelaskan bahwa kita dapat menambahkan judul melalui fungsi title(). argumen yang dimasukkan pada dasarnya tidak berbeda dengan ketika kita menambahkan judul secara langsung pada plot. Berikut adalah contoh sintaks dan output yang dihasilkan pada Figure 27:\n# menambahkan judul\rbarplot(c(2,5,8))\r# menambahkan judul\rtitle(main=\u0026quot;Main title\u0026quot;,\rxlab=\u0026quot;X axis title\u0026quot;,\rylab=\u0026quot;Y axis title\u0026quot;,\rsub=\u0026quot;Sub-title\u0026quot;,\r# kustomisasi warna font\rcol.main=\u0026quot;red\u0026quot;, col.lab=\u0026quot;blue\u0026quot;, col.sub=\u0026quot;black\u0026quot;,\r# kustomisasi font style\rfont.main=4, font.lab=4, font.sub=4,\r# kustomisasi ukuran font\rcex.main=2, cex.lab=1.7, cex.sub=1.2)\r\rFigure 27: Menambahkan Judul (3)\r\r\r4.10.2 Menambahkan Legend\rFungsi legend() pada R dapat digunakan untuk menambahkan legend pada grafik. Format sederhananya adalah sebagai berikut:\nlegend(x, y=NULL, legend, fill, col, bg)\r\rNote: \n\rx dan y: koordinat yang digunakan untuk posisi legend.\rlegend: teks pada legend\rfill: warna yang digunakan untuk mengisi box disamping teks legend.\rcol: warna garis dan titik disamping teks legend.\rbg: warna latar belakang legend box.\r\r\rBerikut adalah contoh sintaks dan ouput penerapan argumen disajikan pada Figure 28:\n# membuat vektor numerik\rx \u0026lt;- c(1:10)\ry \u0026lt;- x^2\rz \u0026lt;- x*2\r# membuat line plot\rplot(x,y, type=\u0026quot;o\u0026quot;, col=\u0026quot;red\u0026quot;, lty=1)\r# menambahkan line plot\rlines(x,z, type=\u0026quot;o\u0026quot;, col=\u0026quot;blue\u0026quot;, lty=2)\r# menambahkan legend\rlegend(1, 95, legend=c(\u0026quot;Line 1\u0026quot;, \u0026quot;Line 2\u0026quot;),\rcol=c(\u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;), lty=1:2, cex=0.8)\r\rFigure 28: Menambahkan legend\r\rKita dapat menambahkan judul, merubah font, dan merubah warna backgroud pada legend. Argumen yang ditambahkan pada legend adalah sebagai berikut:\ntitle: Judul legend\rtext.font: integer yang menunjukkan font style pada teks legend. Nilai yang dapat dimasukkan adalah sebagai berikut:\r\r1: normal\r2: cetak tebal\r3: cetak miring\r4: cetak tebal dan miring.\r\rbg: warna background legend box.\r\rBerikut adalah penerapan sintaks dan output yang dihasilkan pada Figure 29:\n# membuat line plot\rplot(x,y, type=\u0026quot;o\u0026quot;, col=\u0026quot;red\u0026quot;, lty=1)\r# menambahkan line plot\rlines(x,z, type=\u0026quot;o\u0026quot;, col=\u0026quot;blue\u0026quot;, lty=2)\r# menambahkan legend\rlegend(1, 95, legend=c(\u0026quot;Line 1\u0026quot;, \u0026quot;Line 2\u0026quot;),\rcol=c(\u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;), lty=1:2, cex=0.8,\rtitle=\u0026quot;Line types\u0026quot;, text.font=4, bg=\u0026#39;lightblue\u0026#39;)\r\rFigure 29: Menambahkan legend (2)\r\rKita dapat melakukan kustomisasi pada border dari legend melalui argumen box.lty=(jenis garis), box.lwd=(ukuran garis), dan box.col=(warna box). Berikut adalah penerapan argumen tersebut beserta output yang dihasilkan pada Figure 30:\n# membuat line plot\rplot(x,y, type=\u0026quot;o\u0026quot;, col=\u0026quot;red\u0026quot;, lty=1)\r# menambahkan line plot\rlines(x,z, type=\u0026quot;o\u0026quot;, col=\u0026quot;blue\u0026quot;, lty=2)\r# menambahkan legend\rlegend(1, 95, legend=c(\u0026quot;Line 1\u0026quot;, \u0026quot;Line 2\u0026quot;),\rcol=c(\u0026quot;red\u0026quot;, \u0026quot;blue\u0026quot;), lty=1:2, cex=0.8,\rtitle=\u0026quot;Line types\u0026quot;, text.font=4, bg=\u0026#39;white\u0026#39;,\rbox.lty=2, box.lwd=2, box.col=\u0026quot;steelblue\u0026quot;)\r\rFigure 30: Menambahkan legend (3)\r\rSelain menggunakan koordinat, kita juga dapat melakukan kustomisasi posisi legend menggunakan keyword seperti: bottomright“,”bottom“,”bottomleft“,”left“,”topleft“,”top“,”topright“,”right\u0026quot; and “center”. Sejumlah kustomisasi legend berdasarkan keyword disajikan pada Figure 31:\n# plot\rplot(x,y, type = \u0026quot;n\u0026quot;)\r# posisi kiri atas, inset =0.05\rlegend(\u0026quot;topleft\u0026quot;,\rlegend = \u0026quot;(x,y)\u0026quot;,\rtitle = \u0026quot;topleft, inset = .05\u0026quot;,\rinset = 0.05)\r# posisi atas\rlegend(\u0026quot;top\u0026quot;,\rlegend = \u0026quot;(x,y)\u0026quot;,\rtitle = \u0026quot;top\u0026quot;)\r# posisi kanan atas inset = .02\rlegend(\u0026quot;topright\u0026quot;,\rlegend = \u0026quot;(x,y)\u0026quot;,\rtitle = \u0026quot;topright, inset = .02\u0026quot;,\rinset = 0.02)\r# posisi kiri\rlegend(\u0026quot;left\u0026quot;,\rlegend = \u0026quot;(x,y)\u0026quot;,\rtitle = \u0026quot;left\u0026quot;)\r# posisi tengah\rlegend(\u0026quot;center\u0026quot;,\rlegend = \u0026quot;(x,y)\u0026quot;,\rtitle = \u0026quot;center\u0026quot;)\r# posisi kanan\rlegend(\u0026quot;right\u0026quot;,\rlegend = \u0026quot;(x,y)\u0026quot;,\rtitle = \u0026quot;right\u0026quot;)\r# posisi kiri bawah\rlegend(\u0026quot;bottomleft\u0026quot;,\rlegend = \u0026quot;(x,y)\u0026quot;,\rtitle = \u0026quot;bottomleft\u0026quot;)\r# posisi bawah\rlegend(\u0026quot;bottom\u0026quot;,\rlegend = \u0026quot;(x,y)\u0026quot;,\rtitle = \u0026quot;bottom\u0026quot;)\r# posisi kanan bawah\rlegend(\u0026quot;bottomright\u0026quot;,\rlegend = \u0026quot;(x,y)\u0026quot;,\rtitle = \u0026quot;bottomright\u0026quot;)\r\rFigure 31: Kustomisasi posisi legend\r\r\r4.10.3 Menambahkan Teks Pada Grafik\rTeks pada grafik dapat kita tambahkan baik sebagai keterangan yang menunjukkan label suatu observasi, keterangan tambahan disekitar bingkai grafik, maupun sebuah persamaan yang ada pada bidang grafik. Untuk menambahkannya kita dapat menggunakan dua buah fungsi yaitu: text() dan mtext().\nFUngsi text() berguna untuk menambahkan teks di dalam bidang grafik seperti label titik observasi dan persamaan di dalam bidang grafik. Format yang digunakan adalah sebagai berikut:\ntext(x, y, labels)\r\rNote: \n\rx dan y: vektor numerik yang menunjukkan koordinat posisi teks.\rlabels: vektor karakter yang menunjukkan teks yang hendak ditulis.\r\r\rBerikut adalah contoh sintaks untuk memberi label pada sejumlah data yang memiliki kriteria yang kita inginkan dan output yang dihasilkan pada Figure 32:\n# tandai observasi yang memiliki nilai\r# mpg \u0026lt; 15 dan wt \u0026gt; 5\rd \u0026lt;- mtcars[mtcars$wt \u0026gt;= 5 \u0026amp; mtcars \u0026lt;= 15, ]\r# plot\rplot(mtcars$wt, mtcars$mpg, main=\u0026quot;Milage vs. Car Weight\u0026quot;,\rxlab=\u0026quot;Weight\u0026quot;, ylab=\u0026quot;Miles/(US) gallon\u0026quot;)\r# menambahkan text\rtext(d[,\u0026#39;wt\u0026#39;], d[,\u0026#39;mpg\u0026#39;], row.names(d),\rcex=0.65, pos=3,col=\u0026quot;red\u0026quot;)\r\rFigure 32: Menambahkan teks\r\rSedangkan sintaks berikut adalah contoh bagaimana menambahkan persamaan kedalam bidang grafik dan output yang dihasilkan pada Figure 33:\nplot(1:10, 1:10, main=\u0026quot;text(...) examples\\n~~~~~~~~~~~\u0026quot;)\rtext(4, 9, expression(hat(beta) == (X^t * X)^{-1} * X^t * y))\rtext(7, 4, expression(bar(x) == sum(frac(x[i], n), i==1, n)))\r\rFigure 33: Menambahkan teks (2)\r\rFungsi mtext() berguna untuk menambahkan teks pada frame sekitar bidang grafik. Format yang digunakan adalah sebagai berikut:\nmtext(text, side=3)\r\rNote: \n\rtext: teks yang akan ditulis.\rside: integer yang menunjukkan lokasi teks yang akan ditulis. Nilai yang dapat dimasukkan antara lain:\r1: bawah\r2: kiri\r3: atas\r4: kanan.\r\r\rBerikut adalah contoh penerapan dan output yang dihasilkan pada Figure 34:\nplot(1:10, 1:10, main=\u0026quot;mtext(...) examples\\n~~~~~~~~~~~\u0026quot;)\rmtext(\u0026quot;Magic function\u0026quot;, side=3)\r\rFigure 34: Menambahkan teks (3)\r\r\r4.10.4 Menambahkan Garis Pada Plot\rFungsi abline() dapat digunakan untuk menamabahkan garis pada plot. Garis yang ditambahkan dapat berupa garis vertikal, horizontal, maupun garis regresi. Format yang digunakan adalah sebagi berikut:\nabline(v=y)\rBerikut adalah contoh sintaks bagaimana menambahkan garis pada sebuah plot dan output yang dihasilkan disajikan pada Figure 35:\n# membuat plot\rplot(mtcars$wt, mtcars$mpg, main=\u0026quot;Milage vs. Car Weight\u0026quot;,\rxlab=\u0026quot;Weight\u0026quot;, ylab=\u0026quot;Miles/(US) gallon\u0026quot;)\r# menambahkan garis vertikal di titik rata-rata weight\rabline(v=mean(mtcars$wt), col=\u0026quot;red\u0026quot;, lwd=3, lty=2)\r# menambahkan garis horizontal di titik rata-rata mpg\rabline(h=mean(mtcars$mpg), col=\u0026quot;blue\u0026quot;, lwd=3, lty=3)\r# menambahkan garis regresi\rabline(lm(mpg~wt, data=mtcars), lwd=4, lty=4)\r\rFigure 35: Menambahkan garis\r\r\r4.10.5 Merubah Simbol plot dan Jenis Garis\rSimbol plot (jenis titik) dapat diubah dengan menambahkan argumen pch= pada plot. Nilai yang dimasukkan pada argumen tersebut adalah integer dengan kemungkinan nilai sebagai berikut:\n\rpch = 0,square\rpch = 1,circle (default)\rpch = 2,triangle point up\rpch = 3,plus\rpch = 4,cross\rpch = 5,diamond\rpch = 6,triangle point down\rpch = 7,square cross\rpch = 8,star\rpch = 9,diamond plus\rpch = 10,circle plus\rpch = 11,triangles up and down\rpch = 12,square plus\rpch = 13,circle cross\rpch = 14,square and triangle down\rpch = 15, filled square\rpch = 16, filled circle\rpch = 17, filled triangle point-up\rpch = 18, filled diamond\rpch = 19, solid circle\rpch = 20,bullet (smaller circle)\rpch = 21, filled circle blue\rpch = 22, filled square blue\rpch = 23, filled diamond blue\rpch = 24, filled triangle point-up blue\rpch = 25, filled triangle point down blue\r\rUntuk lebih memahami bentuk simbol tersebut, penulis akan menyajikan sintaks yang menampilkan seluruh simbol tersebut pada satu grafik. Output yang dihasilkan disajikan pada Figure 36:\ngenerateRPointShapes\u0026lt;-function(){\r# menentukan parameter plot\roldPar\u0026lt;-par()\rpar(font=2, mar=c(0.5,0,0,0))\r# produksi titik axis\ry=rev(c(rep(1,6),rep(2,5), rep(3,5), rep(4,5), rep(5,5)))\rx=c(rep(1:5,5),6)\r# plot seluruh titik dan label\rplot(x, y, pch = 0:25, cex=1.5, ylim=c(1,5.5), xlim=c(1,6.5), axes=FALSE, xlab=\u0026quot;\u0026quot;, ylab=\u0026quot;\u0026quot;, bg=\u0026quot;blue\u0026quot;)\rtext(x, y, labels=0:25, pos=3)\rpar(mar=oldPar$mar,font=oldPar$font )\r}\r# Print\rgenerateRPointShapes()\r\rFigure 36: Symbol plot\r\rPada R kita juga dapat mengatur jenis garis yang akan ditampilkan pada plot dengan menambahkan argumen lty= (line type) pada fungsi plot. Nilai yang dapat dimasukkan adalah nilai integer. Keterangan masing-masing nilai tersebut adalah sebagai berikut:\n\rlty = 0, blank\rlty = 1, solid (default)\rlty = 2, dashed\rlty = 3, dotted\rlty = 4, dotdash\rlty = 5, longdash\rlty = 6, twodash\r\rUntuk lebih memahaminya, pada sintaks berikut disajikan plot seluruh jenis garis tersebut beserta output yang dihasilkannya pada Figure 37:\ngenerateRLineTypes\u0026lt;-function(){\roldPar\u0026lt;-par()\rpar(font=2, mar=c(0,0,0,0))\rplot(1, pch=\u0026quot;\u0026quot;, ylim=c(0,6), xlim=c(0,0.7), axes = FALSE ,xlab=\u0026quot;\u0026quot;, ylab=\u0026quot;\u0026quot;)\rfor(i in 0:6) lines(c(0.3,0.7), c(i,i), lty=i, lwd=3)\rtext(rep(0.1,6), 0:6, labels=c(\u0026quot;0.\u0026#39;blank\u0026#39;\u0026quot;, \u0026quot;1.\u0026#39;solid\u0026#39;\u0026quot;, \u0026quot;2.\u0026#39;dashed\u0026#39;\u0026quot;, \u0026quot;3.\u0026#39;dotted\u0026#39;\u0026quot;, \u0026quot;4.\u0026#39;dotdash\u0026#39;\u0026quot;, \u0026quot;5.\u0026#39;longdash\u0026#39;\u0026quot;, \u0026quot;6.\u0026#39;twodash\u0026#39;\u0026quot;))\rpar(mar=oldPar$mar,font=oldPar$font )\r}\rgenerateRLineTypes()\r\rFigure 37: Line type\r\r\r4.10.6 Mengatur Axis Plot\rKita dapat melakukan pengaturan lebih jauh terhadap axis, seperti: menambahkan axis tambahan pada atas dan bawah frame, mengubah rentang nilai axis, serta kustomisasi tick mark pada nilai axis. Hal ini diperlukan karena fungsi grafik dasar R tidak dapat mengatur axis secara otomatis saat plot baru ditambahkan pada plot pertama dan rentang nilai plot baru lebih besar dibanding plot pertama, sehingga sebagian nilai plot baru tidak ditampilkan pada hasil akhir.\nUntuk menambahkan axis pada R kita dapat menambahkan fungsi axis() setelah plot dilakukan. Format yang digunakan adalah sebagai berikut:\naxis(side, at=NULL, labels=TRUE)\r\rNote: \n\rside: nilai integer yang mengidikasikan posisi axix yang hendak ditambahkan. Nilai yang dapat dimasukkan adalah sebagai berikut:\r\r1: bawah\r2: kiri\r3: atas\r4: kanan.\r\rat: titik dimana tick-mark hendak digambarkan. Nilai yang dapat dimasukkan sama dengan side.\rlabels: Teks label tick-mark. Dapat juga secara logis menentukan apakah anotasi harus dibuat pada tick mark.\r\r\rBerikut contoh sintaks penerapan fungsi tersebut dan output yang dihasilkan pada Figure 38:\n# membuat vektor numerik\rx \u0026lt;- c(1:4)\ry \u0026lt;- x^2\r# plot\rplot(x, y, pch=18, col=\u0026quot;red\u0026quot;, type=\u0026quot;b\u0026quot;,\rframe=FALSE, xaxt=\u0026quot;n\u0026quot;) # Remove x axis\r# menambahkan axis\r# bawah\raxis(1, 1:4, LETTERS[1:4], col.axis=\u0026quot;blue\u0026quot;)\r# atas\raxis(3, col = \u0026quot;darkgreen\u0026quot;, lty = 2, lwd = 0.5)\r# kanan\raxis(4, col = \u0026quot;violet\u0026quot;, col.axis = \u0026quot;dark violet\u0026quot;, lwd = 2)\r\rFigure 38: Menambahkan axis\r\rKita dapat mengubah rentang nilai pada axis menggunakan fungsi xlim() dan ylim() yang menyatakan vektor nilai masimum dan minimum rentang. Selain itu kita dapat juga melakukan tranformasi baik pada sumbu x dan sumbu y. Berikut adalah argumen yang dapat ditambahkan pada fungsi grafik:\n\rxlim: limit nilai sumbu x dengan format: xlim(min, max).\rylim: limit nilai sumbu x dengan format: ylim(min, max).\r\rUntuk transformasi skala log, kita dapat menambahkan argumen berikut:\n\rlog=“x”: transformasi log sumbu x.\rlog=“y”: transformasi log sumbu y.\rlog=“xy”: transformasi log sumbu x dan y.\r\rBerikut adalah contoh sintaks penerapan argumen tersebut beserta output yang dihasilkan pada Figure 39:\n# membagi jendela grafik menjadi 1 baris dan 3 kolom\rpar(mfrow=c(1,3))\r# membuat vektor numerik\rx\u0026lt;-c(1:10); y\u0026lt;-x*x\r# simple plot\rplot(x, y)\r# plot dengan pengaturan rentang skala\rplot(x, y, xlim=c(1,15), ylim=c(1,150))\r# plot dengan transformasi skala log\rplot(x, y, log=\u0026quot;y\u0026quot;)\r\rFigure 39: Mengubah rentang dan skala axis\r\rKita dapat melakukan kustomisasi pada tick mark. Kustomisasi yang dapat dilakukan adalah merubah warna, font style, ukuran font, orientasi, serta menyembunyikan tick mark.\nArgumen yang ditambahkan adalah sebagai berikut:\n\rcol.axis: warna tick mark.\rfont.axis: integer yang menunjukkan font style. Sama dengan pengaturan judul.\rcex.axis: pengaturan ukuran tick mark.\rlas: mengatur orientasi tick mark. Nilai yang dapat dimasukkan adalah sebagai berikut:\n\r0: paralel terhadap posisi axis (default)\r1: selalu horizontal\r2: selalu perpendikular dengan posisi axis\r3: selalu vertikal\n\rxaxt dan yaxt: karakter untuk menunjukkan apakah axis akan ditampilkan atau tidak. nilai dapat berupa “n”(sembunyika) dan “s”(tampilkan).\n\r\rBerikut adalah contoh penerapan argumen tersebut beserta output pada Figure 40:\n# membuat vektor numerik\rx\u0026lt;-c(1:10); y\u0026lt;-x*x\r# plot\rplot(x,y,\r# warna\rcol.axis=\u0026quot;red\u0026quot;,\r# font style\rfont.axis=2,\r# ukuran\rcex=1.5,\r# orientasi\rlas=3,\r# sembunyikan sumbu x\rxaxt=\u0026quot;n\u0026quot;)\r\rFigure 40: Kustomisasi tick mark\r\r\r4.10.7 Mengatur Warna\rPada fungsi dasar R, warna dapat diatur dengan mengetikkan nama warna maupun kode hexadesimal. Selain itu kita juga dapat menamambahkan warna lain melalui library lain yang tidak dijelaskan pada chapter ini.\nUntuk penggunaan warna hexadesima kita perlu mengetikkan “#” yang diukuti oleh 6 kode warna. Untuk memperlajari kode-kode dan warna yang dihasilkan, silahkan pembaca mengunjungi situs http://www.visibone.com/.\nPada sintaks berikut disajikan visualisasi nama-nama warna bawaan yang ada pada R. Output yang dihasilkan disajikan pada Figure 41:\nshowCols \u0026lt;- function(cl=colors(), bg = \u0026quot;grey\u0026quot;,\rcex = 0.75, rot = 30) {\rm \u0026lt;- ceiling(sqrt(n \u0026lt;-length(cl)))\rlength(cl) \u0026lt;- m*m; cm \u0026lt;- matrix(cl, m)\rrequire(\u0026quot;grid\u0026quot;)\rgrid.newpage(); vp \u0026lt;- viewport(w = .92, h = .92)\rgrid.rect(gp=gpar(fill=bg))\rgrid.text(cm, x = col(cm)/m, y = rev(row(cm))/m, rot = rot,\rvp=vp, gp=gpar(cex = cex, col = cm))\r}\r# print 60 nama warna pertama\rshowCols(bg=\u0026quot;gray20\u0026quot;, cl=colors()[1:60], rot=30, cex=0.9)\r## Loading required package: grid\r\rFigure 41: Nama warna\r\rReferensi\nMaindonald, J.H. 2008. Using R for Data Analysis and Graphics Introduction, Code and Commentary. Centre for Mathematics and Its Applications Australian National University.\rScherber, C. 2007. An introduction to statistical data analysis using R. R_Manual Goettingen.\rVenables, W.N. Smith D.M. and R Core Team. 2018. An Introduction to R. R Manuals.\rSTHDA. R Base Graphs. http://www.sthda.com/english/wiki/r-base-graphs\r\r\r\r","date":1552064400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1552064400,"objectID":"4921e253b061a9caad56dc8e69865c64","permalink":"/tutorial/04_visualisasi-data-menggunakan-fungsi-dasar-r/","publishdate":"2019-03-09T00:00:00+07:00","relpermalink":"/tutorial/04_visualisasi-data-menggunakan-fungsi-dasar-r/","section":"tutorial","summary":"body{\rtext-align: justify}\r\r\rDaftar Isi\n\rVisualisasi Data Menggunakan Fungsi plot\rMatriks Scatterplot\rBox plot\rBar Plot\rLine Plot\rPie Chart\rHistogram dan Density Plot\rQQ Plot\rDot Chart\rKustomisasi Parameter Grafik\r\r\r4.1 Visualisasi Data Menggunakan Fungsi plot()\rFungsi plot() merupakan fungsi umum yang digunakan untuk membuat plot pada R. Format dasarnya adalah sebagai berikut:\nplot(x, y, type=\u0026quot;p\u0026quot;)\r\rNote: \n\rx dan y: titik koordinat plot Berupa variabel dengan panjang atau jumlah observasi yang sama.","tags":null,"title":"4. Visualisasi Data Menggunakan Fungsi Dasar R","type":"docs"},{"authors":["Mohammad Rosidi, S.T."],"categories":[],"content":" from IPython.core.display import Image Image('https://www.python.org/static/community_logos/python-logo-master-v3-TM-flattened.png')  print(\u0026quot;Welcome to Academic!\u0026quot;)  Welcome to Academic!  Install Python and Jupyter Install Anaconda which includes Python 3 and Jupyter notebook.\nOtherwise, for advanced users, install Jupyter notebook with pip3 install jupyter.\nCreate a new blog post as usual Run the following commands in your Terminal, substituting \u0026lt;MY_WEBSITE_FOLDER\u0026gt; and my-post with the file path to your Academic website folder and a name for your blog post (without spaces), respectively:\ncd \u0026lt;MY_WEBSITE_FOLDER\u0026gt; hugo new --kind post post/my-post cd \u0026lt;MY_WEBSITE_FOLDER\u0026gt;/content/post/my-post/  Create or upload a Jupyter notebook Run the following command to start Jupyter within your new blog post folder. Then create a new Jupyter notebook (New \u0026gt; Python Notebook) or upload a notebook.\njupyter notebook  Convert notebook to Markdown jupyter nbconvert Untitled.ipynb --to markdown --NbConvertApp.output_files_dir=. # Copy the contents of Untitled.md and append it to index.md: cat Untitled.md | tee -a index.md # Remove the temporary file: rm Untitled.md  Edit your post metadata Open index.md in your text editor and edit the title etc. in the front matter according to your preference.\nTo set a featured image, place an image named featured into your post\u0026rsquo;s folder.\nFor other tips, such as using math, see the guide on writing content with Academic.\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"6e929dc84ed3ef80467b02e64cd2ed64","permalink":"/post/jupyter/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/post/jupyter/","section":"post","summary":"Learn how to blog in Academic using Jupyter notebooks","tags":[],"title":"Display Jupyter Notebooks with Academic","type":"post"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.\n  Slides can be added in a few ways:\n Create slides using Academic\u0026rsquo;s Slides feature and link using url_slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1483203600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483203600,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"/talk/example/","publishdate":"2017-01-01T00:00:00+07:00","relpermalink":"/talk/example/","section":"talk","summary":"An example talk using Academic's Markdown slides feature.","tags":[],"title":"Example Talk","type":"talk"},{"authors":null,"categories":null,"content":"This project is a website in the form of a collection of topics related to data analysis and modeling in the environmental field. This website is structured in such a way as to contain a number of material related to statistics, advanced mathematics, environmental engineering modeling, and operations research in the field of environmental engineering.\nThe website is updated every week where each author update will share on the author\u0026rsquo;s social media account. Readers can continue to follow the writing on the website by visiting the site environmental learning.wordpress.com.\n","date":1461690000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461690000,"objectID":"a0e4c49a97de4c62f04b541c8d10b613","permalink":"/project/environmental-learning-website/","publishdate":"2016-04-27T00:00:00+07:00","relpermalink":"/project/environmental-learning-website/","section":"project","summary":"This project is a website in the form of a collection of topics related to data analysis and modeling in the environmental field. This website is structured in such a way as to contain a number of material related to statistics, advanced mathematics, environmental engineering modeling, and operations research in the field of environmental engineering.\nThe website is updated every week where each author update will share on the author\u0026rsquo;s social media account.","tags":["R","Statistics"],"title":"Environmental Learning Website Project","type":"project"},{"authors":null,"categories":null,"content":"","date":1461690000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461690000,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"/project/external-project/","publishdate":"2016-04-27T00:00:00+07:00","relpermalink":"/project/external-project/","section":"project","summary":"Author repository collection on `Github`.","tags":["R"],"title":"External Project","type":"project"},{"authors":["Mohammad Rosidi, S.T."],"categories":null,"content":" Academic makes it easy to create a beautiful website for free using Markdown. Customize anything on your site with widgets, themes, and language packs.\nFollow our easy step by step guide to learn how to build your own free website with Academic. Check out the personal demo or the business demo of what you\u0026rsquo;ll get in less than 10 minutes.\n View the documentation Ask a question Request a feature or report a bug Updating? View the Update Guide and Release Notes Support development of Academic:  Donate a coffee Become a backer on Patreon Decorate your laptop or journal with an Academic sticker Wear the T-shirt   \nKey features:\n Easily manage various content including homepage, blog posts, publications, talks, and projects Extensible via color themes and widgets/plugins Write in Markdown for easy formatting and code highlighting, with LaTeX for mathematical expressions Social/academic network linking, Google Analytics, and Disqus comments Responsive and mobile friendly Simple and refreshing one page design Multilingual and easy to customize  Color Themes Academic is available in different color themes and font themes.\n         Ecosystem  Academic Admin: An admin tool to import publications from BibTeX or import assets for an offline site Academic Scripts: Scripts to help migrate content to new versions of Academic  Install You can choose from one of the following four methods to install:\n one-click install using your web browser (recommended) install on your computer using Git with the Command Prompt/Terminal app install on your computer by downloading the ZIP files install on your computer with RStudio  Quick install using your web browser  Install Academic with Netlify  Netlify will provide you with a customizable URL to access your new site  On GitHub, go to your newly created academic-kickstart repository and edit config.toml to personalize your site. Shortly after saving the file, your site will automatically update Read the Quick Start Guide to learn how to add Markdown content. For inspiration, refer to the Markdown content which powers the Demo  Install with Git Prerequisites:\n Download and install Git Download and install Hugo   Fork the Academic Kickstart repository and clone your fork with Git:\ngit clone https://github.com/sourcethemes/academic-kickstart.git My_Website  Note that if you forked Academic Kickstart, the above command should be edited to clone your fork, i.e. replace sourcethemes with your GitHub username.\n Initialize the theme:\ncd My_Website git submodule update --init --recursive   Install with ZIP  Download and extract Academic Kickstart Download and extract the Academic theme to the themes/academic/ folder from the above step  Install with RStudio View the guide to installing Academic with RStudio\nQuick start  If you installed on your computer, view your new website by running the following command:\nhugo server  Now visit localhost:1313 and your new Academic powered website will appear. Otherwise, if using Netlify, they will provide you with your URL.\n Read the Quick Start Guide to learn how to add Markdown content, customize your site, and deploy it. For inspiration, refer to the Markdown content which powers the Demo\n Build your site by running the hugo command. Then host it for free using Github Pages or Netlify (refer to the first installation method). Alternatively, copy the generated public/ directory (by FTP, Rsync, etc.) to your production web server (such as a university\u0026rsquo;s hosting service).\n  Updating Feel free to star the project on Github to help keep track of updates and check out the release notes prior to updating your site.\nBefore updating the framework, it is recommended to make a backup of your entire website directory (or at least your themes/academic directory) and record your current version number.\nBy default, Academic is installed as a Git submodule which can be updated by running the following command:\ngit submodule update --remote --merge  Check out the update guide for full instructions and alternative methods.\nFeedback \u0026amp; Contributing Please use the issue tracker to let me know about any bugs or feature requests, or alternatively make a pull request.\nFor support, head over to the Hugo discussion forum.\nLicense Copyright 2016-present George Cushen.\nReleased under the MIT license.\n","date":1461085200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1515776400,"objectID":"279b9966ca9cf3121ce924dca452bb1c","permalink":"/post/getting-started/","publishdate":"2016-04-20T00:00:00+07:00","relpermalink":"/post/getting-started/","section":"post","summary":"Create a beautifully simple website or blog in under 10 minutes.","tags":["Academic"],"title":"Academic: the website designer for Hugo","type":"post"},{"authors":null,"categories":["R"],"content":"\rR Markdown\rThis is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nYou can embed an R code chunk like this:\nsummary(cars)\r## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00\rfit \u0026lt;- lm(dist ~ speed, data = cars)\rfit\r## ## Call:\r## lm(formula = dist ~ speed, data = cars)\r## ## Coefficients:\r## (Intercept) speed ## -17.579 3.932\r\rIncluding Plots\rYou can also embed plots. See Figure 1 for example:\npar(mar = c(0, 1, 0, 1))\rpie(\rc(280, 60, 20),\rc(\u0026#39;Sky\u0026#39;, \u0026#39;Sunny side of pyramid\u0026#39;, \u0026#39;Shady side of pyramid\u0026#39;),\rcol = c(\u0026#39;#0292D8\u0026#39;, \u0026#39;#F7EA39\u0026#39;, \u0026#39;#C4B632\u0026#39;),\rinit.angle = -50, border = NA\r)\r\rFigure 1: A fancy pie chart.\r\r\r","date":1437703994,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1437703994,"objectID":"10065deaa3098b0da91b78b48d0efc71","permalink":"/post/2015-07-23-r-rmarkdown/","publishdate":"2015-07-23T21:13:14-05:00","relpermalink":"/post/2015-07-23-r-rmarkdown/","section":"post","summary":"R Markdown\rThis is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com.\nYou can embed an R code chunk like this:\nsummary(cars)\r## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.","tags":["R Markdown","plot","regression"],"title":"Hello R Markdown","type":"post"},{"authors":null,"categories":null,"content":"\r\rMoh Rosidi - Curriculum Vitae\r\r\r\r\rMoh. Rosidi\rMaster Student\r\r\re: rosidi.mohammad@yahoo.com\rw: environmental-data-modeling.netlify.com/\rm: 082128770438\r\r\r\r\r\r\rPersonal Profile\r\rI am a master’s student in Environmental Engineering, Institut Teknologi Bandung with fields of Technology and Environmental Management. Currently active writers in communities such as R Indonesia and Machine Learning ID. Besides being active in the community, I also active in writing blogs. The theme of the blog is related to data analytics and environmental modeling.\n\r\r\r\r\rWork Experience\r\r\rPROPER Assessment Assistant KLHK\rAugust 2017 - August 2017\nResponsibilities include:\r- Check and evaluate company environmental management reports\r- make reports regarding the management and PROPER rating of the company (eg: black, red, or blue)\n\r\rMember of the Field Surveyor Team Dinas PU Cipta Karya\rAugust 2017 - September 2017\nResponsibilities include:\r- Conduct field surveys to verify data on homes that do not have defecation facilities\r- Make technology recommendations (eg individual septic tanks, communal septic tanks, or local waste treatment plants) based on the results of field surveys\n\r\rAssistant Professor at ITS\rAugust 2017 - August 2018\nResponsibilities include:\r- Helping lecturer research\r- Assist the process of preparing teaching books\n\r\r\r\r\rKey Skills\r\rEnvironmental Management\rEnvironmental Modeling\rData Analytics\rR\rPhyton\rSPSS\rSystem Dynamic\rMS. Office\rStatistics\r\r\r\r\r\rEducation\r\r\rEnvironmental Engineering/Institut Teknologi Bandung\rMaster Student\nThe field of study in Technology and Environmental Management with the research being worked on concerns the design of environmental databases.\n\r\rEnvironmental Engineering/Institut Teknologi Sepuluh Nopember\rSarjana Teknik\nLearn about environmental science and design of environmental infrastructure with research on the design of fine paper industry waste water treatment plants.\n\r\r\r\r\r\rvar gaJsHost = ((\"https:\" == document.location.protocol) ? \"https://ssl.\" : \"http://www.\");\rdocument.write(unescape(\"%3Cscript src='\" + gaJsHost + \"google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E\"));\r\rvar pageTracker = _gat._getTracker(\"UA-3753241-1\");\rpageTracker._initData();\rpageTracker._trackPageview();\r\r\r","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"9780949a3024bbdfdb7ce88dfaa4afe3","permalink":"/cv/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/cv/","section":"","summary":"Moh Rosidi - Curriculum Vitae\r\r\r\r\rMoh. Rosidi\rMaster Student\r\r\re: rosidi.mohammad@yahoo.com\rw: environmental-data-modeling.netlify.com/\rm: 082128770438\r\r\r\r\r\r\rPersonal Profile\r\rI am a master’s student in Environmental Engineering, Institut Teknologi Bandung with fields of Technology and Environmental Management. Currently active writers in communities such as R Indonesia and Machine Learning ID. Besides being active in the community, I also active in writing blogs.","tags":null,"title":"","type":"page"},{"authors":["Mohammad Rosidi","Mohammad Razif"],"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"98a16eebf121a69c91ade830fd98e0bc","permalink":"/publication/perancangan-ipal/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/publication/perancangan-ipal/","section":"publication","summary":"The paper industry is an industry that produces large amounts of liquid waste. In addition, the content of pollutant parameters in the paper coloring process is very high. Based on East Java Governor no. 72 of 2013 there are 5 quality standards for wastewater that must be met before being discharged into water bodies. The parameters that need to be processed are pH, COD, BOD, TSS, and Pb. In the design used primary data in the form of debit data and waste characteristics taken from the fine paper industry of PT. Sido Sidoarjo. Waste treated comes from the paper coloring process. Characteristics of treated waste have a value of TSS41000 mg / l, COD 45384 mg / l, BOD 8300 mg / l, Pb 0.56 mg / l and pH 7.7. The planned WWTP unit consists of precedimentation, equalization tanks, fast stirring tanks , slow stirrer, sedimentation 2, and ABR-ABF. Calculation of BOQ and RAB using HSPK Surabaya City 2015 and obtained a figure of Rp217,650,760 for the construction of all units of WWTP.","tags":[],"title":"Perancangan Instalasi Pengolahan Air Limbah (IPAL) Industri Kertas Halus","type":"publication"},{"authors":null,"categories":null,"content":" Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = \\;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \nA fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears  Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view   Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links   night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links  Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }  Questions? Ask\nDocumentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c2915ec5da95791851caafdcba9664af","permalink":"/slides/example-slides/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/slides/example-slides/","section":"slides","summary":"Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$","tags":null,"title":"Slides","type":"slides"}]